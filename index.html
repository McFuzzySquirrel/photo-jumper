<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Jumper - Platform Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .lan-hint {
            margin-top: -6px;
            margin-bottom: 18px;
            background: #f7f7ff;
            border: 1px solid #e3e3ff;
            border-radius: 12px;
            padding: 12px;
            display: none;
        }

        .lan-hint.open {
            display: block;
        }

        .lan-hint .row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .lan-hint .label {
            font-weight: bold;
            color: #333;
        }

        .lan-hint code {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px 10px;
            display: inline-block;
            max-width: 100%;
            overflow-wrap: anywhere;
        }

        .lan-hint .note {
            margin-top: 8px;
            color: #666;
            font-size: 13px;
        }

        .lan-hint .note strong {
            color: #333;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #fileInput, #cameraInput {
            display: none;
        }

        .game-canvas-container {
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 3px solid #333;
            border-radius: 10px;
            max-width: 100%;
            background: #87ceeb;
            display: none;
        }

        .instructions {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .instructions p {
            margin-bottom: 8px;
            color: #666;
        }

        .game-info {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: none;
        }

        .preview-canvas {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 1000;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 520px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        }

        .modal-content h3 {
            margin-bottom: 8px;
            color: #333;
        }

        .modal-content .hint {
            margin-bottom: 14px;
            color: #666;
            font-size: 14px;
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            text-align: left;
        }

        .form-row label {
            font-weight: bold;
            color: #333;
        }

        .form-row select,
        .form-row textarea {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 10px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-row textarea {
            resize: vertical;
            min-height: 110px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .status {
            margin-top: 10px;
            min-height: 18px;
            color: #333;
            font-size: 14px;
        }

        .status.error {
            color: #b00020;
        }

        .status.success {
            color: #0b6b0b;
        }

        /* Mobile control buttons */
        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            user-select: none;
        }

        .mobile-controls.visible {
            display: flex;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 15px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            touch-action: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .control-btn.jump-btn {
            width: 90px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        /* Intro screen styles */
        .intro-screen {
            text-align: center;
            padding: 40px 20px;
        }

        .intro-screen.hidden {
            display: none;
        }

        .intro-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .intro-screen .tagline {
            font-size: 1.3em;
            color: #555;
            margin-bottom: 30px;
        }

        .intro-screen .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
            text-align: left;
        }

        .intro-screen .feature {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .intro-screen .feature h3 {
            margin-bottom: 8px;
            color: #667eea;
        }

        .intro-screen .feature p {
            color: #666;
            margin: 0;
        }

        .intro-screen .cta-button {
            font-size: 1.2em;
            padding: 16px 32px;
            margin-top: 20px;
        }

        /* Game screen styles */
        .game-screen {
            display: none;
        }

        .game-screen.active {
            display: block;
        }

        /* Fullscreen styles */
        .game-canvas-container.fullscreen {
            position: fixed;
            inset: 0;
            z-index: 100;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .game-canvas-container.fullscreen #gameCanvas {
            max-width: 95vw;
            max-height: 95vh;
            border-radius: 10px;
        }

        /* Hide non-essential elements when canvas is fullscreen */
        .game-canvas-container.fullscreen ~ .instructions {
            display: none;
        }

        .game-screen:has(.game-canvas-container.fullscreen) .upload-section {
            display: none;
        }

        .game-screen:has(.game-canvas-container.fullscreen) h1 {
            display: none;
        }

        /* Position game info overlay when fullscreen */
        .game-canvas-container.fullscreen ~ .game-info,
        .game-screen:has(.game-canvas-container.fullscreen) .game-info {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Position mobile controls when fullscreen */
        .game-canvas-container.fullscreen ~ .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
        }

        /* Exit fullscreen button */
        .exit-fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 101;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            display: none;
        }

        .exit-fullscreen-btn.visible {
            display: block;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
            }

            button {
                padding: 10px 20px;
                font-size: 14px;
            }

            .container {
                padding: 20px;
            }

            .intro-screen h1 {
                font-size: 2em;
            }

            .intro-screen .tagline {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <button class="exit-fullscreen-btn" id="exitFullscreenBtn">‚úï Exit Game</button>
    
    <div class="container">
        <!-- Intro Screen -->
        <div class="intro-screen" id="introScreen">
            <h1>üéÆ Photo Jumper</h1>
            <p class="tagline">Turn your photos into playable platformer levels!</p>
            
            <div class="features">
                <div class="feature">
                    <h3>üì∏ Upload or Capture</h3>
                    <p>Use any photo - the game detects edges and brightness to create platforms</p>
                </div>
                <div class="feature">
                    <h3>üéØ Reach the Goal</h3>
                    <p>Jump from platform to platform to reach the golden star at the top</p>
                </div>
                <div class="feature">
                    <h3>‚ö° Fast & Fun</h3>
                    <p>Quick platformer action with responsive controls</p>
                </div>
            </div>

            <button class="cta-button" id="startGameBtn">Get Started</button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <h1>üéÆ Photo Jumper</h1>
            
            <div class="upload-section">
            <div class="button-group">
                <button id="uploadBtn">üìÅ Upload Photo</button>
                <button id="cameraBtn">üì∑ Take Photo</button>
                <button id="resetBtn" style="display: none;">üîÑ New Photo</button>
                <button id="feedbackBtn" type="button">üìù Feedback</button>
            </div>

            <div id="lanHint" class="lan-hint" aria-live="polite">
                <div class="row">
                    <div>
                        <div class="label">Share link</div>
                        <code id="lanUrl"></code>
                    </div>
                    <button id="copyLinkBtn" type="button">Copy</button>
                </div>
                <div id="lanNote" class="note"></div>
            </div>

            <input type="file" id="fileInput" accept="image/*">
            <input type="file" id="cameraInput" accept="image/*" capture="environment">
        </div>

        <div class="game-info" id="gameInfo">
            Score: <span id="score">0</span> | Time: <span id="time">0</span>s
        </div>

        <div class="game-canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <canvas id="previewCanvas" class="preview-canvas"></canvas>
        </div>

        <!-- Mobile control buttons -->
        <div class="mobile-controls" id="mobileControls">
            <button class="control-btn" id="leftBtn" aria-label="Move left">‚óÄ</button>
            <button class="control-btn jump-btn" id="jumpBtn" aria-label="Jump">‚ñ≤</button>
            <button class="control-btn" id="rightBtn" aria-label="Move right">‚ñ∂</button>
        </div>

        <div class="instructions">
            <h3>How to Play:</h3>
            <p>1. Upload a photo or take one with your camera</p>
            <p>2. The photo will be converted into platforms based on brightness</p>
            <p>3. Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move (or touch controls on mobile)</p>
            <p>4. Press <strong>Space</strong> or <strong>Up Arrow</strong> to jump</p>
            <p>5. Navigate from the green start platform to the golden goal star!</p>
            <p>6. Press <strong>R</strong> to respawn if you get stuck</p>
            <p><label><input type="checkbox" id="debugOverlayToggle"> Debug overlay</label></p>
        </div>
        </div>
        <!-- End Game Screen -->

        <div id="feedbackModal" class="modal" aria-hidden="true">
            <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="feedbackTitle">
                <h3 id="feedbackTitle">Send Feedback</h3>
                <p class="hint">Text-only feedback is saved locally on the host machine.</p>

                <form id="feedbackForm">
                    <div class="form-row">
                        <label for="feedbackDeviceType">Device type</label>
                        <select id="feedbackDeviceType" required>
                            <option value="unknown">Unknown</option>
                            <option value="desktop">Desktop / Laptop</option>
                            <option value="tablet">Tablet</option>
                            <option value="mobile">Mobile</option>
                        </select>
                    </div>

                    <div class="form-row">
                        <label for="feedbackMessage">Message</label>
                        <textarea id="feedbackMessage" maxlength="2000" placeholder="What worked well? What was confusing or buggy?" required></textarea>
                    </div>

                    <div class="modal-actions">
                        <button type="button" id="feedbackCancelBtn">Cancel</button>
                        <button type="submit" id="feedbackSubmitBtn">Send</button>
                    </div>
                    <div id="feedbackStatus" class="status" aria-live="polite"></div>
                </form>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        
        const introScreen = document.getElementById('introScreen');
        const gameScreen = document.getElementById('gameScreen');
        const startGameBtn = document.getElementById('startGameBtn');
        const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
        const container = document.querySelector('.container');
        const gameCanvasContainer = document.querySelector('.game-canvas-container');
        
        const uploadBtn = document.getElementById('uploadBtn');
        const cameraBtn = document.getElementById('cameraBtn');
        const resetBtn = document.getElementById('resetBtn');
        const feedbackBtn = document.getElementById('feedbackBtn');
        const fileInput = document.getElementById('fileInput');
        const cameraInput = document.getElementById('cameraInput');
        const gameInfo = document.getElementById('gameInfo');
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');

        const feedbackModal = document.getElementById('feedbackModal');
        const feedbackForm = document.getElementById('feedbackForm');
        const feedbackDeviceType = document.getElementById('feedbackDeviceType');
        const feedbackMessage = document.getElementById('feedbackMessage');
        const feedbackCancelBtn = document.getElementById('feedbackCancelBtn');
        const feedbackSubmitBtn = document.getElementById('feedbackSubmitBtn');
        const feedbackStatus = document.getElementById('feedbackStatus');

        const lanHint = document.getElementById('lanHint');
        const lanUrl = document.getElementById('lanUrl');
        const lanNote = document.getElementById('lanNote');
        const copyLinkBtn = document.getElementById('copyLinkBtn');

        const debugOverlayToggle = document.getElementById('debugOverlayToggle');

        // Mobile control buttons
        const mobileControls = document.getElementById('mobileControls');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');

        const FEEDBACK_TOKEN_STORAGE_KEY = 'photoJumperFeedbackToken';

        // Game configuration constants
        const PLAYER_SIZE = 20;
        const PLAYER_SPEED = 5;
        const PLAYER_JUMP_POWER = 12;
        const PLAYER_GRAVITY = 0.5;

        const GRID_SIZE = 20;  // Reduced from 30 to detect more platforms (1x player size)
        const BRIGHTNESS_THRESHOLD = 140;  // Increased from 128 to require brighter areas for platforms
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
        const EDGE_DETECTION_THRESHOLD = 30;  // Reduced from 40 for better edge detection
        const EDGE_BRIGHTNESS_THRESHOLD = 200;  // Increased from 180 to accept more edge-detected platforms

        // Gameplay-first platform constraints
        const PLATFORM_MIN_WIDTH = 40;
        const PLATFORM_THICKNESS = 14;
        const PLATFORM_MERGE_GAP_PX = 0;
        const HELPERS_MAX_COUNT = 14;

        const DEBUG_DEFAULT_ENABLED = false;
        
        // Player spawn and reserved area constants
        const PLAYER_SPAWN_X = 40;
        const PLAYER_SPAWN_Y_OFFSET = 100; // Pixels above canvas bottom
        const START_AREA_WIDTH = 140;  // Wider to ensure clear start area
        const START_AREA_HEIGHT = 100;  // Taller to ensure clear start area
        const GOAL_AREA_WIDTH = 100;
        const GOAL_AREA_HEIGHT = 80;
        
        // Stuck detection constants
        const STUCK_CHECK_INTERVAL = 3000;  // 3 seconds
        const STUCK_MOVEMENT_THRESHOLD = 5;  // pixels

        let gameRunning = false;
        let platforms = [];
        let player = null;
        let goal = null;  // Goal/end point for the level
        let playerSpawnY = 0;  // Calculated spawn Y position
        let keys = {};
        let score = 0;
        let startTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchJumping = false;
        let backgroundImage = null; // Store the uploaded photo for background
        let gameWon = false;  // Track if player reached the goal

        let debugOverlayEnabled = DEBUG_DEFAULT_ENABLED;
        let debugSolidGrid = null;
        let debugGridSize = GRID_SIZE;
        let debugHelperPlatforms = [];

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = PLAYER_SIZE;
                this.height = PLAYER_SIZE;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = PLAYER_SPEED;
                this.jumpPower = PLAYER_JUMP_POWER;
                this.gravity = PLAYER_GRAVITY;
                this.onGround = false;
                this.lastPositionTime = Date.now();
                this.lastX = x;
                this.lastY = y;
                this.stuckCheckInterval = STUCK_CHECK_INTERVAL;
            }

            update() {
                // Horizontal movement
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    this.velocityX = -this.speed;
                } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    this.velocityX = this.speed;
                } else {
                    this.velocityX *= 0.7; // Reduced friction for more responsive feel
                }

                // Jumping
                if ((keys['ArrowUp'] || keys['w'] || keys['W'] || keys[' '] || touchJumping) && this.onGround) {
                    this.velocityY = -this.jumpPower;
                    this.onGround = false;
                    touchJumping = false; // Reset touch jump
                }

                // Apply gravity
                this.velocityY += this.gravity;

                // Update horizontal position
                this.x += this.velocityX;

                // Check horizontal platform collisions
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Push out from sides
                        if (this.x + this.width / 2 < platform.x + platform.width / 2) {
                            this.x = platform.x - this.width;
                        } else {
                            this.x = platform.x + platform.width;
                        }
                        this.velocityX = 0;
                    }
                }

                // Update vertical position
                this.y += this.velocityY;

                // Check vertical platform collisions
                this.onGround = false;
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Landing on top of platform
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                        // Hitting platform from below
                        else if (this.velocityY < 0 && this.y - this.velocityY >= platform.y + platform.height) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                    }
                }

                // Boundary checks
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

                // Check if player fell off
                if (this.y > canvas.height) {
                    this.respawn();
                }

                // Stuck detection: if player hasn't moved significantly in a while
                const now = Date.now();
                const distMoved = Math.sqrt((this.x - this.lastX) ** 2 + (this.y - this.lastY) ** 2);
                
                if (now - this.lastPositionTime > this.stuckCheckInterval) {
                    if (distMoved < STUCK_MOVEMENT_THRESHOLD && this.onGround) {
                        // Player appears stuck, auto-respawn
                        this.respawn();
                        // Reset tracking variables after respawn to prevent immediate re-triggering
                        this.lastX = this.x;
                        this.lastY = this.y;
                        this.lastPositionTime = Date.now();
                    } else {
                        // Update last known position when not stuck
                        this.lastX = this.x;
                        this.lastY = this.y;
                        this.lastPositionTime = now;
                    }
                }

                // Update score based on progress and time efficiency
                // Score = platforms reached * 100 - time penalty
                const heightProgress = Math.max(0, Math.floor((canvas.height - this.y) / 10));
                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                const timePenalty = Math.floor(elapsedSeconds / 2); // -1 point every 2 seconds
                const currentScore = Math.max(0, heightProgress * 2 - timePenalty);
                
                if (currentScore > score) {
                    score = currentScore;
                    scoreElement.textContent = score;
                }
            }

            checkCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            respawn() {
                this.x = PLAYER_SPAWN_X;
                this.y = playerSpawnY;  // Use the calculated spawn Y position
                this.velocityX = 0;
                this.velocityY = 0;
                score = Math.max(0, score - 10);
                scoreElement.textContent = score;
            }

            draw() {
                // Draw shadow/outline for better visibility on photo
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x + 2, this.y + 2, this.width, this.height);
                
                // Draw main body
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw border for visibility
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Draw eyes (adjusted for smaller size)
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x + 4, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 12, this.y + 5, 4, 4);
                
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x + 5, this.y + 6, 2, 2);
                ctx.fillRect(this.x + 13, this.y + 6, 2, 2);
            }
        }

        // Goal class - represents the end goal for the level
        class Goal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.animation = 0;
            }

            update() {
                this.animation += 0.1;
            }

            checkCollision(player) {
                return player.x < this.x + this.width &&
                       player.x + player.width > this.x &&
                       player.y < this.y + this.height &&
                       player.y + player.height > this.y;
            }

            draw() {
                // Draw animated star/goal
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                const outerRadius = 15 + Math.sin(this.animation) * 2;
                const innerRadius = 7;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.animation * 0.5);
                
                // Draw star
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                
                // Gradient fill
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, outerRadius);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(1, '#FFA500');
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.strokeStyle = '#FF8C00';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        // Platform class
        class Platform {
            constructor(x, y, width, height, color, kind = 'photo') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.kind = kind;
            }

            draw() {
                // Add shadow for depth
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Draw platform fill
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Reset shadow for outline
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw thick black outline for visibility
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Add highlight on top edge for 3D effect
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 1);
                ctx.lineTo(this.x + this.width, this.y + 1);
                ctx.stroke();
            }
        }

        // Process image and create platforms
        function processImage(image) {
            // Store the image for background rendering
            backgroundImage = image;

            // Set canvas size based on image aspect ratio
            const maxWidth = 800;
            const maxHeight = 600;
            let width = image.width;
            let height = image.height;

            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }

            canvas.width = width;
            canvas.height = height;
            previewCanvas.width = width;
            previewCanvas.height = height;

            // Draw image to preview canvas
            previewCtx.drawImage(image, 0, 0, width, height);
            const imageData = previewCtx.getImageData(0, 0, width, height);
            const data = imageData.data;

            // Create platforms based on brightness and edge detection
            platforms = [];
            const gridSize = GRID_SIZE;
            const brightnessThreshold = BRIGHTNESS_THRESHOLD;

            debugGridSize = gridSize;
            debugHelperPlatforms = [];
            debugSolidGrid = null;

            // Helper function to detect edges (helps identify objects better)
            function hasEdge(x, y, width, height, data) {
                // Allow edge detection near boundaries, just need 1-pixel neighbors
                if (x === 0 || y === 0 || x + 1 >= width || y + 1 >= height) {
                    return false;
                }
                
                // Get center brightness
                const centerI = (y * width + x) * 4;
                const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;
                
                // Check brightness difference with adjacent neighbors (1 pixel away)
                let maxDiff = 0;
                const checkPositions = [
                    [x - 1, y], [x + 1, y],
                    [x, y - 1], [x, y + 1]
                ];
                
                for (const [px, py] of checkPositions) {
                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const i = (py * width + px) * 4;
                        const neighborBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const diff = Math.abs(centerBrightness - neighborBrightness);
                        maxDiff = Math.max(maxDiff, diff);
                    }
                }
                // Significant brightness difference indicates an edge
                return maxDiff > EDGE_DETECTION_THRESHOLD;
            }

            function buildSolidGrid() {
                const cellsX = Math.ceil(width / gridSize);
                const cellsY = Math.ceil(height / gridSize);
                const solid = Array.from({ length: cellsY }, () => Array.from({ length: cellsX }, () => false));
                const brightness = Array.from({ length: cellsY }, () => Array.from({ length: cellsX }, () => 255));

                for (let cy = 0; cy < cellsY; cy++) {
                    for (let cx = 0; cx < cellsX; cx++) {
                        const x = cx * gridSize;
                        const y = cy * gridSize;

                        let totalBrightness = 0;
                        let pixelCount = 0;

                        // Calculate average brightness of grid cell
                        for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4;
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                const bness = (r + g + b) / 3;
                                totalBrightness += bness;
                                pixelCount++;
                            }
                        }

                        const avgBrightness = pixelCount > 0 ? (totalBrightness / pixelCount) : 255;
                        brightness[cy][cx] = avgBrightness;

                        // Create solid hint if brightness is below threshold OR at edges (better object detection)
                        const isEdge = hasEdge(x, y, width, height, data);

                        // Reserve start area (bottom-left) and goal area (top-right) - don't generate photo platforms there
                        const isStartArea = (x < START_AREA_WIDTH && y > height - START_AREA_HEIGHT);
                        const isGoalArea = (x > width - GOAL_AREA_WIDTH && y < GOAL_AREA_HEIGHT);

                        const isSolidHint = (!isStartArea && !isGoalArea) &&
                            (avgBrightness < brightnessThreshold || (isEdge && avgBrightness < EDGE_BRIGHTNESS_THRESHOLD));

                        solid[cy][cx] = Boolean(isSolidHint);
                    }
                }

                return { solid, brightness, cellsX, cellsY };
            }

            function platformColorFromBrightness(avgBrightness) {
                const alpha = 0.68;
                const colorValue = Math.floor(avgBrightness * 0.6);
                return `rgba(${colorValue}, ${colorValue}, ${colorValue}, ${alpha})`;
            }

            function extractTopSurfacesFromGrid(grid) {
                const { solid, brightness, cellsX, cellsY } = grid;
                const segments = [];

                for (let cy = 0; cy < cellsY; cy++) {
                    for (let cx = 0; cx < cellsX; cx++) {
                        if (!solid[cy][cx]) continue;
                        const aboveSolid = (cy > 0) ? solid[cy - 1][cx] : false;
                        if (aboveSolid) continue;

                        const x = cx * gridSize;
                        const y = cy * gridSize;
                        const w = Math.min(gridSize, width - x);
                        if (w <= 0) continue;

                        segments.push({
                            x,
                            y,
                            width: w,
                            brightness: brightness[cy][cx]
                        });
                    }
                }

                // Merge adjacent segments on the same y into longer platforms
                const merged = [];
                let current = null;

                for (const seg of segments) {
                    if (!current) {
                        current = { ...seg };
                        continue;
                    }

                    const touchesSameRow = seg.y === current.y;
                    const isAdjacent = seg.x <= (current.x + current.width + PLATFORM_MERGE_GAP_PX);

                    if (touchesSameRow && isAdjacent) {
                        const end = Math.max(current.x + current.width, seg.x + seg.width);
                        const totalWidth = end - current.x;
                        const weightedBrightness = ((current.brightness * current.width) + (seg.brightness * seg.width)) / (current.width + seg.width);
                        current.width = totalWidth;
                        current.brightness = weightedBrightness;
                    } else {
                        merged.push(current);
                        current = { ...seg };
                    }
                }
                if (current) merged.push(current);

                // Convert to platform objects, enforcing minimum width + thickness
                const platformsOut = [];
                for (const m of merged) {
                    if (m.width < PLATFORM_MIN_WIDTH) continue;
                    const color = platformColorFromBrightness(m.brightness);
                    platformsOut.push(new Platform(m.x, m.y, m.width, PLATFORM_THICKNESS, color, 'photo'));
                }

                return platformsOut;
            }

            function intervalGap(a1, a2, b1, b2) {
                if (a2 < b1) return b1 - a2;
                if (b2 < a1) return a1 - b2;
                return 0;
            }

            function getJumpLimits() {
                const jumpPower = PLAYER_JUMP_POWER;
                const gravity = PLAYER_GRAVITY;
                const speed = PLAYER_SPEED;

                const maxJumpUp = (jumpPower * jumpPower) / (2 * gravity);
                const maxHangTime = (2 * jumpPower) / gravity;
                const maxJumpDx = speed * maxHangTime;

                // Conservative safety margins (gameplay-first): if we say reachable, it should be reachable.
                return {
                    maxJumpUp: maxJumpUp * 0.9,
                    maxJumpDx: maxJumpDx * 0.85,
                    jumpPower,
                    gravity,
                    speed
                };
            }

            function canReachPlatform(from, to, limits) {
                if (from === to) return false;

                const fromLeft = from.x;
                const fromRight = from.x + from.width;
                const toLeft = to.x;
                const toRight = to.x + to.width;

                const dx = intervalGap(fromLeft, fromRight, toLeft, toRight);
                if (dx > limits.maxJumpDx) return false;

                const up = from.y - to.y;
                if (up <= 0) {
                    // Dropping down is allowed; keep conservative horizontal requirement only.
                    return true;
                }

                if (up > limits.maxJumpUp) return false;

                // More accurate horizontal limit for higher targets: time to reach that height (descending).
                const disc = (limits.jumpPower * limits.jumpPower) - (2 * limits.gravity * up);
                if (disc < 0) return false;
                const tLanding = (limits.jumpPower + Math.sqrt(disc)) / limits.gravity;
                const dxLimit = Math.min(limits.maxJumpDx, limits.speed * tLanding * 0.9);
                return dx <= dxLimit;
            }

            function isReachable(startPlatform, goalPlatform, allPlatforms, limits) {
                const visited = new Set();
                const queue = [startPlatform];
                visited.add(startPlatform);

                while (queue.length) {
                    const current = queue.shift();
                    if (current === goalPlatform) return true;

                    for (const next of allPlatforms) {
                        if (visited.has(next)) continue;
                        if (!canReachPlatform(current, next, limits)) continue;
                        visited.add(next);
                        queue.push(next);
                    }
                }

                return false;
            }

            function overlapsAny(candidate, allPlatforms) {
                for (const p of allPlatforms) {
                    const overlaps = !(candidate.x + candidate.width <= p.x ||
                        candidate.x >= p.x + p.width ||
                        candidate.y + candidate.height <= p.y ||
                        candidate.y >= p.y + p.height);
                    if (overlaps) return true;
                }
                return false;
            }

            function addHelperPlatformsIfNeeded(startPlatform, goalSupportPlatform, allPlatforms, limits) {
                if (isReachable(startPlatform, goalSupportPlatform, allPlatforms, limits)) {
                    return;
                }

                const helperWidth = Math.max(PLATFORM_MIN_WIDTH * 2, 80);
                const helperColor = 'rgba(80, 120, 255, 0.9)';

                let current = startPlatform;
                let added = 0;

                while (added < HELPERS_MAX_COUNT) {
                    if (isReachable(startPlatform, goalSupportPlatform, allPlatforms, limits)) return;

                    const currentCenter = current.x + current.width / 2;
                    const goalCenter = goalSupportPlatform.x + goalSupportPlatform.width / 2;

                    const toward = Math.sign(goalCenter - currentCenter) || 1;
                    const stepX = limits.maxJumpDx * 0.7;
                    const stepUp = limits.maxJumpUp * 0.7;

                    const targetY = Math.max(10, current.y - stepUp);
                    const idealX = currentCenter + toward * stepX - (helperWidth / 2);
                    let targetX = Math.max(0, Math.min(width - helperWidth, idealX));

                    // Avoid placing helpers inside the goal reserved area.
                    const wouldBeInGoalArea = (targetX > width - GOAL_AREA_WIDTH && targetY < GOAL_AREA_HEIGHT);
                    if (wouldBeInGoalArea) {
                        targetX = Math.max(0, width - GOAL_AREA_WIDTH - helperWidth - 10);
                    }

                    const candidate = new Platform(targetX, targetY, helperWidth, PLATFORM_THICKNESS, helperColor, 'helper');

                    // Deterministically search nearby x positions if we collide with existing geometry.
                    if (overlapsAny(candidate, allPlatforms)) {
                        let placed = false;
                        for (let offset = gridSize; offset <= gridSize * 8; offset += gridSize) {
                            const leftX = Math.max(0, targetX - offset);
                            const rightX = Math.min(width - helperWidth, targetX + offset);

                            const leftCandidate = new Platform(leftX, targetY, helperWidth, PLATFORM_THICKNESS, helperColor, 'helper');
                            if (!overlapsAny(leftCandidate, allPlatforms)) {
                                allPlatforms.push(leftCandidate);
                                debugHelperPlatforms.push(leftCandidate);
                                current = leftCandidate;
                                placed = true;
                                break;
                            }

                            const rightCandidate = new Platform(rightX, targetY, helperWidth, PLATFORM_THICKNESS, helperColor, 'helper');
                            if (!overlapsAny(rightCandidate, allPlatforms)) {
                                allPlatforms.push(rightCandidate);
                                debugHelperPlatforms.push(rightCandidate);
                                current = rightCandidate;
                                placed = true;
                                break;
                            }
                        }

                        if (!placed) {
                            // If we can't find a non-overlapping spot, stop adding helpers.
                            return;
                        }
                    } else {
                        allPlatforms.push(candidate);
                        debugHelperPlatforms.push(candidate);
                        current = candidate;
                    }

                    added++;
                }
            }

            const grid = buildSolidGrid();
            debugSolidGrid = grid.solid;
            platforms = extractTopSurfacesFromGrid(grid);

            // Add a ground platform at the bottom (darker and more opaque)
            platforms.push(new Platform(0, height - 20, width, 20, 'rgba(100, 60, 20, 0.8)', 'ground'));

            // Add starting platform (green to indicate start, larger and clearer)
            const startPlatformY = height - 60;
            const startPlatform = new Platform(10, startPlatformY, 100, 20, 'rgba(0, 180, 0, 0.9)', 'start');
            platforms.push(startPlatform);

            // Add goal at top-right corner of the level
            const goalX = width - 50;
            const goalY = 20;
            // Add a platform for the goal to sit on (golden and more visible)
            const goalSupportPlatform = new Platform(goalX - 10, goalY + 30, 50, 20, 'rgba(255, 200, 0, 0.9)', 'goal');
            platforms.push(goalSupportPlatform);
            goal = new Goal(goalX, goalY);

            // Initialize player ON the start platform (not above it)
            playerSpawnY = startPlatformY - 20; // Player height is 20, so spawn on top of platform
            player = new Player(PLAYER_SPAWN_X, playerSpawnY);
            
            // Remove any photo-generated platforms that overlap with player spawn area
            // to ensure player never spawns inside a block
            const spawnCheckX = PLAYER_SPAWN_X - 10;
            const spawnCheckY = playerSpawnY - 10;
            const spawnCheckWidth = 40;  // Player width + buffer
            const spawnCheckHeight = 40; // Player height + buffer
            
            platforms = platforms.filter(platform => {
                // Keep non-photo platforms (ground/start/goal/helper)
                if (platform.kind !== 'photo') return true;

                // Remove photo platforms that overlap with spawn area
                const overlaps = !(platform.x + platform.width < spawnCheckX ||
                    platform.x > spawnCheckX + spawnCheckWidth ||
                    platform.y + platform.height < spawnCheckY ||
                    platform.y > spawnCheckY + spawnCheckHeight);
                return !overlaps;
            });

            // Ensure the level is winnable: add helper platforms only when needed.
            const limits = getJumpLimits();
            addHelperPlatformsIfNeeded(startPlatform, goalSupportPlatform, platforms, limits);

            // Start game
            startGame();
        }

        // Start the game loop
        function startGame() {
            gameRunning = true;
            gameWon = false;  // Reset win state
            canvas.style.display = 'block';
            gameInfo.style.display = 'block';
            resetBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'none';
            cameraBtn.style.display = 'none';
            
            score = 0;
            startTime = Date.now();
            scoreElement.textContent = score;
            
            // Enter fullscreen when game starts
            enterFullscreen();
            
            gameLoop();
        }

        // Main game loop
        function gameLoop() {
            if (!gameRunning) return;

            // Draw the photo as background instead of solid color
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback to sky blue if no image
                ctx.fillStyle = '#87ceeb';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Update and draw goal
            if (goal) {
                goal.update();
                goal.draw();
            }

            // Update and draw platforms
            for (let platform of platforms) {
                platform.draw();
            }

            if (debugOverlayEnabled && debugSolidGrid) {
                drawDebugOverlay();
            }

            // Update and draw player
            if (player && !gameWon) {
                player.update();
                player.draw();
                
                // Check if player reached the goal
                if (goal && goal.checkCollision(player)) {
                    gameWon = true;
                }
            } else if (player && gameWon) {
                // Just draw the player when game is won, don't update
                player.draw();
            }

            // Draw win message if game is won
            if (gameWon) {
                drawWinMessage();
            }

            // Update time
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            timeElement.textContent = elapsedTime;

            requestAnimationFrame(gameLoop);
        }

        function drawDebugOverlay() {
            const gridSize = debugGridSize;
            if (!gridSize) return;

            // Solid grid hint
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = '#00bcd4';

            for (let cy = 0; cy < debugSolidGrid.length; cy++) {
                const row = debugSolidGrid[cy];
                for (let cx = 0; cx < row.length; cx++) {
                    if (!row[cx]) continue;
                    const x = cx * gridSize;
                    const y = cy * gridSize;
                    const w = Math.min(gridSize, canvas.width - x);
                    const h = Math.min(gridSize, canvas.height - y);
                    ctx.fillRect(x, y, w, h);
                }
            }

            // Helper platforms highlight
            ctx.globalAlpha = 1;
            ctx.strokeStyle = 'rgba(80, 120, 255, 1)';
            ctx.lineWidth = 2;
            for (const p of debugHelperPlatforms) {
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            }

            ctx.restore();
        }

        // Draw win message overlay
        function drawWinMessage() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üéâ YOU WIN! üéâ', canvas.width / 2, canvas.height / 2);
            ctx.font = '20px Arial';
            ctx.fillStyle = '#FFF';
            ctx.fillText(`Time: ${Math.floor((Date.now() - startTime) / 1000)}s`, canvas.width / 2, canvas.height / 2 + 30);
            ctx.fillText('Press ESC or click "Exit Game" to return to start', canvas.width / 2, canvas.height / 2 + 55);
        }

        // Show intro screen
        function showIntroScreen() {
            introScreen.classList.remove('hidden');
            gameScreen.classList.remove('active');
            exitFullscreen();
        }

        // Show game screen
        function showGameScreen() {
            introScreen.classList.add('hidden');
            gameScreen.classList.add('active');
        }

        // Enter fullscreen
        function enterFullscreen() {
            gameCanvasContainer.classList.add('fullscreen');
            exitFullscreenBtn.classList.add('visible');
            document.body.style.overflow = 'hidden';
        }

        // Exit fullscreen
        function exitFullscreen() {
            gameCanvasContainer.classList.remove('fullscreen');
            exitFullscreenBtn.classList.remove('visible');
            document.body.style.overflow = '';
        }

        // Return to intro and exit fullscreen
        function returnToIntro() {
            resetGame();
            showIntroScreen();
        }

        // Reset game
        function resetGame() {
            gameRunning = false;
            gameWon = false;
            platforms = [];
            player = null;
            goal = null;  // Clear goal
            score = 0;
            backgroundImage = null; // Clear background image
            canvas.style.display = 'none';
            gameInfo.style.display = 'none';
            resetBtn.style.display = 'none';
            uploadBtn.style.display = 'inline-block';
            cameraBtn.style.display = 'inline-block';
        }

        function guessDeviceType() {
            const ua = (navigator.userAgent || '').toLowerCase();
            if (ua.includes('ipad') || ua.includes('tablet')) return 'tablet';
            if (ua.includes('iphone') || ua.includes('android')) {
                return ua.includes('mobile') ? 'mobile' : 'tablet';
            }
            if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
                return window.innerWidth >= 768 ? 'tablet' : 'mobile';
            }
            return 'desktop';
        }

        function setFeedbackStatus(text, kind) {
            feedbackStatus.textContent = text || '';
            feedbackStatus.classList.remove('error', 'success');
            if (kind) feedbackStatus.classList.add(kind);
        }

        function openFeedbackModal() {
            feedbackDeviceType.value = guessDeviceType();
            setFeedbackStatus('', null);
            feedbackModal.classList.add('open');
            feedbackModal.setAttribute('aria-hidden', 'false');

            if (location.protocol === 'file:') {
                setFeedbackStatus('Feedback requires running the local server (not file://).', 'error');
            }

            setTimeout(() => {
                feedbackMessage.focus();
            }, 0);
        }

        function closeFeedbackModal() {
            feedbackModal.classList.remove('open');
            feedbackModal.setAttribute('aria-hidden', 'true');
        }

        async function postFeedback(message, deviceType, token) {
            const headers = {
                'Content-Type': 'application/json'
            };
            if (token) headers['X-Feedback-Token'] = token;

            return fetch('/api/feedback', {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    message,
                    deviceType
                })
            });
        }

        function shouldIgnoreGameKeyEvent(e) {
            if (feedbackModal.classList.contains('open')) return true;
            const target = e.target;
            if (!target) return false;
            if (target.isContentEditable) return true;
            const tag = (target.tagName || '').toUpperCase();
            return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        }

        function updateLanHint() {
            if (location.protocol === 'file:') {
                lanHint.classList.remove('open');
                return;
            }

            lanHint.classList.add('open');
            lanUrl.textContent = location.href;

            const host = (location.hostname || '').toLowerCase();
            if (host === 'localhost' || host === '127.0.0.1') {
                lanNote.innerHTML = 'If you\'re sharing to other devices, replace <strong>localhost</strong> with the host computer\'s LAN IP (e.g. <strong>192.168.x.x</strong>).';
            } else if (host === '0.0.0.0') {
                lanNote.innerHTML = 'Use the host computer\'s LAN IP instead of <strong>0.0.0.0</strong> when sharing (e.g. <strong>192.168.x.x</strong>).';
            } else {
                lanNote.textContent = 'Open this URL on devices connected to the same network.';
            }
        }

        if (debugOverlayToggle) {
            debugOverlayToggle.checked = DEBUG_DEFAULT_ENABLED;
            debugOverlayToggle.addEventListener('change', () => {
                debugOverlayEnabled = Boolean(debugOverlayToggle.checked);
            });
        }

        async function copyLanLink() {
            const text = location.href;
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const temp = document.createElement('textarea');
                    temp.value = text;
                    temp.style.position = 'fixed';
                    temp.style.left = '-9999px';
                    document.body.appendChild(temp);
                    temp.focus();
                    temp.select();
                    document.execCommand('copy');
                    document.body.removeChild(temp);
                }
                copyLinkBtn.textContent = 'Copied';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 900);
            } catch {
                copyLinkBtn.textContent = 'Copy failed';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 1200);
            }
        }

        // Event listeners
        startGameBtn.addEventListener('click', showGameScreen);
        exitFullscreenBtn.addEventListener('click', returnToIntro);
        
        uploadBtn.addEventListener('click', () => fileInput.click());
        cameraBtn.addEventListener('click', () => cameraInput.click());
        resetBtn.addEventListener('click', returnToIntro);

        copyLinkBtn.addEventListener('click', copyLanLink);

        feedbackBtn.addEventListener('click', openFeedbackModal);
        feedbackCancelBtn.addEventListener('click', closeFeedbackModal);
        feedbackModal.addEventListener('click', (e) => {
            if (e.target === feedbackModal) closeFeedbackModal();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please select a valid image file.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('File is too large. Please select an image under 10MB.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try a different file.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read file. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        cameraInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please capture a valid image.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('Image is too large. Please try again.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try again.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read image. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        feedbackForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const message = (feedbackMessage.value || '').trim();
            const deviceType = feedbackDeviceType.value || 'unknown';

            if (!message) {
                setFeedbackStatus('Please enter a message.', 'error');
                return;
            }

            feedbackSubmitBtn.disabled = true;
            setFeedbackStatus('Sending‚Ä¶', null);

            try {
                let token = localStorage.getItem(FEEDBACK_TOKEN_STORAGE_KEY) || '';
                let response = await postFeedback(message, deviceType, token);

                if (response.status === 401) {
                    const enteredToken = window.prompt('This server requires an access code. Enter it to send feedback:');
                    if (enteredToken) {
                        localStorage.setItem(FEEDBACK_TOKEN_STORAGE_KEY, enteredToken);
                        token = enteredToken;
                        response = await postFeedback(message, deviceType, token);
                    }
                }

                if (!response.ok) {
                    const text = await response.text();
                    setFeedbackStatus(`Failed to send feedback (${response.status}). ${text ? 'Details: ' + text : ''}`.trim(), 'error');
                    return;
                }

                feedbackMessage.value = '';
                setFeedbackStatus('Sent. Thank you!', 'success');

                setTimeout(() => {
                    closeFeedbackModal();
                }, 700);
            } catch (err) {
                setFeedbackStatus('Failed to send feedback. Is the local server running?', 'error');
            } finally {
                feedbackSubmitBtn.disabled = false;
            }
        });

        updateLanHint();

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // ESC key returns to intro screen
            if (e.key === 'Escape') {
                if (gameScreen.classList.contains('active')) {
                    returnToIntro();
                    e.preventDefault();
                }
                return;
            }
            
            if (shouldIgnoreGameKeyEvent(e)) return;
            
            // Manual respawn with 'R' key
            if ((e.key === 'r' || e.key === 'R') && player && gameRunning) {
                player.respawn();
                e.preventDefault();
                return;
            }
            
            keys[e.key] = true;
            // Prevent default for arrow keys and space
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (shouldIgnoreGameKeyEvent(e)) return;
            keys[e.key] = false;
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
            
            // Jump on tap
            touchJumping = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // Horizontal movement based on touch position
            const deltaX = touchX - touchStartX;
            
            if (deltaX < -20) {
                keys['ArrowLeft'] = true;
                keys['ArrowRight'] = false;
            } else if (deltaX > 20) {
                keys['ArrowRight'] = true;
                keys['ArrowLeft'] = false;
            } else {
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });

        // Mobile control button handlers
        // Detect if device supports touch and show controls
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            mobileControls.classList.add('visible');
        }

        // Left button
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        leftBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });

        // Right button
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        rightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        rightBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });

        // Jump button
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchJumping = true;
        });
        jumpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
        });
        jumpBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchJumping = false;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && feedbackModal.classList.contains('open')) {
                closeFeedbackModal();
            }
        });
    </script>
</body>
</html>
