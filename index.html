<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#764ba2">
    <meta name="description" content="Turn your photos into playable platformer levels! Upload a photo and jump through your own pictures.">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Photo Jumper">
    <title>Photo Jumper - Platform Game</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .lan-hint {
            margin-top: -6px;
            margin-bottom: 18px;
            background: #f7f7ff;
            border: 1px solid #e3e3ff;
            border-radius: 12px;
            padding: 12px;
            display: none;
        }

        .lan-hint.open {
            display: block;
        }

        .lan-hint .row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .lan-hint .label {
            font-weight: bold;
            color: #333;
        }

        .lan-hint code {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px 10px;
            display: inline-block;
            max-width: 100%;
            overflow-wrap: anywhere;
        }

        .lan-hint .note {
            margin-top: 8px;
            color: #666;
            font-size: 13px;
        }

        .lan-hint .note strong {
            color: #333;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #fileInput, #cameraInput {
            display: none;
        }

        .game-canvas-container {
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 3px solid #333;
            border-radius: 10px;
            max-width: 100%;
            background: #87ceeb;
            display: none;
        }

        .instructions {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .instructions p {
            margin-bottom: 8px;
            color: #666;
        }

        .game-info {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: none;
        }

        .preview-canvas {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 1000;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 520px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        }

        .modal-content h3 {
            margin-bottom: 8px;
            color: #333;
        }

        .modal-content .hint {
            margin-bottom: 14px;
            color: #666;
            font-size: 14px;
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            text-align: left;
        }

        .form-row label {
            font-weight: bold;
            color: #333;
        }

        .form-row select,
        .form-row textarea {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 10px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-row textarea {
            resize: vertical;
            min-height: 110px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .status {
            margin-top: 10px;
            min-height: 18px;
            color: #333;
            font-size: 14px;
        }

        .status.error {
            color: #b00020;
        }

        .status.success {
            color: #0b6b0b;
        }

        /* Mobile control buttons */
        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            user-select: none;
        }

        .mobile-controls.visible {
            display: flex;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 15px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            touch-action: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .control-btn.jump-btn {
            width: 90px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        /* Intro screen styles */
        .intro-screen {
            text-align: center;
            padding: 40px 20px;
        }

        .intro-screen.hidden {
            display: none;
        }

        .intro-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .intro-screen .tagline {
            font-size: 1.3em;
            color: #555;
            margin-bottom: 30px;
        }

        .intro-screen .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
            text-align: left;
        }

        .intro-screen .feature {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .intro-screen .feature h3 {
            margin-bottom: 8px;
            color: #667eea;
        }

        .intro-screen .feature p {
            color: #666;
            margin: 0;
        }

        .intro-screen .cta-button {
            font-size: 1.2em;
            padding: 16px 32px;
            margin-top: 20px;
        }

        /* Game screen styles */
        .game-screen {
            display: none;
        }

        .game-screen.active {
            display: block;
        }

        /* Fullscreen styles */
        .game-canvas-container.fullscreen {
            position: fixed;
            inset: 0;
            z-index: 100;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .game-canvas-container.fullscreen #gameCanvas {
            max-width: 95vw;
            max-height: 95vh;
            border-radius: 10px;
        }

        /* Hide non-essential elements when canvas is fullscreen */
        .game-canvas-container.fullscreen ~ .instructions {
            display: none;
        }

        .game-screen:has(.game-canvas-container.fullscreen) .upload-section {
            display: none;
        }

        .game-screen:has(.game-canvas-container.fullscreen) h1 {
            display: none;
        }

        /* Position game info overlay when fullscreen */
        .game-canvas-container.fullscreen ~ .game-info,
        .game-screen:has(.game-canvas-container.fullscreen) .game-info {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Position mobile controls when fullscreen */
        .game-canvas-container.fullscreen ~ .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
        }

        /* Exit fullscreen button */
        .exit-fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 101;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            display: none;
        }

        .exit-fullscreen-btn.visible {
            display: block;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
            }

            button {
                padding: 10px 20px;
                font-size: 14px;
            }

            .container {
                padding: 20px;
            }

            .intro-screen h1 {
                font-size: 2em;
            }

            .intro-screen .tagline {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <button class="exit-fullscreen-btn" id="exitFullscreenBtn">‚úï Exit Game</button>
    
    <div class="container">
        <!-- Intro Screen -->
        <div class="intro-screen" id="introScreen">
            <h1>üéÆ Photo Jumper</h1>
            <p class="tagline">Turn your photos into playable platformer levels!</p>
            
            <div class="features">
                <div class="feature">
                    <h3>üì∏ Upload or Capture</h3>
                    <p>Use any photo - the game detects edges and brightness to create platforms</p>
                </div>
                <div class="feature">
                    <h3>üéØ Reach the Goal</h3>
                    <p>Jump from platform to platform to reach the golden star at the top</p>
                </div>
                <div class="feature">
                    <h3>‚ö° Fast & Fun</h3>
                    <p>Quick platformer action with responsive controls</p>
                </div>
            </div>

            <button class="cta-button" id="startGameBtn">Get Started</button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <h1>üéÆ Photo Jumper</h1>
            
            <div class="upload-section">
            <div class="button-group">
                <button id="uploadBtn">üìÅ Upload Photo</button>
                <button id="cameraBtn">üì∑ Take Photo</button>
                <button id="resetBtn" style="display: none;">üîÑ New Photo</button>
                <button id="feedbackBtn" type="button">üìù Feedback</button>
            </div>

            <div id="lanHint" class="lan-hint" aria-live="polite">
                <div class="row">
                    <div>
                        <div class="label">Share link</div>
                        <code id="lanUrl"></code>
                    </div>
                    <button id="copyLinkBtn" type="button">Copy</button>
                </div>
                <div id="lanNote" class="note"></div>
            </div>

            <input type="file" id="fileInput" accept="image/*">
            <input type="file" id="cameraInput" accept="image/*" capture="environment">
        </div>

        <div class="game-info" id="gameInfo">
            Score: <span id="score">0</span> | Time: <span id="time">0</span>s
        </div>

        <div class="game-canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <canvas id="previewCanvas" class="preview-canvas"></canvas>
        </div>

        <!-- Mobile control buttons -->
        <div class="mobile-controls" id="mobileControls">
            <button class="control-btn" id="leftBtn" aria-label="Move left">‚óÄ</button>
            <button class="control-btn jump-btn" id="jumpBtn" aria-label="Jump">‚ñ≤</button>
            <button class="control-btn" id="rightBtn" aria-label="Move right">‚ñ∂</button>
        </div>

        <div class="instructions">
            <h3>How to Play:</h3>
            <p>1. Upload a photo or take one with your camera</p>
            <p>2. The photo will be converted into platforms based on brightness</p>
            <p>3. Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move (or touch controls on mobile)</p>
            <p>4. Press <strong>Space</strong> or <strong>Up Arrow</strong> to jump</p>
            <p>5. Navigate from the green start platform to the golden goal star!</p>
            <p>6. Press <strong>R</strong> to respawn if you get stuck</p>
            <p><label><input type="checkbox" id="debugOverlayToggle"> Debug overlay</label></p>
            <p><label><input type="checkbox" id="mlDetectionToggle" aria-describedby="mlStatusDesc"> ML object detection (experimental)</label>
                <span id="mlStatus" style="font-size: 12px; color: #666;"></span>
                <span id="mlStatusDesc" class="visually-hidden" style="position: absolute; left: -10000px;">When enabled, uses machine learning to detect objects in your photo and create platforms from them. May increase loading time.</span>
            </p>
        </div>
        </div>
        <!-- End Game Screen -->

        <div id="feedbackModal" class="modal" aria-hidden="true">
            <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="feedbackTitle">
                <h3 id="feedbackTitle">Send Feedback</h3>
                <p class="hint">Text-only feedback is saved locally on the host machine.</p>

                <form id="feedbackForm">
                    <div class="form-row">
                        <label for="feedbackDeviceType">Device type</label>
                        <select id="feedbackDeviceType" required>
                            <option value="unknown">Unknown</option>
                            <option value="desktop">Desktop / Laptop</option>
                            <option value="tablet">Tablet</option>
                            <option value="mobile">Mobile</option>
                        </select>
                    </div>

                    <div class="form-row">
                        <label for="feedbackMessage">Message</label>
                        <textarea id="feedbackMessage" maxlength="2000" placeholder="What worked well? What was confusing or buggy?" required></textarea>
                    </div>

                    <div class="modal-actions">
                        <button type="button" id="feedbackCancelBtn">Cancel</button>
                        <button type="submit" id="feedbackSubmitBtn">Send</button>
                    </div>
                    <div id="feedbackStatus" class="status" aria-live="polite"></div>
                </form>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        
        const introScreen = document.getElementById('introScreen');
        const gameScreen = document.getElementById('gameScreen');
        const startGameBtn = document.getElementById('startGameBtn');
        const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
        const container = document.querySelector('.container');
        const gameCanvasContainer = document.querySelector('.game-canvas-container');
        
        const uploadBtn = document.getElementById('uploadBtn');
        const cameraBtn = document.getElementById('cameraBtn');
        const resetBtn = document.getElementById('resetBtn');
        const feedbackBtn = document.getElementById('feedbackBtn');
        const fileInput = document.getElementById('fileInput');
        const cameraInput = document.getElementById('cameraInput');
        const gameInfo = document.getElementById('gameInfo');
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');

        const feedbackModal = document.getElementById('feedbackModal');
        const feedbackForm = document.getElementById('feedbackForm');
        const feedbackDeviceType = document.getElementById('feedbackDeviceType');
        const feedbackMessage = document.getElementById('feedbackMessage');
        const feedbackCancelBtn = document.getElementById('feedbackCancelBtn');
        const feedbackSubmitBtn = document.getElementById('feedbackSubmitBtn');
        const feedbackStatus = document.getElementById('feedbackStatus');

        const lanHint = document.getElementById('lanHint');
        const lanUrl = document.getElementById('lanUrl');
        const lanNote = document.getElementById('lanNote');
        const copyLinkBtn = document.getElementById('copyLinkBtn');

        const debugOverlayToggle = document.getElementById('debugOverlayToggle');

        // Mobile control buttons
        const mobileControls = document.getElementById('mobileControls');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');

        const FEEDBACK_TOKEN_STORAGE_KEY = 'photoJumperFeedbackToken';

        // Game configuration constants
        const PLAYER_SIZE = 20;
        const PLAYER_SPEED = 5;
        const PLAYER_JUMP_POWER = 12;
        const PLAYER_GRAVITY = 0.5;

        const GRID_SIZE = 20;  // Reduced from 30 to detect more platforms (1x player size)
        const BRIGHTNESS_THRESHOLD = 140;  // Increased from 128 to require brighter areas for platforms
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
        const EDGE_DETECTION_THRESHOLD = 30;  // Reduced from 40 for better edge detection
        const EDGE_BRIGHTNESS_THRESHOLD = 200;  // Increased from 180 to accept more edge-detected platforms

        // Gameplay-first platform constraints
        const PLATFORM_MIN_WIDTH = 40;
        const PLATFORM_THICKNESS = 14;
        const PLATFORM_MERGE_GAP_PX = 0;
        const HELPERS_MAX_COUNT = 14;

        const DEBUG_DEFAULT_ENABLED = false;
        
        // Player spawn and reserved area constants
        const PLAYER_SPAWN_X = 40;
        const PLAYER_SPAWN_Y_OFFSET = 100; // Pixels above canvas bottom
        const START_AREA_WIDTH = 140;  // Wider to ensure clear start area
        const START_AREA_HEIGHT = 100;  // Taller to ensure clear start area
        const GOAL_AREA_WIDTH = 100;
        const GOAL_AREA_HEIGHT = 80;
        
        // Stuck detection constants
        const STUCK_CHECK_INTERVAL = 3000;  // 3 seconds
        const STUCK_MOVEMENT_THRESHOLD = 5;  // pixels

        // Letter collection constants
        const LETTER_SIZE = 20;
        const LETTER_POINTS = 10;  // Points per letter
        const WORD_COMPLETE_BONUS = 50;  // Bonus for collecting all letters
        const CORRECT_ORDER_BONUS = 100;  // Extra bonus for correct order
        const WORD_DICTIONARY = ['JUMP', 'PLAY', 'GAME', 'PHOTO', 'STAR', 'GOAL', 'WIN', 'FUN'];

        let gameRunning = false;
        let platforms = [];
        let player = null;
        let goal = null;  // Goal/end point for the level
        let playerSpawnY = 0;  // Calculated spawn Y position
        let keys = {};
        let score = 0;
        let startTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchJumping = false;
        let backgroundImage = null; // Store the uploaded photo for background
        let gameWon = false;  // Track if player reached the goal

        // Letter collection game state
        let letters = [];  // Array of Letter objects
        let collectedLetters = [];  // Array of collected letters in order
        let targetWord = '';  // The word to spell
        let wordCompleteBonus = 0;  // Bonus earned for completing word
        let correctOrderBonus = 0;  // Bonus earned for correct order

        let debugOverlayEnabled = DEBUG_DEFAULT_ENABLED;
        let debugSolidGrid = null;
        let debugGridSize = GRID_SIZE;
        let debugHelperPlatforms = [];

        // ONNX ML detection configuration
        const ML_DETECTION_ENABLED_DEFAULT = false;
        // Model URLs: Try CDN first for deployments, local as fallback
        // For local development: place yolov8n.onnx in 'models/' folder
        // For production: CDN is preferred (smaller deployment, no large files in repo)
        const ML_MODEL_URLS = [
            'https://cdn.jsdelivr.net/gh/aspect-technology/yolov8-onnx@main/models/yolov8n.onnx',  // CDN (preferred for production)
            'models/yolov8n.onnx',  // Local fallback (for development/offline)
        ];
        // ONNX Runtime URLs: CDN first for deployments, local fallback
        // For local development: download ort.min.js and ort-wasm*.wasm files to 'lib/' folder
        // From: https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/
        const ONNX_RUNTIME_URLS = [
            'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js',  // CDN (preferred for production)
            'lib/ort.min.js',  // Local fallback (for development/offline)
        ];
        const ML_CONFIDENCE_THRESHOLD = 0.5;
        const ML_INPUT_SIZE = 640;  // YOLOv8n expects 640x640 input images
        const ML_INFERENCE_TIMEOUT_MS = 5000;
        const ML_MIN_DETECTION_SIZE = 10;  // Minimum bounding box size in pixels to consider
        const ML_PLATFORM_MERGE_TOLERANCE = 20;  // Extra horizontal gap tolerance when merging ML platforms
        const ML_PLATFORM_OVERLAP_TOLERANCE_Y = 10;  // Vertical overlap tolerance when combining ML and grid platforms
        
        // COCO classes that are suitable for platforms (horizontal surfaces)
        const PLATFORMABLE_CLASSES = [
            // Furniture - obvious platforms
            'bench', 'chair', 'couch', 'bed', 'dining table', 'desk', 'toilet',
            
            // Electronics - flat top surfaces
            'tv', 'laptop', 'keyboard', 'book', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator',
            
            // Vehicles - can stand on top
            'car', 'bus', 'truck', 'boat', 'train', 'airplane', 'bicycle', 'motorcycle',
            
            // Large objects - stable platforms
            'suitcase', 'backpack', 'skateboard', 'surfboard', 
            
            // Sports equipment - flat surfaces
            'snowboard', 'skis',
            
            // Containers - can stand on
            'vase', 'potted plant', 'bowl',
            
            // Animals - because why not! ü¶íüêòüê¥
            'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe',
            
            // People - jump on heads!
            'person',
            
            // Other - potential platforms
            'clock', 'teddy bear', 'remote', 'mouse', 'cell phone'
        ];
        
        // COCO class names (80 classes)
        const COCO_CLASSES = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
            'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
            'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
            'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
            'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
            'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
            'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
            'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];

        // ONNX state
        let mlDetectionEnabled = ML_DETECTION_ENABLED_DEFAULT;
        let onnxSession = null;
        let onnxModelLoading = false;
        let onnxModelLoaded = false;
        let onnxLoadError = null;
        let debugDetectedObjects = [];

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = PLAYER_SIZE;
                this.height = PLAYER_SIZE;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = PLAYER_SPEED;
                this.jumpPower = PLAYER_JUMP_POWER;
                this.gravity = PLAYER_GRAVITY;
                this.onGround = false;
                this.lastPositionTime = Date.now();
                this.lastX = x;
                this.lastY = y;
                this.stuckCheckInterval = STUCK_CHECK_INTERVAL;
            }

            update() {
                // Horizontal movement
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    this.velocityX = -this.speed;
                } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    this.velocityX = this.speed;
                } else {
                    this.velocityX *= 0.7; // Reduced friction for more responsive feel
                }

                // Jumping
                if ((keys['ArrowUp'] || keys['w'] || keys['W'] || keys[' '] || touchJumping) && this.onGround) {
                    this.velocityY = -this.jumpPower;
                    this.onGround = false;
                    touchJumping = false; // Reset touch jump
                }

                // Apply gravity
                this.velocityY += this.gravity;

                // Update horizontal position
                this.x += this.velocityX;

                // Check horizontal platform collisions
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Push out from sides
                        if (this.x + this.width / 2 < platform.x + platform.width / 2) {
                            this.x = platform.x - this.width;
                        } else {
                            this.x = platform.x + platform.width;
                        }
                        this.velocityX = 0;
                    }
                }

                // Update vertical position
                this.y += this.velocityY;

                // Check vertical platform collisions
                this.onGround = false;
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Landing on top of platform
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                        // Hitting platform from below
                        else if (this.velocityY < 0 && this.y - this.velocityY >= platform.y + platform.height) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                    }
                }

                // Boundary checks
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

                // Check if player fell off
                if (this.y > canvas.height) {
                    this.respawn();
                }

                // Stuck detection: if player hasn't moved significantly in a while
                const now = Date.now();
                const distMoved = Math.sqrt((this.x - this.lastX) ** 2 + (this.y - this.lastY) ** 2);
                
                if (now - this.lastPositionTime > this.stuckCheckInterval) {
                    if (distMoved < STUCK_MOVEMENT_THRESHOLD && this.onGround) {
                        // Player appears stuck, auto-respawn
                        this.respawn();
                        // Reset tracking variables after respawn to prevent immediate re-triggering
                        this.lastX = this.x;
                        this.lastY = this.y;
                        this.lastPositionTime = Date.now();
                    } else {
                        // Update last known position when not stuck
                        this.lastX = this.x;
                        this.lastY = this.y;
                        this.lastPositionTime = now;
                    }
                }

                // Update score based on progress and time efficiency
                // Score = platforms reached * 100 - time penalty
                const heightProgress = Math.max(0, Math.floor((canvas.height - this.y) / 10));
                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                const timePenalty = Math.floor(elapsedSeconds / 2); // -1 point every 2 seconds
                const currentScore = Math.max(0, heightProgress * 2 - timePenalty);
                
                if (currentScore > score) {
                    score = currentScore;
                    scoreElement.textContent = score;
                }
            }

            checkCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            respawn() {
                this.x = PLAYER_SPAWN_X;
                this.y = playerSpawnY;  // Use the calculated spawn Y position
                this.velocityX = 0;
                this.velocityY = 0;
                score = Math.max(0, score - 10);
                scoreElement.textContent = score;
            }

            draw() {
                // Draw shadow/outline for better visibility on photo
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x + 2, this.y + 2, this.width, this.height);
                
                // Draw main body
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw border for visibility
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Draw eyes (adjusted for smaller size)
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x + 4, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 12, this.y + 5, 4, 4);
                
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x + 5, this.y + 6, 2, 2);
                ctx.fillRect(this.x + 13, this.y + 6, 2, 2);
            }
        }

        // Goal class - represents the end goal for the level
        class Goal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.animation = 0;
            }

            update() {
                this.animation += 0.1;
            }

            checkCollision(player) {
                return player.x < this.x + this.width &&
                       player.x + player.width > this.x &&
                       player.y < this.y + this.height &&
                       player.y + player.height > this.y;
            }

            draw() {
                // Draw animated star/goal
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                const outerRadius = 15 + Math.sin(this.animation) * 2;
                const innerRadius = 7;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.animation * 0.5);
                
                // Draw star
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                
                // Gradient fill
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, outerRadius);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(1, '#FFA500');
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.strokeStyle = '#FF8C00';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        // Platform class
        class Platform {
            constructor(x, y, width, height, color, kind = 'photo') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.kind = kind;
            }

            draw() {
                // Add shadow for depth
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Draw platform fill
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Reset shadow for outline
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw thick black outline for visibility
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Add highlight on top edge for 3D effect
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 1);
                ctx.lineTo(this.x + this.width, this.y + 1);
                ctx.stroke();
            }
        }

        // Letter class for collectible letters
        class Letter {
            constructor(char, x, y, index) {
                this.char = char;
                this.x = x;
                this.y = y;
                this.width = LETTER_SIZE;
                this.height = LETTER_SIZE;
                this.collected = false;
                this.index = index;  // Position in the target word
                this.animation = 0;
            }

            update() {
                this.animation += 0.1;
            }

            checkCollision(player) {
                return !this.collected &&
                       player.x < this.x + this.width &&
                       player.x + player.width > this.x &&
                       player.y < this.y + this.height &&
                       player.y + player.height > this.y;
            }

            draw() {
                if (this.collected) return;

                // Floating animation
                const floatOffset = Math.sin(this.animation) * 3;
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2 + floatOffset;

                // Draw circular background with glow
                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, LETTER_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();

                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Draw black outline
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, LETTER_SIZE / 2, 0, Math.PI * 2);
                ctx.stroke();

                // Draw the letter
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.char, centerX, centerY);
            }
        }

        // ==========================================
        // ONNX ML Detection Functions
        // ==========================================

        // Lazy-load ONNX Runtime with fallback URLs
        async function loadONNXRuntime() {
            if (typeof ort !== 'undefined') {
                // Already loaded, just ensure WASM path is set
                if (!ort.env.wasm.wasmPaths) {
                    ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/';
                }
                return true;
            }
            
            for (const runtimeUrl of ONNX_RUNTIME_URLS) {
                try {
                    console.log('Attempting to load ONNX Runtime from:', runtimeUrl);
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = runtimeUrl;
                        script.onload = () => resolve(true);
                        script.onerror = () => reject(new Error(`Failed to load from ${runtimeUrl}`));
                        document.head.appendChild(script);
                    });
                    
                    // Wait a bit for ort to become available (async initialization)
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Verify ort is available after script loads
                    if (typeof ort !== 'undefined') {
                        console.log('ONNX Runtime loaded successfully from:', runtimeUrl);
                        
                        // Configure WASM paths - point to the same location as the runtime
                        if (runtimeUrl.includes('://')) {
                            // CDN - point to CDN for WASM files
                            const cdnBase = runtimeUrl.substring(0, runtimeUrl.lastIndexOf('/') + 1);
                            ort.env.wasm.wasmPaths = cdnBase;
                            console.log('ONNX WASM path set to CDN:', ort.env.wasm.wasmPaths);
                        } else {
                            // Local - point to local lib folder
                            ort.env.wasm.wasmPaths = 'lib/';
                            console.log('ONNX WASM path set to local:', ort.env.wasm.wasmPaths);
                        }
                        
                        // Set number of threads for better performance
                        ort.env.wasm.numThreads = 1;
                        
                        return true;
                    }
                } catch (err) {
                    console.error('Failed to load ONNX Runtime from:', runtimeUrl);
                    console.error('Error details:', err);
                    // Continue to next URL
                }
            }
            
            throw new Error('Failed to load ONNX Runtime from all sources');
        }

        // Initialize ONNX model (lazy load with fallback URLs)
        async function initONNXModel() {
            if (onnxSession) return true;
            if (onnxModelLoading) return false;
            if (onnxLoadError) return false;
            
            onnxModelLoading = true;
            updateMLStatus('Loading runtime...');
            
            try {
                // Load ONNX runtime first
                await loadONNXRuntime();
                updateMLStatus('Loading model...');
                
                // Try each model URL until one works
                let lastError = null;
                for (const modelUrl of ML_MODEL_URLS) {
                    try {
                        updateMLStatus(`Trying ${modelUrl.includes('://') ? 'CDN' : 'local'} model...`);
                        console.log('Attempting to load model from:', modelUrl);
                        
                        onnxSession = await ort.InferenceSession.create(modelUrl, {
                            executionProviders: ['wasm'],
                            graphOptimizationLevel: 'all'
                        });
                        
                        onnxModelLoaded = true;
                        onnxModelLoading = false;
                        updateMLStatus('ML ready');
                        console.log('ONNX model loaded successfully from:', modelUrl);
                        return true;
                    } catch (urlError) {
                        console.error(`Failed to load model from ${modelUrl}:`, urlError);
                        console.error('Error stack:', urlError.stack);
                        lastError = urlError;
                        // Continue to try next URL
                    }
                }
                
                // All URLs failed
                throw lastError || new Error('All model URLs failed');
            } catch (err) {
                onnxLoadError = err;
                onnxModelLoading = false;
                onnxModelLoaded = false;
                updateMLStatus('ML failed - see console');
                console.error('Failed to load ML detection:', err);
                console.info('=== ML Detection Troubleshooting ===');
                console.info('The app is running via HTTPS/web server (good!)');
                console.info('ML assets are loading from CDN (no downloads needed).');
                console.info('');
                console.info('Possible issues:');
                console.info('1. CDN temporarily unavailable - try refreshing');
                console.info('2. Network/firewall blocking CDN - check connection');
                console.info('3. Browser compatibility - try Chrome/Edge');
                console.info('');
                console.info('CDN URLs tried:');
                console.info('- Runtime: https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/');
                console.info('- Model: https://cdn.jsdelivr.net/gh/aspect-technology/yolov8-onnx@main/');
                console.info('');
                console.info('See docs/ONNX_SETUP.md for full troubleshooting guide.');
                return false;
            }
        }

        // Update ML status indicator
        function updateMLStatus(text) {
            const mlStatusEl = document.getElementById('mlStatus');
            if (mlStatusEl) {
                mlStatusEl.textContent = text ? ` (${text})` : '';
            }
        }

        // Preprocess image for YOLO model input
        function preprocessImageForYOLO(imageData, width, height) {
            // Create a temporary canvas to resize image to ML_INPUT_SIZE x ML_INPUT_SIZE
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = ML_INPUT_SIZE;
            tempCanvas.height = ML_INPUT_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw with letterboxing to maintain aspect ratio
            const scale = Math.min(ML_INPUT_SIZE / width, ML_INPUT_SIZE / height);
            const scaledWidth = Math.floor(width * scale);
            const scaledHeight = Math.floor(height * scale);
            const offsetX = Math.floor((ML_INPUT_SIZE - scaledWidth) / 2);
            const offsetY = Math.floor((ML_INPUT_SIZE - scaledHeight) / 2);
            
            // Fill with gray (letterbox padding)
            tempCtx.fillStyle = '#808080';
            tempCtx.fillRect(0, 0, ML_INPUT_SIZE, ML_INPUT_SIZE);
            
            // Draw the resized image centered
            tempCtx.drawImage(previewCanvas, 0, 0, width, height, offsetX, offsetY, scaledWidth, scaledHeight);
            
            // Get pixel data
            const resizedData = tempCtx.getImageData(0, 0, ML_INPUT_SIZE, ML_INPUT_SIZE).data;
            
            // Convert to normalized float32 tensor [1, 3, 640, 640] (NCHW format)
            const inputSize = ML_INPUT_SIZE * ML_INPUT_SIZE;
            const float32Data = new Float32Array(3 * inputSize);
            
            for (let i = 0; i < inputSize; i++) {
                const pixelIndex = i * 4;
                // Normalize to [0, 1]
                float32Data[i] = resizedData[pixelIndex] / 255.0;                    // R channel
                float32Data[i + inputSize] = resizedData[pixelIndex + 1] / 255.0;   // G channel
                float32Data[i + 2 * inputSize] = resizedData[pixelIndex + 2] / 255.0; // B channel
            }
            
            return {
                tensor: new ort.Tensor('float32', float32Data, [1, 3, ML_INPUT_SIZE, ML_INPUT_SIZE]),
                scale,
                offsetX,
                offsetY
            };
        }

        // Run YOLO inference and extract bounding boxes
        async function detectObjectsWithONNX(width, height) {
            if (!onnxSession) return [];
            
            try {
                const startTime = performance.now();
                
                // Preprocess image
                const { tensor, scale, offsetX, offsetY } = preprocessImageForYOLO(null, width, height);
                
                // Run inference with timeout (clean up timeout when inference completes)
                let timeoutId;
                const timeoutPromise = new Promise((_, reject) => {
                    timeoutId = setTimeout(() => reject(new Error('Inference timeout')), ML_INFERENCE_TIMEOUT_MS);
                });
                
                try {
                    const results = await Promise.race([
                        onnxSession.run({ images: tensor }),
                        timeoutPromise
                    ]);
                    clearTimeout(timeoutId);
                    
                    const inferenceTime = performance.now() - startTime;
                    console.log(`ONNX inference completed in ${inferenceTime.toFixed(0)}ms`);
                    
                    // Process YOLO output - different models use different output names
                    const output = results.predictions || results.output0 || results[Object.keys(results)[0]];
                    
                    if (!output) {
                        console.error('No valid output found. Available keys:', Object.keys(results));
                        return [];
                    }
                    
                    console.log('Using output tensor with dims:', output.dims);
                    
                    const detections = processYOLOOutput(output, width, height, scale, offsetX, offsetY);
                    
                    return detections;
                } catch (inferErr) {
                    clearTimeout(timeoutId);
                    throw inferErr;
                }
            } catch (err) {
                console.warn('ONNX inference failed:', err);
                return [];
            }
        }

        // Process YOLO v8 output format [1, 84, 8400] -> bounding boxes
        function processYOLOOutput(output, originalWidth, originalHeight, scale, offsetX, offsetY) {
            if (!output) {
                console.error('Output is undefined');
                return [];
            }
            
            // ONNX Runtime Web returns tensors, need to get data from cpuData or data
            const data = output.cpuData || output.data;
            
            if (!data) {
                console.error('Output data is undefined. Output:', output);
                console.error('Available properties:', Object.keys(output));
                return [];
            }
            
            const dims = output.dims;
            if (!dims || dims.length !== 3) {
                console.error('Invalid output dimensions:', dims);
                return [];
            }
            
            const [batch, features, numBoxes] = dims; // Expected: [1, 84, 8400]
            console.log(`Processing YOLO output: ${batch}x${features}x${numBoxes}`);
            
            const detections = [];
            
            // YOLOv8 output format: first 4 values are [cx, cy, w, h], remaining 80 are class probabilities
            for (let i = 0; i < numBoxes; i++) {
                // Extract box coordinates (cx, cy, w, h)
                const cx = data[i];
                const cy = data[numBoxes + i];
                const w = data[2 * numBoxes + i];
                const h = data[3 * numBoxes + i];
                
                // Find the class with highest probability
                let maxProb = 0;
                let maxClass = 0;
                for (let c = 0; c < 80; c++) {
                    const prob = data[(4 + c) * numBoxes + i];
                    if (prob > maxProb) {
                        maxProb = prob;
                        maxClass = c;
                    }
                }
                
                // Filter by confidence threshold
                if (maxProb < ML_CONFIDENCE_THRESHOLD) continue;
                
                // Convert from letterboxed coordinates to original image coordinates
                const x1 = (cx - w / 2 - offsetX) / scale;
                const y1 = (cy - h / 2 - offsetY) / scale;
                const boxW = w / scale;
                const boxH = h / scale;
                
                // Clamp to image bounds
                const clampedX = Math.max(0, Math.min(x1, originalWidth - 1));
                const clampedY = Math.max(0, Math.min(y1, originalHeight - 1));
                const clampedW = Math.min(boxW, originalWidth - clampedX);
                const clampedH = Math.min(boxH, originalHeight - clampedY);
                
                if (clampedW < ML_MIN_DETECTION_SIZE || clampedH < ML_MIN_DETECTION_SIZE) continue;
                
                const className = COCO_CLASSES[maxClass] || 'unknown';
                
                detections.push({
                    class: className,
                    classId: maxClass,
                    confidence: maxProb,
                    bbox: [clampedX, clampedY, clampedW, clampedH],
                    isPlatformable: PLATFORMABLE_CLASSES.includes(className)
                });
            }
            
            // Apply Non-Maximum Suppression (NMS)
            return applyNMS(detections, 0.45);
        }

        // Non-Maximum Suppression to remove overlapping detections
        function applyNMS(detections, iouThreshold) {
            // Sort by confidence (descending)
            detections.sort((a, b) => b.confidence - a.confidence);
            
            const kept = [];
            const suppressed = new Set();
            
            for (let i = 0; i < detections.length; i++) {
                if (suppressed.has(i)) continue;
                
                kept.push(detections[i]);
                
                for (let j = i + 1; j < detections.length; j++) {
                    if (suppressed.has(j)) continue;
                    
                    const iou = calculateIoU(detections[i].bbox, detections[j].bbox);
                    if (iou > iouThreshold) {
                        suppressed.add(j);
                    }
                }
            }
            
            return kept;
        }

        // Calculate Intersection over Union (IoU) between two bounding boxes
        function calculateIoU(box1, box2) {
            const [x1, y1, w1, h1] = box1;
            const [x2, y2, w2, h2] = box2;
            
            const interX1 = Math.max(x1, x2);
            const interY1 = Math.max(y1, y2);
            const interX2 = Math.min(x1 + w1, x2 + w2);
            const interY2 = Math.min(y1 + h1, y2 + h2);
            
            const interW = Math.max(0, interX2 - interX1);
            const interH = Math.max(0, interY2 - interY1);
            const interArea = interW * interH;
            
            const area1 = w1 * h1;
            const area2 = w2 * h2;
            const unionArea = area1 + area2 - interArea;
            
            return unionArea > 0 ? interArea / unionArea : 0;
        }

        // Map detected objects to platform candidates using top-edge heuristic
        function mapObjectsToPlatforms(detections, canvasWidth, canvasHeight) {
            const platformCandidates = [];
            
            for (const detection of detections) {
                const [x, y, w, h] = detection.bbox;
                
                // Use TOP edge of detected object as platform surface
                // This is where you would realistically stand on the object (top of chair, car, etc.)
                const platformY = y;  // Top of the detected object
                const platformX = x;
                const platformWidth = w;
                
                // Skip if platform would be in reserved areas
                const isStartArea = (platformX < START_AREA_WIDTH && platformY > canvasHeight - START_AREA_HEIGHT);
                const isGoalArea = (platformX > canvasWidth - GOAL_AREA_WIDTH && platformY < GOAL_AREA_HEIGHT);
                if (isStartArea || isGoalArea) continue;
                
                // Skip if platform is too small
                if (platformWidth < PLATFORM_MIN_WIDTH) continue;
                
                // Skip if platform is outside canvas bounds
                if (platformY < 0 || platformY > canvasHeight - PLATFORM_THICKNESS) continue;
                
                // Assign color based on detection confidence and whether it's a "platformable" object
                let color;
                if (detection.isPlatformable) {
                    // Green-tinted for explicitly platformable objects
                    const alpha = 0.75 + (detection.confidence * 0.2);
                    color = `rgba(60, 150, 80, ${alpha})`;
                } else {
                    // Blue-tinted for other detected objects
                    const alpha = 0.65 + (detection.confidence * 0.2);
                    color = `rgba(80, 100, 160, ${alpha})`;
                }
                
                platformCandidates.push({
                    x: platformX,
                    y: platformY,
                    width: platformWidth,
                    height: PLATFORM_THICKNESS,
                    color: color,
                    source: 'ml-detection',
                    detection: detection
                });
            }
            
            // Merge nearby platforms on similar Y positions
            return mergePlatformCandidates(platformCandidates);
        }

        // Merge platform candidates that are on similar Y levels and close horizontally
        function mergePlatformCandidates(candidates) {
            if (candidates.length === 0) return [];
            
            // Sort by Y then X
            candidates.sort((a, b) => a.y - b.y || a.x - b.x);
            
            const merged = [];
            let current = { ...candidates[0] };
            
            for (let i = 1; i < candidates.length; i++) {
                const next = candidates[i];
                
                // Merge if on same Y level (within tolerance) and horizontally adjacent/overlapping
                const sameRow = Math.abs(next.y - current.y) < PLATFORM_THICKNESS;
                const adjacent = next.x <= current.x + current.width + PLATFORM_MERGE_GAP_PX + ML_PLATFORM_MERGE_TOLERANCE;
                
                if (sameRow && adjacent) {
                    // Extend current platform
                    const newRight = Math.max(current.x + current.width, next.x + next.width);
                    current.width = newRight - current.x;
                } else {
                    merged.push(current);
                    current = { ...next };
                }
            }
            merged.push(current);
            
            return merged;
        }

        // ==========================================
        // End ONNX ML Detection Functions
        // ==========================================

        // Process image and create platforms
        async function processImage(image) {
            // Store the image for background rendering
            backgroundImage = image;

            // Set canvas size based on image aspect ratio
            const maxWidth = 800;
            const maxHeight = 600;
            let width = image.width;
            let height = image.height;

            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }

            canvas.width = width;
            canvas.height = height;
            previewCanvas.width = width;
            previewCanvas.height = height;

            // Draw image to preview canvas
            previewCtx.drawImage(image, 0, 0, width, height);
            const imageData = previewCtx.getImageData(0, 0, width, height);
            const data = imageData.data;

            // Create platforms based on brightness and edge detection
            platforms = [];
            const gridSize = GRID_SIZE;
            const brightnessThreshold = BRIGHTNESS_THRESHOLD;

            debugGridSize = gridSize;
            debugHelperPlatforms = [];
            debugSolidGrid = null;
            debugDetectedObjects = [];

            // Helper function to detect edges (helps identify objects better)
            function hasEdge(x, y, width, height, data) {
                // Allow edge detection near boundaries, just need 1-pixel neighbors
                if (x === 0 || y === 0 || x + 1 >= width || y + 1 >= height) {
                    return false;
                }
                
                // Get center brightness
                const centerI = (y * width + x) * 4;
                const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;
                
                // Check brightness difference with adjacent neighbors (1 pixel away)
                let maxDiff = 0;
                const checkPositions = [
                    [x - 1, y], [x + 1, y],
                    [x, y - 1], [x, y + 1]
                ];
                
                for (const [px, py] of checkPositions) {
                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const i = (py * width + px) * 4;
                        const neighborBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const diff = Math.abs(centerBrightness - neighborBrightness);
                        maxDiff = Math.max(maxDiff, diff);
                    }
                }
                // Significant brightness difference indicates an edge
                return maxDiff > EDGE_DETECTION_THRESHOLD;
            }

            function buildSolidGrid() {
                const cellsX = Math.ceil(width / gridSize);
                const cellsY = Math.ceil(height / gridSize);
                const solid = Array.from({ length: cellsY }, () => Array.from({ length: cellsX }, () => false));
                const brightness = Array.from({ length: cellsY }, () => Array.from({ length: cellsX }, () => 255));

                for (let cy = 0; cy < cellsY; cy++) {
                    for (let cx = 0; cx < cellsX; cx++) {
                        const x = cx * gridSize;
                        const y = cy * gridSize;

                        let totalBrightness = 0;
                        let pixelCount = 0;

                        // Calculate average brightness of grid cell
                        for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4;
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                const bness = (r + g + b) / 3;
                                totalBrightness += bness;
                                pixelCount++;
                            }
                        }

                        const avgBrightness = pixelCount > 0 ? (totalBrightness / pixelCount) : 255;
                        brightness[cy][cx] = avgBrightness;

                        // Create solid hint if brightness is below threshold OR at edges (better object detection)
                        const isEdge = hasEdge(x, y, width, height, data);

                        // Reserve start area (bottom-left) and goal area (top-right) - don't generate photo platforms there
                        const isStartArea = (x < START_AREA_WIDTH && y > height - START_AREA_HEIGHT);
                        const isGoalArea = (x > width - GOAL_AREA_WIDTH && y < GOAL_AREA_HEIGHT);

                        const isSolidHint = (!isStartArea && !isGoalArea) &&
                            (avgBrightness < brightnessThreshold || (isEdge && avgBrightness < EDGE_BRIGHTNESS_THRESHOLD));

                        solid[cy][cx] = Boolean(isSolidHint);
                    }
                }

                return { solid, brightness, cellsX, cellsY };
            }

            function platformColorFromBrightness(avgBrightness) {
                const alpha = 0.68;
                const colorValue = Math.floor(avgBrightness * 0.6);
                return `rgba(${colorValue}, ${colorValue}, ${colorValue}, ${alpha})`;
            }

            function extractTopSurfacesFromGrid(grid) {
                const { solid, brightness, cellsX, cellsY } = grid;
                const segments = [];

                for (let cy = 0; cy < cellsY; cy++) {
                    for (let cx = 0; cx < cellsX; cx++) {
                        if (!solid[cy][cx]) continue;
                        const aboveSolid = (cy > 0) ? solid[cy - 1][cx] : false;
                        if (aboveSolid) continue;

                        const x = cx * gridSize;
                        const y = cy * gridSize;
                        const w = Math.min(gridSize, width - x);
                        if (w <= 0) continue;

                        segments.push({
                            x,
                            y,
                            width: w,
                            brightness: brightness[cy][cx]
                        });
                    }
                }

                // Merge adjacent segments on the same y into longer platforms
                const merged = [];
                let current = null;

                for (const seg of segments) {
                    if (!current) {
                        current = { ...seg };
                        continue;
                    }

                    const touchesSameRow = seg.y === current.y;
                    const isAdjacent = seg.x <= (current.x + current.width + PLATFORM_MERGE_GAP_PX);

                    if (touchesSameRow && isAdjacent) {
                        const end = Math.max(current.x + current.width, seg.x + seg.width);
                        const totalWidth = end - current.x;
                        const weightedBrightness = ((current.brightness * current.width) + (seg.brightness * seg.width)) / (current.width + seg.width);
                        current.width = totalWidth;
                        current.brightness = weightedBrightness;
                    } else {
                        merged.push(current);
                        current = { ...seg };
                    }
                }
                if (current) merged.push(current);

                // Convert to platform objects, enforcing minimum width + thickness
                const platformsOut = [];
                for (const m of merged) {
                    if (m.width < PLATFORM_MIN_WIDTH) continue;
                    const color = platformColorFromBrightness(m.brightness);
                    platformsOut.push(new Platform(m.x, m.y, m.width, PLATFORM_THICKNESS, color, 'photo'));
                }

                return platformsOut;
            }

            function intervalGap(a1, a2, b1, b2) {
                if (a2 < b1) return b1 - a2;
                if (b2 < a1) return a1 - b2;
                return 0;
            }

            function getJumpLimits() {
                const jumpPower = PLAYER_JUMP_POWER;
                const gravity = PLAYER_GRAVITY;
                const speed = PLAYER_SPEED;

                const maxJumpUp = (jumpPower * jumpPower) / (2 * gravity);
                const maxHangTime = (2 * jumpPower) / gravity;
                const maxJumpDx = speed * maxHangTime;

                // Conservative safety margins (gameplay-first): if we say reachable, it should be reachable.
                return {
                    maxJumpUp: maxJumpUp * 0.9,
                    maxJumpDx: maxJumpDx * 0.85,
                    jumpPower,
                    gravity,
                    speed
                };
            }

            function canReachPlatform(from, to, limits) {
                if (from === to) return false;

                const fromLeft = from.x;
                const fromRight = from.x + from.width;
                const toLeft = to.x;
                const toRight = to.x + to.width;

                const dx = intervalGap(fromLeft, fromRight, toLeft, toRight);
                if (dx > limits.maxJumpDx) return false;

                const up = from.y - to.y;
                if (up <= 0) {
                    // Dropping down is allowed; keep conservative horizontal requirement only.
                    return true;
                }

                if (up > limits.maxJumpUp) return false;

                // More accurate horizontal limit for higher targets: time to reach that height (descending).
                const disc = (limits.jumpPower * limits.jumpPower) - (2 * limits.gravity * up);
                if (disc < 0) return false;
                const tLanding = (limits.jumpPower + Math.sqrt(disc)) / limits.gravity;
                const dxLimit = Math.min(limits.maxJumpDx, limits.speed * tLanding * 0.9);
                return dx <= dxLimit;
            }

            function isReachable(startPlatform, goalPlatform, allPlatforms, limits) {
                const visited = new Set();
                const queue = [startPlatform];
                visited.add(startPlatform);

                while (queue.length) {
                    const current = queue.shift();
                    if (current === goalPlatform) return true;

                    for (const next of allPlatforms) {
                        if (visited.has(next)) continue;
                        if (!canReachPlatform(current, next, limits)) continue;
                        visited.add(next);
                        queue.push(next);
                    }
                }

                return false;
            }

            function overlapsAny(candidate, allPlatforms) {
                for (const p of allPlatforms) {
                    const overlaps = !(candidate.x + candidate.width <= p.x ||
                        candidate.x >= p.x + p.width ||
                        candidate.y + candidate.height <= p.y ||
                        candidate.y >= p.y + p.height);
                    if (overlaps) return true;
                }
                return false;
            }

            function addHelperPlatformsIfNeeded(startPlatform, goalSupportPlatform, allPlatforms, limits) {
                if (isReachable(startPlatform, goalSupportPlatform, allPlatforms, limits)) {
                    return;
                }

                const helperWidth = Math.max(PLATFORM_MIN_WIDTH * 2, 80);
                const helperColor = 'rgba(80, 120, 255, 0.9)';

                let current = startPlatform;
                let added = 0;

                while (added < HELPERS_MAX_COUNT) {
                    if (isReachable(startPlatform, goalSupportPlatform, allPlatforms, limits)) return;

                    const currentCenter = current.x + current.width / 2;
                    const goalCenter = goalSupportPlatform.x + goalSupportPlatform.width / 2;

                    const toward = Math.sign(goalCenter - currentCenter) || 1;
                    const stepX = limits.maxJumpDx * 0.7;
                    const stepUp = limits.maxJumpUp * 0.7;

                    const targetY = Math.max(10, current.y - stepUp);
                    const idealX = currentCenter + toward * stepX - (helperWidth / 2);
                    let targetX = Math.max(0, Math.min(width - helperWidth, idealX));

                    // Avoid placing helpers inside the goal reserved area.
                    const wouldBeInGoalArea = (targetX > width - GOAL_AREA_WIDTH && targetY < GOAL_AREA_HEIGHT);
                    if (wouldBeInGoalArea) {
                        targetX = Math.max(0, width - GOAL_AREA_WIDTH - helperWidth - 10);
                    }

                    const candidate = new Platform(targetX, targetY, helperWidth, PLATFORM_THICKNESS, helperColor, 'helper');

                    // Deterministically search nearby x positions if we collide with existing geometry.
                    if (overlapsAny(candidate, allPlatforms)) {
                        let placed = false;
                        for (let offset = gridSize; offset <= gridSize * 8; offset += gridSize) {
                            const leftX = Math.max(0, targetX - offset);
                            const rightX = Math.min(width - helperWidth, targetX + offset);

                            const leftCandidate = new Platform(leftX, targetY, helperWidth, PLATFORM_THICKNESS, helperColor, 'helper');
                            if (!overlapsAny(leftCandidate, allPlatforms)) {
                                allPlatforms.push(leftCandidate);
                                debugHelperPlatforms.push(leftCandidate);
                                current = leftCandidate;
                                placed = true;
                                break;
                            }

                            const rightCandidate = new Platform(rightX, targetY, helperWidth, PLATFORM_THICKNESS, helperColor, 'helper');
                            if (!overlapsAny(rightCandidate, allPlatforms)) {
                                allPlatforms.push(rightCandidate);
                                debugHelperPlatforms.push(rightCandidate);
                                current = rightCandidate;
                                placed = true;
                                break;
                            }
                        }

                        if (!placed) {
                            // If we can't find a non-overlapping spot, stop adding helpers.
                            return;
                        }
                    } else {
                        allPlatforms.push(candidate);
                        debugHelperPlatforms.push(candidate);
                        current = candidate;
                    }

                    added++;
                }
            }

            // Build grid-based platforms (always run as baseline/fallback)
            const grid = buildSolidGrid();
            debugSolidGrid = grid.solid;
            let gridBasedPlatforms = extractTopSurfacesFromGrid(grid);

            // Try ML-based object detection if enabled
            let mlPlatforms = [];
            if (mlDetectionEnabled && onnxModelLoaded && onnxSession) {
                console.log('ü§ñ Running ML object detection...');
                try {
                    updateMLStatus('Detecting objects...');
                    const detections = await detectObjectsWithONNX(width, height);
                    debugDetectedObjects = detections;
                    
                    console.log(`ML detection found ${detections.length} total objects`);
                    
                    // Log all detections for debugging
                    if (detections.length > 0) {
                        console.log('Detected objects:', detections.map(d => 
                            `${d.class} (${(d.confidence * 100).toFixed(1)}%) ${d.isPlatformable ? '‚úì platformable' : '‚úó not platformable'}`
                        ).join(', '));
                    }
                    
                    const platformableDetections = detections.filter(d => d.isPlatformable);
                    console.log(`${platformableDetections.length} of those are platformable`);
                    
                    if (platformableDetections.length > 0) {
                        mlPlatforms = mapObjectsToPlatforms(detections, width, height);
                        
                        // Convert ML platform candidates to Platform objects
                        mlPlatforms = mlPlatforms.map(p => 
                            new Platform(p.x, p.y, p.width, p.height, p.color, 'ml')
                        );
                        
                        updateMLStatus(`${platformableDetections.length} objects ‚Üí platforms`);
                    } else if (detections.length > 0) {
                        console.log('‚ÑπÔ∏è Objects detected but none are platformable. Enable debug overlay to see them.');
                        updateMLStatus(`${detections.length} objects (none platformable)`);
                    } else {
                        console.log('‚ÑπÔ∏è No objects detected. Try photos with furniture, vehicles, or electronics.');
                        console.log('   Platformable objects: chairs, tables, couches, cars, laptops, etc.');
                        console.log('   Note: Buildings/architecture are not detected - use grid-based detection for those.');
                        updateMLStatus('No objects detected');
                    }
                } catch (err) {
                    console.warn('ML detection failed during inference:', err);
                    updateMLStatus('Detection failed');
                }
            }

            // Combine platforms: ML platforms take priority, then grid-based fill gaps
            // If ML detection is enabled and found platforms, prioritize those
            if (mlDetectionEnabled && mlPlatforms.length > 0) {
                // Use ML platforms as primary, with grid-based as supplement
                platforms = [...mlPlatforms];
                
                // Add grid-based platforms that don't significantly overlap with ML platforms
                for (const gridPlatform of gridBasedPlatforms) {
                    let overlapsML = false;
                    for (const mlPlatform of mlPlatforms) {
                        const overlap = !(gridPlatform.x + gridPlatform.width < mlPlatform.x ||
                            gridPlatform.x > mlPlatform.x + mlPlatform.width ||
                            gridPlatform.y + gridPlatform.height < mlPlatform.y - ML_PLATFORM_OVERLAP_TOLERANCE_Y ||
                            gridPlatform.y > mlPlatform.y + mlPlatform.height + ML_PLATFORM_OVERLAP_TOLERANCE_Y);
                        if (overlap) {
                            overlapsML = true;
                            break;
                        }
                    }
                    if (!overlapsML) {
                        platforms.push(gridPlatform);
                    }
                }
            } else {
                // Fall back to grid-based only
                platforms = gridBasedPlatforms;
            }

            // Add a ground platform at the bottom (darker and more opaque)
            platforms.push(new Platform(0, height - 20, width, 20, 'rgba(100, 60, 20, 0.8)', 'ground'));

            // Add starting platform (green to indicate start, larger and clearer)
            const startPlatformY = height - 60;
            const startPlatform = new Platform(10, startPlatformY, 100, 20, 'rgba(0, 180, 0, 0.9)', 'start');
            platforms.push(startPlatform);

            // Add goal at top-right corner of the level
            const goalX = width - 50;
            const goalY = 20;
            // Add a platform for the goal to sit on (golden and more visible)
            const goalSupportPlatform = new Platform(goalX - 10, goalY + 30, 50, 20, 'rgba(255, 200, 0, 0.9)', 'goal');
            platforms.push(goalSupportPlatform);
            goal = new Goal(goalX, goalY);

            // Initialize player ON the start platform (not above it)
            playerSpawnY = startPlatformY - 20; // Player height is 20, so spawn on top of platform
            player = new Player(PLAYER_SPAWN_X, playerSpawnY);
            
            // Remove any photo-generated platforms that overlap with player spawn area
            // to ensure player never spawns inside a block
            const spawnCheckX = PLAYER_SPAWN_X - 10;
            const spawnCheckY = playerSpawnY - 10;
            const spawnCheckWidth = 40;  // Player width + buffer
            const spawnCheckHeight = 40; // Player height + buffer
            
            platforms = platforms.filter(platform => {
                // Keep non-photo/non-ml platforms (ground/start/goal/helper)
                if (platform.kind !== 'photo' && platform.kind !== 'ml') return true;

                // Remove photo/ml platforms that overlap with spawn area
                const overlaps = !(platform.x + platform.width < spawnCheckX ||
                    platform.x > spawnCheckX + spawnCheckWidth ||
                    platform.y + platform.height < spawnCheckY ||
                    platform.y > spawnCheckY + spawnCheckHeight);
                return !overlaps;
            });

            // Ensure the level is winnable: add helper platforms only when needed.
            const limits = getJumpLimits();
            addHelperPlatformsIfNeeded(startPlatform, goalSupportPlatform, platforms, limits);

            // Place collectible letters on platforms
            placeLettersOnPlatforms();

            // Start game
            startGame();
        }

        // Fisher-Yates shuffle algorithm for unbiased array shuffling
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Place letters on platforms to spell a word
        function placeLettersOnPlatforms() {
            letters = [];
            collectedLetters = [];
            
            // Get platforms that are suitable for letter placement
            // Exclude ground, start, and goal platforms
            const suitablePlatforms = platforms.filter(p => 
                p.kind === 'photo' || p.kind === 'ml' || p.kind === 'helper'
            );
            
            if (suitablePlatforms.length === 0) {
                console.warn('No suitable platforms for letter placement');
                return;
            }
            
            // Choose a word that fits the available platforms
            // Filter words that have length <= number of suitable platforms
            const availableWords = WORD_DICTIONARY.filter(word => word.length <= suitablePlatforms.length);
            
            if (availableWords.length === 0) {
                // If no words fit, use the shortest word and allow platform reuse
                targetWord = WORD_DICTIONARY.reduce((shortest, word) => 
                    word.length < shortest.length ? word : shortest
                );
            } else {
                targetWord = availableWords[Math.floor(Math.random() * availableWords.length)];
            }
            
            // Shuffle platforms using Fisher-Yates algorithm
            const shuffledPlatforms = shuffleArray(suitablePlatforms);
            
            // Place each letter of the word on different platforms
            for (let i = 0; i < targetWord.length; i++) {
                const platform = shuffledPlatforms[i % shuffledPlatforms.length];
                
                // Place letter on top of platform, centered with some randomness
                const platformCenterX = platform.x + platform.width / 2;
                const randomOffsetX = (Math.random() - 0.5) * Math.min(platform.width * 0.4, 30);
                const letterX = platformCenterX + randomOffsetX - LETTER_SIZE / 2;
                const letterY = platform.y - LETTER_SIZE - 10;  // 10px above platform
                
                letters.push(new Letter(targetWord[i], letterX, letterY, i));
            }
            
            console.log(`Placed ${letters.length} letters to spell: ${targetWord}`);
        }

        // Start the game loop
        function startGame() {
            gameRunning = true;
            gameWon = false;  // Reset win state
            canvas.style.display = 'block';
            gameInfo.style.display = 'block';
            resetBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'none';
            cameraBtn.style.display = 'none';
            
            score = 0;
            wordCompleteBonus = 0;
            correctOrderBonus = 0;
            startTime = Date.now();
            scoreElement.textContent = score;
            
            // Enter fullscreen when game starts
            enterFullscreen();
            
            gameLoop();
        }

        // Main game loop
        function gameLoop() {
            if (!gameRunning) return;

            // Draw the photo as background instead of solid color
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback to sky blue if no image
                ctx.fillStyle = '#87ceeb';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Update and draw goal
            if (goal) {
                goal.update();
                goal.draw();
            }

            // Update and draw platforms
            for (let platform of platforms) {
                platform.draw();
            }

            if (debugOverlayEnabled && debugSolidGrid) {
                drawDebugOverlay();
            }

            // Update and draw letters
            for (let letter of letters) {
                letter.update();
                letter.draw();
            }

            // Update and draw player
            if (player && !gameWon) {
                player.update();
                player.draw();
                
                // Check for letter collection
                for (let letter of letters) {
                    if (letter.checkCollision(player)) {
                        letter.collected = true;
                        collectedLetters.push(letter);
                        
                        // Add points for the letter
                        score += LETTER_POINTS;
                        scoreElement.textContent = score;
                        
                        console.log(`Collected letter: ${letter.char} (${collectedLetters.length}/${targetWord.length})`);
                    }
                }
                
                // Check if player reached the goal
                if (goal && goal.checkCollision(player)) {
                    // Calculate bonuses if all letters were collected
                    if (collectedLetters.length === targetWord.length) {
                        wordCompleteBonus = WORD_COMPLETE_BONUS;
                        score += wordCompleteBonus;
                        
                        // Check if letters were collected in correct order
                        let correctOrder = true;
                        for (let i = 0; i < collectedLetters.length; i++) {
                            if (collectedLetters[i].index !== i) {
                                correctOrder = false;
                                break;
                            }
                        }
                        
                        if (correctOrder) {
                            correctOrderBonus = CORRECT_ORDER_BONUS;
                            score += correctOrderBonus;
                        }
                        
                        scoreElement.textContent = score;
                    }
                    gameWon = true;
                }
            } else if (player && gameWon) {
                // Just draw the player when game is won, don't update
                player.draw();
            }

            // Draw collected letters display
            drawCollectedLetters();

            // Draw win message if game is won
            if (gameWon) {
                drawWinMessage();
            }

            // Update time
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            timeElement.textContent = elapsedTime;

            requestAnimationFrame(gameLoop);
        }

        function drawDebugOverlay() {
            const gridSize = debugGridSize;
            if (!gridSize) return;

            // Solid grid hint
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = '#00bcd4';

            for (let cy = 0; cy < debugSolidGrid.length; cy++) {
                const row = debugSolidGrid[cy];
                for (let cx = 0; cx < row.length; cx++) {
                    if (!row[cx]) continue;
                    const x = cx * gridSize;
                    const y = cy * gridSize;
                    const w = Math.min(gridSize, canvas.width - x);
                    const h = Math.min(gridSize, canvas.height - y);
                    ctx.fillRect(x, y, w, h);
                }
            }

            // Helper platforms highlight
            ctx.globalAlpha = 1;
            ctx.strokeStyle = 'rgba(80, 120, 255, 1)';
            ctx.lineWidth = 2;
            for (const p of debugHelperPlatforms) {
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            }

            // ML detected objects overlay (only in debug mode)
            if (debugOverlayEnabled && debugDetectedObjects && debugDetectedObjects.length > 0) {
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                
                for (const detection of debugDetectedObjects) {
                    const [x, y, w, h] = detection.bbox;
                    
                    // Draw bounding box
                    if (detection.isPlatformable) {
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                    } else {
                        ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                    }
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                    
                    // Draw label background
                    const label = `${detection.class} (${Math.round(detection.confidence * 100)}%)`;
                    const textWidth = ctx.measureText(label).width;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(x, y - 16, textWidth + 6, 16);
                    
                    // Draw label text
                    ctx.fillStyle = detection.isPlatformable ? '#00ff00' : '#ffa500';
                    ctx.fillText(label, x + 3, y - 4);
                }
            }

            ctx.restore();
        }

        // Draw collected letters display at the top of the screen
        function drawCollectedLetters() {
            if (letters.length === 0) return;
            
            ctx.save();
            
            // Draw background panel
            const panelHeight = 40;
            const panelY = 10;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, panelY, canvas.width - 20, panelHeight);
            
            // Draw label
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText('Collect:', 20, panelY + panelHeight / 2);
            
            // Draw target word letters
            const letterSpacing = 25;
            const startX = 90;
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            
            for (let i = 0; i < targetWord.length; i++) {
                const x = startX + i * letterSpacing;
                const y = panelY + panelHeight / 2;
                
                // Check if this letter has been collected
                const collected = collectedLetters.some(l => l.index === i);
                
                // Draw letter circle
                if (collected) {
                    ctx.fillStyle = '#FFD700';
                } else {
                    ctx.fillStyle = '#555';
                }
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw letter
                ctx.fillStyle = collected ? '#000' : '#AAA';
                ctx.fillText(targetWord[i], x, y);
            }
            
            // Draw collection progress
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`${collectedLetters.length}/${targetWord.length}`, canvas.width - 20, panelY + panelHeight / 2);
            
            ctx.restore();
        }

        // Draw win message overlay
        function drawWinMessage() {
            // Calculate message height based on content
            let messageHeight = 100;
            let yOffset = 0;
            
            if (collectedLetters.length === targetWord.length) {
                messageHeight = 180;
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, canvas.height / 2 - messageHeight / 2, canvas.width, messageHeight);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üéâ YOU WIN! üéâ', canvas.width / 2, canvas.height / 2 - 50);
            
            // Show word if all letters were collected
            if (collectedLetters.length === targetWord.length) {
                ctx.font = 'bold 28px Arial';
                ctx.fillStyle = '#00FF00';
                ctx.fillText(`You spelled: ${targetWord}!`, canvas.width / 2, canvas.height / 2 - 15);
                
                // Show bonuses
                ctx.font = '18px Arial';
                ctx.fillStyle = '#FFF';
                yOffset = 10;
                ctx.fillText(`Word Complete Bonus: +${wordCompleteBonus}`, canvas.width / 2, canvas.height / 2 + yOffset);
                
                if (correctOrderBonus > 0) {
                    yOffset += 25;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(`‚ú® Correct Order Bonus: +${correctOrderBonus} ‚ú®`, canvas.width / 2, canvas.height / 2 + yOffset);
                }
                
                yOffset += 30;
            } else {
                yOffset = 0;
            }
            
            ctx.font = '20px Arial';
            ctx.fillStyle = '#FFF';
            ctx.fillText(`Time: ${Math.floor((Date.now() - startTime) / 1000)}s`, canvas.width / 2, canvas.height / 2 + yOffset + 30);
            ctx.font = '16px Arial';
            ctx.fillText('Press ESC or click "Exit Game" to return to start', canvas.width / 2, canvas.height / 2 + yOffset + 55);
        }

        // Show intro screen
        function showIntroScreen() {
            introScreen.classList.remove('hidden');
            gameScreen.classList.remove('active');
            exitFullscreen();
        }

        // Show game screen
        function showGameScreen() {
            introScreen.classList.add('hidden');
            gameScreen.classList.add('active');
        }

        // Enter fullscreen
        function enterFullscreen() {
            gameCanvasContainer.classList.add('fullscreen');
            exitFullscreenBtn.classList.add('visible');
            document.body.style.overflow = 'hidden';
        }

        // Exit fullscreen
        function exitFullscreen() {
            gameCanvasContainer.classList.remove('fullscreen');
            exitFullscreenBtn.classList.remove('visible');
            document.body.style.overflow = '';
        }

        // Return to intro and exit fullscreen
        function returnToIntro() {
            resetGame();
            showIntroScreen();
        }

        // Reset game
        function resetGame() {
            gameRunning = false;
            gameWon = false;
            platforms = [];
            player = null;
            goal = null;  // Clear goal
            score = 0;
            letters = [];  // Clear letters
            collectedLetters = [];  // Clear collected letters
            targetWord = '';  // Clear target word
            wordCompleteBonus = 0;
            correctOrderBonus = 0;
            backgroundImage = null; // Clear background image
            canvas.style.display = 'none';
            gameInfo.style.display = 'none';
            resetBtn.style.display = 'none';
            uploadBtn.style.display = 'inline-block';
            cameraBtn.style.display = 'inline-block';
        }

        function guessDeviceType() {
            const ua = (navigator.userAgent || '').toLowerCase();
            if (ua.includes('ipad') || ua.includes('tablet')) return 'tablet';
            if (ua.includes('iphone') || ua.includes('android')) {
                return ua.includes('mobile') ? 'mobile' : 'tablet';
            }
            if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
                return window.innerWidth >= 768 ? 'tablet' : 'mobile';
            }
            return 'desktop';
        }

        function setFeedbackStatus(text, kind) {
            feedbackStatus.textContent = text || '';
            feedbackStatus.classList.remove('error', 'success');
            if (kind) feedbackStatus.classList.add(kind);
        }

        function openFeedbackModal() {
            feedbackDeviceType.value = guessDeviceType();
            setFeedbackStatus('', null);
            feedbackModal.classList.add('open');
            feedbackModal.setAttribute('aria-hidden', 'false');

            if (location.protocol === 'file:') {
                setFeedbackStatus('Feedback requires running the local server (not file://).', 'error');
            }

            setTimeout(() => {
                feedbackMessage.focus();
            }, 0);
        }

        function closeFeedbackModal() {
            feedbackModal.classList.remove('open');
            feedbackModal.setAttribute('aria-hidden', 'true');
        }

        async function postFeedback(message, deviceType, token) {
            const headers = {
                'Content-Type': 'application/json'
            };
            if (token) headers['X-Feedback-Token'] = token;

            return fetch('/api/feedback', {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    message,
                    deviceType
                })
            });
        }

        function shouldIgnoreGameKeyEvent(e) {
            if (feedbackModal.classList.contains('open')) return true;
            const target = e.target;
            if (!target) return false;
            if (target.isContentEditable) return true;
            const tag = (target.tagName || '').toUpperCase();
            return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        }

        function updateLanHint() {
            if (location.protocol === 'file:') {
                lanHint.classList.remove('open');
                return;
            }

            lanHint.classList.add('open');
            lanUrl.textContent = location.href;

            const host = (location.hostname || '').toLowerCase();
            if (host === 'localhost' || host === '127.0.0.1') {
                lanNote.innerHTML = 'If you\'re sharing to other devices, replace <strong>localhost</strong> with the host computer\'s LAN IP (e.g. <strong>192.168.x.x</strong>).';
            } else if (host === '0.0.0.0') {
                lanNote.innerHTML = 'Use the host computer\'s LAN IP instead of <strong>0.0.0.0</strong> when sharing (e.g. <strong>192.168.x.x</strong>).';
            } else {
                lanNote.textContent = 'Open this URL on devices connected to the same network.';
            }
        }

        if (debugOverlayToggle) {
            debugOverlayToggle.checked = DEBUG_DEFAULT_ENABLED;
            debugOverlayToggle.addEventListener('change', () => {
                debugOverlayEnabled = Boolean(debugOverlayToggle.checked);
            });
        }

        // ML Detection toggle handling
        const mlDetectionToggle = document.getElementById('mlDetectionToggle');
        if (mlDetectionToggle) {
            mlDetectionToggle.checked = ML_DETECTION_ENABLED_DEFAULT;
            mlDetectionToggle.addEventListener('change', async () => {
                mlDetectionEnabled = Boolean(mlDetectionToggle.checked);
                
                if (mlDetectionEnabled && !onnxModelLoaded && !onnxModelLoading) {
                    // Reset error state to allow retry
                    onnxLoadError = null;
                    
                    // Start loading the ONNX model when user enables ML detection
                    const success = await initONNXModel();
                    if (!success) {
                        // If loading fails, disable the toggle and show helpful message
                        mlDetectionToggle.checked = false;
                        mlDetectionEnabled = false;
                        
                        // Show actual error from console
                        const errorMsg = onnxLoadError?.message || 'Unknown error';
                        alert('ML detection failed to load.\n\n' +
                            'Error: ' + errorMsg + '\n\n' +
                            'Check browser console (F12) for details.\n\n' +
                            'Common fixes:\n' +
                            '- Refresh the page\n' +
                            '- Check internet connection (CDN needed)\n' +
                            '- Clear browser cache\n\n' +
                            'See docs/ONNX_SETUP.md for full troubleshooting.');
                    }
                } else if (mlDetectionEnabled && onnxModelLoaded) {
                    updateMLStatus('ML ready');
                } else {
                    updateMLStatus('');
                }
            });
        }

        async function copyLanLink() {
            const text = location.href;
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const temp = document.createElement('textarea');
                    temp.value = text;
                    temp.style.position = 'fixed';
                    temp.style.left = '-9999px';
                    document.body.appendChild(temp);
                    temp.focus();
                    temp.select();
                    document.execCommand('copy');
                    document.body.removeChild(temp);
                }
                copyLinkBtn.textContent = 'Copied';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 900);
            } catch {
                copyLinkBtn.textContent = 'Copy failed';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 1200);
            }
        }

        // Event listeners
        startGameBtn.addEventListener('click', showGameScreen);
        exitFullscreenBtn.addEventListener('click', returnToIntro);
        
        uploadBtn.addEventListener('click', () => fileInput.click());
        cameraBtn.addEventListener('click', () => cameraInput.click());
        resetBtn.addEventListener('click', returnToIntro);

        copyLinkBtn.addEventListener('click', copyLanLink);

        feedbackBtn.addEventListener('click', openFeedbackModal);
        feedbackCancelBtn.addEventListener('click', closeFeedbackModal);
        feedbackModal.addEventListener('click', (e) => {
            if (e.target === feedbackModal) closeFeedbackModal();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please select a valid image file.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('File is too large. Please select an image under 10MB.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try a different file.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read file. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        cameraInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please capture a valid image.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('Image is too large. Please try again.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try again.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read image. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        feedbackForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const message = (feedbackMessage.value || '').trim();
            const deviceType = feedbackDeviceType.value || 'unknown';

            if (!message) {
                setFeedbackStatus('Please enter a message.', 'error');
                return;
            }

            feedbackSubmitBtn.disabled = true;
            setFeedbackStatus('Sending‚Ä¶', null);

            try {
                let token = localStorage.getItem(FEEDBACK_TOKEN_STORAGE_KEY) || '';
                let response = await postFeedback(message, deviceType, token);

                if (response.status === 401) {
                    const enteredToken = window.prompt('This server requires an access code. Enter it to send feedback:');
                    if (enteredToken) {
                        localStorage.setItem(FEEDBACK_TOKEN_STORAGE_KEY, enteredToken);
                        token = enteredToken;
                        response = await postFeedback(message, deviceType, token);
                    }
                }

                if (!response.ok) {
                    const text = await response.text();
                    setFeedbackStatus(`Failed to send feedback (${response.status}). ${text ? 'Details: ' + text : ''}`.trim(), 'error');
                    return;
                }

                feedbackMessage.value = '';
                setFeedbackStatus('Sent. Thank you!', 'success');

                setTimeout(() => {
                    closeFeedbackModal();
                }, 700);
            } catch (err) {
                setFeedbackStatus('Failed to send feedback. Is the local server running?', 'error');
            } finally {
                feedbackSubmitBtn.disabled = false;
            }
        });

        updateLanHint();

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // ESC key returns to intro screen
            if (e.key === 'Escape') {
                if (gameScreen.classList.contains('active')) {
                    returnToIntro();
                    e.preventDefault();
                }
                return;
            }
            
            if (shouldIgnoreGameKeyEvent(e)) return;
            
            // Manual respawn with 'R' key
            if ((e.key === 'r' || e.key === 'R') && player && gameRunning) {
                player.respawn();
                e.preventDefault();
                return;
            }
            
            keys[e.key] = true;
            // Prevent default for arrow keys and space
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (shouldIgnoreGameKeyEvent(e)) return;
            keys[e.key] = false;
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
            
            // Jump on tap
            touchJumping = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // Horizontal movement based on touch position
            const deltaX = touchX - touchStartX;
            
            if (deltaX < -20) {
                keys['ArrowLeft'] = true;
                keys['ArrowRight'] = false;
            } else if (deltaX > 20) {
                keys['ArrowRight'] = true;
                keys['ArrowLeft'] = false;
            } else {
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });

        // Mobile control button handlers
        // Detect if device supports touch and show controls
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            mobileControls.classList.add('visible');
        }

        // Left button
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        leftBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });

        // Right button
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        rightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        rightBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });

        // Jump button
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchJumping = true;
        });
        jumpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
        });
        jumpBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchJumping = false;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && feedbackModal.classList.contains('open')) {
                closeFeedbackModal();
            }
        });

        // Register Service Worker for PWA/offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
