<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Jumper - Platform Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .lan-hint {
            margin-top: -6px;
            margin-bottom: 18px;
            background: #f7f7ff;
            border: 1px solid #e3e3ff;
            border-radius: 12px;
            padding: 12px;
            display: none;
        }

        .lan-hint.open {
            display: block;
        }

        .lan-hint .row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .lan-hint .label {
            font-weight: bold;
            color: #333;
        }

        .lan-hint code {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px 10px;
            display: inline-block;
            max-width: 100%;
            overflow-wrap: anywhere;
        }

        .lan-hint .note {
            margin-top: 8px;
            color: #666;
            font-size: 13px;
        }

        .lan-hint .note strong {
            color: #333;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #fileInput, #cameraInput {
            display: none;
        }

        .game-canvas-container {
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 3px solid #333;
            border-radius: 10px;
            max-width: 100%;
            background: #87ceeb;
            display: none;
        }

        .instructions {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .instructions p {
            margin-bottom: 8px;
            color: #666;
        }

        .game-info {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: none;
        }

        .preview-canvas {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 1000;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 520px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        }

        .modal-content h3 {
            margin-bottom: 8px;
            color: #333;
        }

        .modal-content .hint {
            margin-bottom: 14px;
            color: #666;
            font-size: 14px;
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            text-align: left;
        }

        .form-row label {
            font-weight: bold;
            color: #333;
        }

        .form-row select,
        .form-row textarea {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 10px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-row textarea {
            resize: vertical;
            min-height: 110px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .status {
            margin-top: 10px;
            min-height: 18px;
            color: #333;
            font-size: 14px;
        }

        .status.error {
            color: #b00020;
        }

        .status.success {
            color: #0b6b0b;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
            }

            button {
                padding: 10px 20px;
                font-size: 14px;
            }

            .container {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ Photo Jumper</h1>
        
        <div class="upload-section">
            <div class="button-group">
                <button id="uploadBtn">üìÅ Upload Photo</button>
                <button id="cameraBtn">üì∑ Take Photo</button>
                <button id="resetBtn" style="display: none;">üîÑ New Photo</button>
                <button id="feedbackBtn" type="button">üìù Feedback</button>
            </div>

            <div id="lanHint" class="lan-hint" aria-live="polite">
                <div class="row">
                    <div>
                        <div class="label">Share link</div>
                        <code id="lanUrl"></code>
                    </div>
                    <button id="copyLinkBtn" type="button">Copy</button>
                </div>
                <div id="lanNote" class="note"></div>
            </div>

            <input type="file" id="fileInput" accept="image/*">
            <input type="file" id="cameraInput" accept="image/*" capture="environment">
        </div>

        <div class="game-info" id="gameInfo">
            Score: <span id="score">0</span> | Time: <span id="time">0</span>s
        </div>

        <div class="game-canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <canvas id="previewCanvas" class="preview-canvas"></canvas>
        </div>

        <div class="instructions">
            <h3>How to Play:</h3>
            <p>1. Upload a photo or take one with your camera</p>
            <p>2. The photo will be converted into platforms based on brightness</p>
            <p>3. Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move (or touch controls on mobile)</p>
            <p>4. Press <strong>Space</strong> or <strong>Up Arrow</strong> to jump</p>
            <p>5. Navigate from the green start platform to the golden goal star!</p>
            <p>6. Press <strong>R</strong> to respawn if you get stuck</p>
        </div>

        <div id="feedbackModal" class="modal" aria-hidden="true">
            <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="feedbackTitle">
                <h3 id="feedbackTitle">Send Feedback</h3>
                <p class="hint">Text-only feedback is saved locally on the host machine.</p>

                <form id="feedbackForm">
                    <div class="form-row">
                        <label for="feedbackDeviceType">Device type</label>
                        <select id="feedbackDeviceType" required>
                            <option value="unknown">Unknown</option>
                            <option value="desktop">Desktop / Laptop</option>
                            <option value="tablet">Tablet</option>
                            <option value="mobile">Mobile</option>
                        </select>
                    </div>

                    <div class="form-row">
                        <label for="feedbackMessage">Message</label>
                        <textarea id="feedbackMessage" maxlength="2000" placeholder="What worked well? What was confusing or buggy?" required></textarea>
                    </div>

                    <div class="modal-actions">
                        <button type="button" id="feedbackCancelBtn">Cancel</button>
                        <button type="submit" id="feedbackSubmitBtn">Send</button>
                    </div>
                    <div id="feedbackStatus" class="status" aria-live="polite"></div>
                </form>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        
        const uploadBtn = document.getElementById('uploadBtn');
        const cameraBtn = document.getElementById('cameraBtn');
        const resetBtn = document.getElementById('resetBtn');
        const feedbackBtn = document.getElementById('feedbackBtn');
        const fileInput = document.getElementById('fileInput');
        const cameraInput = document.getElementById('cameraInput');
        const gameInfo = document.getElementById('gameInfo');
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');

        const feedbackModal = document.getElementById('feedbackModal');
        const feedbackForm = document.getElementById('feedbackForm');
        const feedbackDeviceType = document.getElementById('feedbackDeviceType');
        const feedbackMessage = document.getElementById('feedbackMessage');
        const feedbackCancelBtn = document.getElementById('feedbackCancelBtn');
        const feedbackSubmitBtn = document.getElementById('feedbackSubmitBtn');
        const feedbackStatus = document.getElementById('feedbackStatus');

        const lanHint = document.getElementById('lanHint');
        const lanUrl = document.getElementById('lanUrl');
        const lanNote = document.getElementById('lanNote');
        const copyLinkBtn = document.getElementById('copyLinkBtn');

        const FEEDBACK_TOKEN_STORAGE_KEY = 'photoJumperFeedbackToken';

        // Game configuration constants
        const GRID_SIZE = 40;  // Increased from 20 to create gaps for jumping
        const BRIGHTNESS_THRESHOLD = 128;
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
        
        // Player spawn and reserved area constants
        const PLAYER_SPAWN_X = 40;
        const PLAYER_SPAWN_Y_OFFSET = 100; // Pixels above canvas bottom
        const START_AREA_WIDTH = 120;
        const START_AREA_HEIGHT = 80;
        const GOAL_AREA_WIDTH = 100;
        const GOAL_AREA_HEIGHT = 80;

        let gameRunning = false;
        let platforms = [];
        let player = null;
        let goal = null;  // Goal/end point for the level
        let keys = {};
        let score = 0;
        let startTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchJumping = false;
        let backgroundImage = null; // Store the uploaded photo for background
        let gameWon = false;  // Track if player reached the goal

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;  // Reduced from 30 to fit better in spaces
                this.height = 20; // Reduced from 30 to fit better in spaces
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = 5;
                this.jumpPower = 12;
                this.gravity = 0.5;
                this.onGround = false;
                this.lastPositionTime = Date.now();
                this.lastX = x;
                this.lastY = y;
                this.stuckCheckInterval = 3000; // Check if stuck every 3 seconds
            }

            update() {
                // Horizontal movement
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    this.velocityX = -this.speed;
                } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    this.velocityX = this.speed;
                } else {
                    this.velocityX *= 0.8; // Friction
                }

                // Jumping
                if ((keys['ArrowUp'] || keys['w'] || keys['W'] || keys[' '] || touchJumping) && this.onGround) {
                    this.velocityY = -this.jumpPower;
                    this.onGround = false;
                    touchJumping = false; // Reset touch jump
                }

                // Apply gravity
                this.velocityY += this.gravity;

                // Update horizontal position
                this.x += this.velocityX;

                // Check horizontal platform collisions
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Push out from sides
                        if (this.x + this.width / 2 < platform.x + platform.width / 2) {
                            this.x = platform.x - this.width;
                        } else {
                            this.x = platform.x + platform.width;
                        }
                        this.velocityX = 0;
                    }
                }

                // Update vertical position
                this.y += this.velocityY;

                // Check vertical platform collisions
                this.onGround = false;
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Landing on top of platform
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                        // Hitting platform from below
                        else if (this.velocityY < 0 && this.y - this.velocityY >= platform.y + platform.height) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                    }
                }

                // Boundary checks
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

                // Check if player fell off
                if (this.y > canvas.height) {
                    this.respawn();
                }

                // Stuck detection: if player hasn't moved significantly in a while
                const now = Date.now();
                const distMoved = Math.sqrt((this.x - this.lastX) ** 2 + (this.y - this.lastY) ** 2);
                
                if (now - this.lastPositionTime > this.stuckCheckInterval) {
                    if (distMoved < 5 && this.onGround) {
                        // Player appears stuck, auto-respawn
                        this.respawn();
                    }
                    // Update last known position
                    this.lastX = this.x;
                    this.lastY = this.y;
                    this.lastPositionTime = now;
                }

                // Update score based on highest position reached
                const currentScore = Math.max(0, Math.floor((canvas.height - this.y) / 10));
                if (currentScore > score) {
                    score = currentScore;
                    scoreElement.textContent = score;
                }
            }

            checkCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            respawn() {
                this.x = PLAYER_SPAWN_X;
                this.y = canvas.height - PLAYER_SPAWN_Y_OFFSET;
                this.velocityX = 0;
                this.velocityY = 0;
                score = Math.max(0, score - 10);
                scoreElement.textContent = score;
            }

            draw() {
                // Draw shadow/outline for better visibility on photo
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x + 2, this.y + 2, this.width, this.height);
                
                // Draw main body
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw border for visibility
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Draw eyes (adjusted for smaller size)
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x + 4, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 12, this.y + 5, 4, 4);
                
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x + 5, this.y + 6, 2, 2);
                ctx.fillRect(this.x + 13, this.y + 6, 2, 2);
            }
        }

        // Goal class - represents the end goal for the level
        class Goal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.animation = 0;
            }

            update() {
                this.animation += 0.1;
            }

            checkCollision(player) {
                return player.x < this.x + this.width &&
                       player.x + player.width > this.x &&
                       player.y < this.y + this.height &&
                       player.y + player.height > this.y;
            }

            draw() {
                // Draw animated star/goal
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                const outerRadius = 15 + Math.sin(this.animation) * 2;
                const innerRadius = 7;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.animation * 0.5);
                
                // Draw star
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                
                // Gradient fill
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, outerRadius);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(1, '#FFA500');
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.strokeStyle = '#FF8C00';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        // Platform class
        class Platform {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        // Process image and create platforms
        function processImage(image) {
            // Store the image for background rendering
            backgroundImage = image;

            // Set canvas size based on image aspect ratio
            const maxWidth = 800;
            const maxHeight = 600;
            let width = image.width;
            let height = image.height;

            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }

            canvas.width = width;
            canvas.height = height;
            previewCanvas.width = width;
            previewCanvas.height = height;

            // Draw image to preview canvas
            previewCtx.drawImage(image, 0, 0, width, height);
            const imageData = previewCtx.getImageData(0, 0, width, height);
            const data = imageData.data;

            // Create platforms based on brightness and edge detection
            platforms = [];
            const gridSize = GRID_SIZE;
            const brightnessThreshold = BRIGHTNESS_THRESHOLD;

            // Helper function to detect edges (helps identify objects better)
            function hasEdge(x, y, width, height, data) {
                if (x === 0 || y === 0 || x + gridSize >= width || y + gridSize >= height) {
                    return false;
                }
                
                // Get center brightness
                const centerI = (y * width + x) * 4;
                const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;
                
                // Check brightness difference with neighbors
                let maxDiff = 0;
                const checkPositions = [
                    [x - 1, y], [x + gridSize, y],
                    [x, y - 1], [x, y + gridSize]
                ];
                
                for (const [px, py] of checkPositions) {
                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const i = (py * width + px) * 4;
                        const neighborBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const diff = Math.abs(centerBrightness - neighborBrightness);
                        maxDiff = Math.max(maxDiff, diff);
                    }
                }
                // Significant brightness difference indicates an edge
                return maxDiff > 40;
            }

            for (let y = 0; y < height; y += gridSize) {
                for (let x = 0; x < width; x += gridSize) {
                    let totalBrightness = 0;
                    let pixelCount = 0;

                    // Calculate average brightness of grid cell
                    for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                            const i = ((y + dy) * width + (x + dx)) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const brightness = (r + g + b) / 3;
                            totalBrightness += brightness;
                            pixelCount++;
                        }
                    }

                    const avgBrightness = totalBrightness / pixelCount;

                    // Create platform if brightness is below threshold OR at edges (better object detection)
                    const isEdge = hasEdge(x, y, width, height, data);
                    
                    // Reserve start area (bottom-left) and goal area (top-right) - don't generate platforms there
                    const isStartArea = (x < START_AREA_WIDTH && y > height - START_AREA_HEIGHT);
                    const isGoalArea = (x > width - GOAL_AREA_WIDTH && y < GOAL_AREA_HEIGHT);
                    
                    if (!isStartArea && !isGoalArea && (avgBrightness < brightnessThreshold || (isEdge && avgBrightness < 180))) {
                        const platformWidth = Math.min(gridSize, width - x);
                        const platformHeight = Math.min(gridSize, height - y);
                        
                        // Ensure minimum platform size for better navigability
                        if (platformWidth >= gridSize && platformHeight >= gridSize) {
                            // Use darker, more opaque color for better visibility
                            const alpha = 0.7; // Increased from 0.4 to 0.7 for better visibility
                            const colorValue = Math.floor(avgBrightness * 0.6); // Darker shade
                            const color = `rgba(${colorValue}, ${colorValue}, ${colorValue}, ${alpha})`;
                            
                            platforms.push(new Platform(x, y, platformWidth, platformHeight, color));
                        }
                    }
                }
            }

            // Add a ground platform at the bottom (darker and more opaque)
            platforms.push(new Platform(0, height - 20, width, 20, 'rgba(100, 60, 20, 0.8)'));

            // Add starting platform (green to indicate start, larger and clearer)
            platforms.push(new Platform(10, height - 60, 100, 20, 'rgba(0, 180, 0, 0.9)'));

            // Add goal at top-right corner of the level
            const goalX = width - 50;
            const goalY = 20;
            // Add a platform for the goal to sit on (golden and more visible)
            platforms.push(new Platform(goalX - 10, goalY + 30, 50, 20, 'rgba(255, 200, 0, 0.9)'));
            goal = new Goal(goalX, goalY);

            // Initialize player on the start platform
            player = new Player(PLAYER_SPAWN_X, height - PLAYER_SPAWN_Y_OFFSET);

            // Start game
            startGame();
        }

        // Start the game loop
        function startGame() {
            gameRunning = true;
            gameWon = false;  // Reset win state
            canvas.style.display = 'block';
            gameInfo.style.display = 'block';
            resetBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'none';
            cameraBtn.style.display = 'none';
            
            score = 0;
            startTime = Date.now();
            scoreElement.textContent = score;
            
            gameLoop();
        }

        // Main game loop
        function gameLoop() {
            if (!gameRunning) return;

            // Draw the photo as background instead of solid color
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback to sky blue if no image
                ctx.fillStyle = '#87ceeb';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Update and draw goal
            if (goal) {
                goal.update();
                goal.draw();
            }

            // Update and draw platforms
            for (let platform of platforms) {
                platform.draw();
            }

            // Update and draw player
            if (player) {
                player.update();
                player.draw();
                
                // Check if player reached the goal
                if (goal && !gameWon && goal.checkCollision(player)) {
                    gameWon = true;
                }
            }

            // Draw win message if game is won
            if (gameWon) {
                drawWinMessage();
            }

            // Update time
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            timeElement.textContent = elapsedTime;

            requestAnimationFrame(gameLoop);
        }

        // Draw win message overlay
        function drawWinMessage() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üéâ YOU WIN! üéâ', canvas.width / 2, canvas.height / 2);
            ctx.font = '20px Arial';
            ctx.fillStyle = '#FFF';
            ctx.fillText(`Time: ${Math.floor((Date.now() - startTime) / 1000)}s`, canvas.width / 2, canvas.height / 2 + 30);
        }

        // Reset game
        function resetGame() {
            gameRunning = false;
            gameWon = false;
            platforms = [];
            player = null;
            goal = null;  // Clear goal
            score = 0;
            backgroundImage = null; // Clear background image
            canvas.style.display = 'none';
            gameInfo.style.display = 'none';
            resetBtn.style.display = 'none';
            uploadBtn.style.display = 'inline-block';
            cameraBtn.style.display = 'inline-block';
        }

        function guessDeviceType() {
            const ua = (navigator.userAgent || '').toLowerCase();
            if (ua.includes('ipad') || ua.includes('tablet')) return 'tablet';
            if (ua.includes('iphone') || ua.includes('android')) {
                return ua.includes('mobile') ? 'mobile' : 'tablet';
            }
            if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
                return window.innerWidth >= 768 ? 'tablet' : 'mobile';
            }
            return 'desktop';
        }

        function setFeedbackStatus(text, kind) {
            feedbackStatus.textContent = text || '';
            feedbackStatus.classList.remove('error', 'success');
            if (kind) feedbackStatus.classList.add(kind);
        }

        function openFeedbackModal() {
            feedbackDeviceType.value = guessDeviceType();
            setFeedbackStatus('', null);
            feedbackModal.classList.add('open');
            feedbackModal.setAttribute('aria-hidden', 'false');

            if (location.protocol === 'file:') {
                setFeedbackStatus('Feedback requires running the local server (not file://).', 'error');
            }

            setTimeout(() => {
                feedbackMessage.focus();
            }, 0);
        }

        function closeFeedbackModal() {
            feedbackModal.classList.remove('open');
            feedbackModal.setAttribute('aria-hidden', 'true');
        }

        async function postFeedback(message, deviceType, token) {
            const headers = {
                'Content-Type': 'application/json'
            };
            if (token) headers['X-Feedback-Token'] = token;

            return fetch('/api/feedback', {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    message,
                    deviceType
                })
            });
        }

        function shouldIgnoreGameKeyEvent(e) {
            if (feedbackModal.classList.contains('open')) return true;
            const target = e.target;
            if (!target) return false;
            if (target.isContentEditable) return true;
            const tag = (target.tagName || '').toUpperCase();
            return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        }

        function updateLanHint() {
            if (location.protocol === 'file:') {
                lanHint.classList.remove('open');
                return;
            }

            lanHint.classList.add('open');
            lanUrl.textContent = location.href;

            const host = (location.hostname || '').toLowerCase();
            if (host === 'localhost' || host === '127.0.0.1') {
                lanNote.innerHTML = 'If you\'re sharing to other devices, replace <strong>localhost</strong> with the host computer\'s LAN IP (e.g. <strong>192.168.x.x</strong>).';
            } else if (host === '0.0.0.0') {
                lanNote.innerHTML = 'Use the host computer\'s LAN IP instead of <strong>0.0.0.0</strong> when sharing (e.g. <strong>192.168.x.x</strong>).';
            } else {
                lanNote.textContent = 'Open this URL on devices connected to the same network.';
            }
        }

        async function copyLanLink() {
            const text = location.href;
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const temp = document.createElement('textarea');
                    temp.value = text;
                    temp.style.position = 'fixed';
                    temp.style.left = '-9999px';
                    document.body.appendChild(temp);
                    temp.focus();
                    temp.select();
                    document.execCommand('copy');
                    document.body.removeChild(temp);
                }
                copyLinkBtn.textContent = 'Copied';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 900);
            } catch {
                copyLinkBtn.textContent = 'Copy failed';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 1200);
            }
        }

        // Event listeners
        uploadBtn.addEventListener('click', () => fileInput.click());
        cameraBtn.addEventListener('click', () => cameraInput.click());
        resetBtn.addEventListener('click', resetGame);

        copyLinkBtn.addEventListener('click', copyLanLink);

        feedbackBtn.addEventListener('click', openFeedbackModal);
        feedbackCancelBtn.addEventListener('click', closeFeedbackModal);
        feedbackModal.addEventListener('click', (e) => {
            if (e.target === feedbackModal) closeFeedbackModal();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please select a valid image file.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('File is too large. Please select an image under 10MB.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try a different file.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read file. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        cameraInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please capture a valid image.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('Image is too large. Please try again.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try again.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read image. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        feedbackForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const message = (feedbackMessage.value || '').trim();
            const deviceType = feedbackDeviceType.value || 'unknown';

            if (!message) {
                setFeedbackStatus('Please enter a message.', 'error');
                return;
            }

            feedbackSubmitBtn.disabled = true;
            setFeedbackStatus('Sending‚Ä¶', null);

            try {
                let token = localStorage.getItem(FEEDBACK_TOKEN_STORAGE_KEY) || '';
                let response = await postFeedback(message, deviceType, token);

                if (response.status === 401) {
                    const enteredToken = window.prompt('This server requires an access code. Enter it to send feedback:');
                    if (enteredToken) {
                        localStorage.setItem(FEEDBACK_TOKEN_STORAGE_KEY, enteredToken);
                        token = enteredToken;
                        response = await postFeedback(message, deviceType, token);
                    }
                }

                if (!response.ok) {
                    const text = await response.text();
                    setFeedbackStatus(`Failed to send feedback (${response.status}). ${text ? 'Details: ' + text : ''}`.trim(), 'error');
                    return;
                }

                feedbackMessage.value = '';
                setFeedbackStatus('Sent. Thank you!', 'success');

                setTimeout(() => {
                    closeFeedbackModal();
                }, 700);
            } catch (err) {
                setFeedbackStatus('Failed to send feedback. Is the local server running?', 'error');
            } finally {
                feedbackSubmitBtn.disabled = false;
            }
        });

        updateLanHint();

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (shouldIgnoreGameKeyEvent(e)) return;
            
            // Manual respawn with 'R' key
            if ((e.key === 'r' || e.key === 'R') && player && gameRunning) {
                player.respawn();
                e.preventDefault();
                return;
            }
            
            keys[e.key] = true;
            // Prevent default for arrow keys and space
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (shouldIgnoreGameKeyEvent(e)) return;
            keys[e.key] = false;
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
            
            // Jump on tap
            touchJumping = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // Horizontal movement based on touch position
            const deltaX = touchX - touchStartX;
            
            if (deltaX < -20) {
                keys['ArrowLeft'] = true;
                keys['ArrowRight'] = false;
            } else if (deltaX > 20) {
                keys['ArrowRight'] = true;
                keys['ArrowLeft'] = false;
            } else {
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && feedbackModal.classList.contains('open')) {
                closeFeedbackModal();
            }
        });
    </script>
</body>
</html>
