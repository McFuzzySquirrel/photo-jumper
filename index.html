<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#764ba2">
    <meta name="description" content="Turn your photos into playable platformer levels! Upload a photo and jump through your own pictures.">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Photo Jumper">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .lan-hint {
            margin-top: -6px;
            margin-bottom: 18px;
            background: #f7f7ff;
            border: 1px solid #e3e3ff;
            border-radius: 12px;
            padding: 12px;
            display: none;
        }

        .lan-hint.open {
            display: block;
        }

        .lan-hint .row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .lan-hint .label {
            font-weight: bold;
            color: #333;
        }

        .lan-hint code {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px 10px;
            display: inline-block;
            max-width: 100%;
            overflow-wrap: anywhere;
        }

        .lan-hint .note {
            margin-top: 8px;
            color: #666;
            font-size: 13px;
        }

        .lan-hint .note strong {
            color: #333;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #fileInput, #cameraInput {
            display: none;
        }

        .game-canvas-container {
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 3px solid #333;
            border-radius: 10px;
            max-width: 100%;
            background: #1a1a2e;
            display: none;
        }

        .instructions {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .instructions p {
            margin-bottom: 8px;
            color: #666;
        }

        .game-info {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: none;
        }

        .preview-canvas {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 1000;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 520px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        }

        .modal-content h3 {
            margin-bottom: 8px;
            color: #333;
        }

        .modal-content .hint {
            margin-bottom: 14px;
            color: #666;
            font-size: 14px;
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            text-align: left;
        }

        .form-row label {
            font-weight: bold;
            color: #333;
        }

        .form-row select,
        .form-row textarea {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 10px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-row textarea {
            resize: vertical;
            min-height: 110px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .status {
            margin-top: 10px;
            min-height: 18px;
            color: #333;
            font-size: 14px;
        }

        .status.error {
            color: #b00020;
        }

        .status.success {
            color: #0b6b0b;
        }

        /* Mobile control buttons */
        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 25px;  /* Increased from 15px for better spacing */
            margin-top: 15px;
            user-select: none;
        }

        .mobile-controls.visible {
            display: flex;
        }

        .control-btn {
            width: 55px;  /* Reduced from 70px */
            height: 55px;  /* Reduced from 70px */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 15px;
            color: white;
            font-size: 20px;  /* Reduced from 24px */
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            touch-action: none;
            transition: transform 0.1s, box-shadow 0.1s, opacity 0.1s;
            opacity: 0.5;
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            opacity: 1.0;
        }

        .control-btn.jump-btn {
            width: 70px;  /* Reduced from 90px */
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        /* Zoom control buttons */
        .zoom-controls {
            display: none;
            position: fixed;
            bottom: 90px;  /* Above mobile controls */
            right: 20px;
            flex-direction: row;  /* Horizontal layout */
            gap: 10px;
            z-index: 102;
        }

        .game-canvas-container.fullscreen ~ .zoom-controls {
            display: flex;
        }

        .zoom-btn {
            width: 50px;
            height: 50px;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #FFD700;
            transform: scale(1.1);
        }

        .zoom-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* Game action buttons (R/G) in zoom group */
        .zoom-btn.zoom-btn-action {
            background: rgba(102, 126, 234, 0.9);
            border-color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
        }

        .zoom-btn.zoom-btn-action:hover {
            background: rgba(102, 126, 234, 1.0);
            border-color: #FFD700;
        }

        /* Visual separator between game action buttons and zoom buttons */
        /* Note: Vertical bar (1px wide √ó 30px tall) for horizontal button layout */
        .zoom-btn-separator {
            width: 1px;
            height: 30px;
            background: rgba(255, 255, 255, 0.3);
            align-self: center;
        }

        /* Game logo styles */
        .game-logo {
            max-width: 200px;
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            margin-bottom: 16px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        /* Splash screen styles */
        .splash-screen {
            text-align: center;
            padding: 60px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
        }

        .splash-screen.hidden {
            display: none;
        }

        .splash-screen .game-logo {
            max-width: 280px;
            margin-bottom: 30px;
            animation: splashPulse 2s ease-in-out infinite;
        }

        .splash-screen .splash-title {
            font-size: 2.8em;
            color: #333;
            margin-bottom: 12px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .splash-screen .splash-subtitle {
            font-size: 1.1em;
            color: #888;
            margin-bottom: 40px;
        }

        .splash-screen .splash-btn {
            font-size: 1.4em;
            padding: 18px 48px;
            border-radius: 50px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 8px 30px rgba(240, 147, 251, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .splash-screen .splash-btn:hover {
            transform: translateY(-3px) scale(1.03);
            box-shadow: 0 12px 40px rgba(240, 147, 251, 0.5);
        }

        @keyframes splashPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        /* Intro screen styles */
        .intro-screen {
            text-align: center;
            padding: 40px 20px;
        }

        .intro-screen.hidden {
            display: none;
        }

        .intro-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .intro-screen .tagline {
            font-size: 1.3em;
            color: #555;
            margin-bottom: 30px;
        }

        .intro-screen .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
            text-align: left;
        }

        .intro-screen .feature {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .intro-screen .feature h3 {
            margin-bottom: 8px;
            color: #667eea;
        }

        .intro-screen .feature p {
            color: #666;
            margin: 0;
        }

        .intro-screen .cta-button {
            font-size: 1.2em;
            padding: 16px 32px;
            margin-top: 20px;
        }

        /* Game screen styles */
        .game-screen {
            display: none;
        }

        .game-screen.active {
            display: block;
        }

        /* Fullscreen styles */
        .game-canvas-container.fullscreen {
            position: fixed;
            inset: 0;
            z-index: 100;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        /* Frosted-glass background behind the game canvas */
        .game-canvas-container.fullscreen::before {
            content: '';
            position: absolute;
            inset: -20px;
            background: url('images/photo-jumper-sq.png') center / cover no-repeat;
            filter: blur(20px) brightness(0.3);
            z-index: 0;
            pointer-events: none; /* Prevent invisible layer from blocking interactions */
        }

        .game-canvas-container.fullscreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            position: relative;
            z-index: 1;
        }

        /* Hide non-essential elements when canvas is fullscreen */
        .game-canvas-container.fullscreen ~ .instructions {
            display: none;
        }

        .game-screen:has(.game-canvas-container.fullscreen) .upload-section {
            display: none;
        }

        .game-screen:has(.game-canvas-container.fullscreen) h1 {
            display: none;
        }

        /* Word bar - positioned in letterbox area above canvas */
        .word-bar {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 101;
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid #FFD700;
            font-family: Arial, sans-serif;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .word-label {
            color: #FFF;
            font-weight: bold;
            font-size: 13px;
        }

        .word-letters {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .word-letter {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }

        .word-letter.collected {
            background: #FFD700;
            color: #000;
        }

        .word-letter.uncollected {
            background: #555;
            color: #AAA;
        }

        .word-progress {
            color: #FFD700;
            font-size: 12px;
            font-weight: bold;
        }

        /* Detection mode indicator badge */
        .detection-mode-badge {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 101;
            background: rgba(0, 0, 0, 0.75);
            color: #FFD700;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            border: 1px solid rgba(255, 215, 0, 0.5);
            display: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .detection-mode-badge.visible {
            display: block;
        }

        .detection-mode-badge.ml-active {
            background: rgba(102, 126, 234, 0.85);
            color: white;
            border-color: rgba(255, 255, 255, 0.6);
        }

        /* Position game info overlay when fullscreen */
        .game-canvas-container.fullscreen ~ .game-info,
        .game-screen:has(.game-canvas-container.fullscreen) .game-info {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Position mobile controls when fullscreen */
        .game-canvas-container.fullscreen ~ .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
        }

        /* Exit fullscreen button */
        .exit-fullscreen-btn {
            position: fixed;
            top: 60px;  /* Moved down to not overlap score */
            right: 10px;
            z-index: 101;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.5);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            display: none;
            cursor: pointer;
        }

        .exit-fullscreen-btn.visible {
            display: block;
        }
        
        .exit-fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #FFD700;
        }


        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
            }

            button {
                padding: 10px 20px;
                font-size: 14px;
            }

            .container {
                padding: 20px;
            }

            .intro-screen h1 {
                font-size: 2em;
            }

            .intro-screen .tagline {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <button class="exit-fullscreen-btn" id="exitFullscreenBtn">‚Üê Exit</button>
    
    <div class="container">
        <!-- Splash Screen -->
        <div class="splash-screen" id="splashScreen">
            <img src="images/photo-jumper-sq.png" alt="Photo Jumper" class="game-logo">
            
            <p class="splash-subtitle">Turn your photos into playable levels</p>
            <button class="splash-btn" id="splashPlayBtn">Let's Jump!</button>
        </div>

        <!-- Intro Screen -->
        <div class="intro-screen hidden" id="introScreen">
            <h1>Photo Jumper</h1>
            <p class="tagline">Turn your photos into playable platformer levels!</p>
            
            <div class="features">
                <div class="feature">
                    <h3>üì∏ Upload or Capture</h3>
                    <p>Use any photo - the game detects edges and brightness to create platforms</p>
                </div>
                <div class="feature">
                    <h3>üéØ Reach the Goal</h3>
                    <p>Jump from platform to platform to reach the golden portal</p>
                </div>
                <div class="feature">
                    <h3>‚ö° Fast & Fun</h3>
                    <p>Quick platformer action with responsive controls</p>
                </div>
            </div>

            <button class="cta-button" id="startGameBtn">Get Started</button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <h1>Photo Jumper</h1>
            
            <div class="upload-section">
            <div class="button-group">
                <button id="uploadBtn">üìÅ Upload Photo</button>
                <button id="cameraBtn">üì∑ Take Photo</button>
                <button id="resetBtn" style="display: none;">üîÑ New Photo</button>
                <button id="feedbackBtn" type="button">üìù Feedback</button>
            </div>

            <div id="lanHint" class="lan-hint" aria-live="polite">
                <div class="row">
                    <div>
                        <div class="label">Share link</div>
                        <code id="lanUrl"></code>
                    </div>
                    <button id="copyLinkBtn" type="button">Copy</button>
                </div>
                <div id="lanNote" class="note"></div>
            </div>

            <input type="file" id="fileInput" accept="image/*">
            <input type="file" id="cameraInput" accept="image/*" capture="environment">
        </div>

        <div class="game-info" id="gameInfo">
            Score: <span id="score">0</span> | Time: <span id="time">0</span>s
        </div>

        <!-- Word collection bar - positioned above canvas in letterbox area -->
        <div class="word-bar" id="wordBar" style="display: none;">
            <span class="word-label">Word:</span>
            <span class="word-letters" id="wordLetters"></span>
            <span class="word-progress" id="wordProgress"></span>
        </div>

        <!-- Detection mode indicator badge -->
        <div class="detection-mode-badge" id="detectionModeBadge">Grid Only</div>

        <div class="game-canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <canvas id="previewCanvas" class="preview-canvas"></canvas>
        </div>

        <!-- Mobile control buttons -->
        <div class="mobile-controls" id="mobileControls">
            <button class="control-btn" id="leftBtn" aria-label="Move left">‚óÄ</button>
            <button class="control-btn jump-btn" id="jumpBtn" aria-label="Jump">‚ñ≤</button>
            <button class="control-btn" id="rightBtn" aria-label="Move right">‚ñ∂</button>
        </div>

        <!-- Zoom & game action control buttons -->
        <div class="zoom-controls" id="zoomControls">
            <button class="zoom-btn zoom-btn-action" id="regenBtn" aria-label="Regenerate level" title="Regenerate level (G)">G</button>
            <button class="zoom-btn zoom-btn-action" id="respawnBtn" aria-label="Respawn" title="Respawn (R)">R</button>
            <div class="zoom-btn-separator"></div>
            <button class="zoom-btn" id="zoomOutBtn" aria-label="Zoom out" title="Zoom out (-)">‚àí</button>
            <button class="zoom-btn" id="zoomResetBtn" aria-label="Reset zoom" title="Reset zoom (0)">‚äô</button>
            <button class="zoom-btn" id="zoomInBtn" aria-label="Zoom in" title="Zoom in (+)">+</button>
        </div>

        <div class="instructions">
            <h3>How to Play:</h3>
            <p>1. Upload a photo or take one with your camera</p>
            <p>2. The photo will be converted into block platforms</p>
            <p>3. Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move (or touch controls on mobile)</p>
            <p>4. Press <strong>Space</strong>, <strong>Up</strong>, or <strong>W</strong> to jump</p>
            <p>5. Collect golden letters to spell words for bonus points</p>
            <p>6. Walk into the glowing <strong>golden portal</strong> to win!</p>
            <p>7. Press <strong>R</strong> to respawn, <strong>G</strong> to regenerate level</p>
            <p><label><input type="checkbox" id="debugOverlayToggle"> Debug overlay (shows platform grid)</label></p>
            <p>
                <label><input type="checkbox" id="mlDetectionToggle" aria-describedby="mlStatusDesc"> ML object detection (experimental)</label>
                <span id="mlStatus" style="font-size: 12px; color: #666;"></span>
                <span id="mlStatusDesc" class="visually-hidden" style="position: absolute; left: -10000px;">When enabled, uses machine learning to detect objects in your photo and create platforms from them. May increase loading time.</span>
            </p>
            <p style="font-size: 11px; color: #888; margin-top: 5px; margin-left: 20px;">
                üí° <strong>Tip:</strong> Use <strong>Grid only</strong> for landscapes/buildings. Use <strong>ML detection</strong> for furniture, vehicles, and objects.
            </p>
            <p style="font-size: 12px; color: #666; margin-top: 15px;">
                üîí <strong>Privacy:</strong> All photos are processed entirely in your browser. No images are uploaded, stored, or transmitted to any server.
            </p>
        </div>
        </div>
        <!-- End Game Screen -->

        <div id="feedbackModal" class="modal" aria-hidden="true">
            <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="feedbackTitle">
                <h3 id="feedbackTitle">Send Feedback</h3>
                <p class="hint">Text-only feedback is saved locally on the host machine.</p>

                <form id="feedbackForm">
                    <div class="form-row">
                        <label for="feedbackDeviceType">Device type</label>
                        <select id="feedbackDeviceType" required>
                            <option value="unknown">Unknown</option>
                            <option value="desktop">Desktop / Laptop</option>
                            <option value="tablet">Tablet</option>
                            <option value="mobile">Mobile</option>
                        </select>
                    </div>

                    <div class="form-row">
                        <label for="feedbackMessage">Message</label>
                        <textarea id="feedbackMessage" maxlength="2000" placeholder="What worked well? What was confusing or buggy?" required></textarea>
                    </div>

                    <div class="modal-actions">
                        <button type="button" id="feedbackCancelBtn">Cancel</button>
                        <button type="submit" id="feedbackSubmitBtn">Send</button>
                    </div>
                    <div id="feedbackStatus" class="status" aria-live="polite"></div>
                </form>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        
        const introScreen = document.getElementById('introScreen');
        const gameScreen = document.getElementById('gameScreen');
        const splashScreen = document.getElementById('splashScreen');
        const splashPlayBtn = document.getElementById('splashPlayBtn');
        const startGameBtn = document.getElementById('startGameBtn');
        const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
        const container = document.querySelector('.container');
        const gameCanvasContainer = document.querySelector('.game-canvas-container');
        
        const uploadBtn = document.getElementById('uploadBtn');
        const cameraBtn = document.getElementById('cameraBtn');
        const resetBtn = document.getElementById('resetBtn');
        const feedbackBtn = document.getElementById('feedbackBtn');
        const fileInput = document.getElementById('fileInput');
        const cameraInput = document.getElementById('cameraInput');
        const gameInfo = document.getElementById('gameInfo');
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');
        
        // Word bar elements
        const wordBar = document.getElementById('wordBar');
        const wordLetters = document.getElementById('wordLetters');
        const wordProgress = document.getElementById('wordProgress');
        const detectionModeBadge = document.getElementById('detectionModeBadge');

        const feedbackModal = document.getElementById('feedbackModal');
        const feedbackForm = document.getElementById('feedbackForm');
        const feedbackDeviceType = document.getElementById('feedbackDeviceType');
        const feedbackMessage = document.getElementById('feedbackMessage');
        const feedbackCancelBtn = document.getElementById('feedbackCancelBtn');
        const feedbackSubmitBtn = document.getElementById('feedbackSubmitBtn');
        const feedbackStatus = document.getElementById('feedbackStatus');

        const lanHint = document.getElementById('lanHint');
        const lanUrl = document.getElementById('lanUrl');
        const lanNote = document.getElementById('lanNote');
        const copyLinkBtn = document.getElementById('copyLinkBtn');

        const debugOverlayToggle = document.getElementById('debugOverlayToggle');

        // Mobile control buttons
        const mobileControls = document.getElementById('mobileControls');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');

        // Zoom control buttons
        const zoomControls = document.getElementById('zoomControls');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const respawnBtn = document.getElementById('respawnBtn');
        const regenBtn = document.getElementById('regenBtn');

        const FEEDBACK_TOKEN_STORAGE_KEY = 'photoJumperFeedbackToken';

        // Game configuration constants
        const PLAYER_SIZE = 20;  // Matches BLOCK_SIZE exactly
        const PLAYER_SPEED = 3;  // Reduced from 4 for more precise positioning in tight gaps
        const PLAYER_JUMP_POWER = 14;  // Increased from 12 - allows jumping up one additional block
        const PLAYER_GRAVITY = 0.5;
        const JUMP_CUT_DAMPING = 0.5;  // Multiplier for velocity on early jump release (0-1, lower = shorter hop)

        const GRID_SIZE = 20;  // Reduced from 30 to detect more platforms (1x player size)
        const BRIGHTNESS_THRESHOLD = 50;  // Lowered to only detect very dark objects (not shadows)
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
        const EDGE_DETECTION_THRESHOLD = 70;  // Increased to reduce sensitivity to shadow edges
        const EDGE_BRIGHTNESS_THRESHOLD = 80;  // Lowered to be very selective about edge-based platforms

        // Modular block platform system
        const BLOCK_SIZE = 20;  // Individual block size (matches GRID_SIZE and PLAYER_SIZE)
        const PLATFORM_MIN_WIDTH = 40;  // Must fit at least 2 blocks
        const PLATFORM_THICKNESS = BLOCK_SIZE;  // One block tall
        const PLATFORM_MERGE_GAP_PX = 0;
        const MAX_PLATFORM_WIDTH_BLOCKS = 12;  // Max width before inserting jump-through gap (scales with world)
        const PLATFORM_GAP_WIDTH_BLOCKS = 2;   // Gap width in blocks (40px at base ‚Äî fits 20px player)
        const HELPERS_MAX_COUNT = 50;  // Increased from 30 - more helpers for complex photos

        const DEBUG_DEFAULT_ENABLED = false;
        
        // Player spawn and reserved area constants
        const PLAYER_SPAWN_X = 40;
        const PLAYER_SPAWN_Y_OFFSET = 100; // Pixels above canvas bottom
        const START_AREA_WIDTH = 140;  // Wider to ensure clear start area
        const START_AREA_HEIGHT = 100;  // Taller to ensure clear start area
        const GOAL_AREA_WIDTH = 100;
        const GOAL_AREA_HEIGHT = 80;
        const WORD_BAR_AREA_HEIGHT = 30;  // Reduced from 60 to not overlap with score display
        
        // Stuck detection constants
        const STUCK_CHECK_INTERVAL = 15000;  // 15 seconds - increased from 5 for more patience
        const STUCK_MOVEMENT_THRESHOLD = 5;  // pixels

        // Letter collection constants
        const COLLECTIBLE_LETTER_SIZE = 20;
        const COLLECTIBLE_LETTER_POINTS = 10;  // Points per letter
        const COLLECTIBLE_LETTER_FLOAT_SPEED = 0.1;  // Animation speed for floating effect
        const COLLECTIBLE_LETTER_OFFSET_RATIO = 0.4;  // Ratio of platform width for random offset
        const COLLECTIBLE_LETTER_MAX_OFFSET = 30;  // Maximum horizontal offset in pixels
        const COLLECTIBLE_LETTER_VERTICAL_OFFSET = 10;  // Pixels above platform
        const COLLECTIBLE_LETTER_FONT_SIZE_RATIO = 0.8;  // Font size as ratio of letter width
        const WORD_COMPLETE_BONUS = 50;  // Bonus for collecting all letters
        const CORRECT_ORDER_BONUS = 100;  // Extra bonus for correct order
        const WORD_DICTIONARY = ['JUMP', 'PLAY', 'GAME', 'PHOTO', 'STAR', 'GOAL', 'WIN', 'FUN'];
        const MAX_GOAL_CANDIDATES = 3;  // Number of top goal platform candidates to randomly select from
        
        // Player scaling constants
        const BASE_WORLD_WIDTH = 800;  // Reference world width for player scaling
        const BASE_PLAYER_SIZE = 20;   // Reference player size at base world width
        const MIN_PLAYER_SIZE = 16;    // Minimum player size regardless of world size
        const PLAYER_EYE_SIZE_RATIO = 0.2;      // Eye size as ratio of player width
        const PLAYER_EYE_Y_RATIO = 0.25;        // Eye Y position as ratio of player height
        const PLAYER_LEFT_EYE_X_RATIO = 0.2;    // Left eye X position as ratio of player width
        const PLAYER_RIGHT_EYE_X_RATIO = 0.6;   // Right eye X position as ratio of player width
        const PLAYER_PUPIL_SIZE_RATIO = 0.5;    // Pupil size as ratio of eye size
        
        // Camera and viewport constants
        let camera = {
            x: 0,
            y: 0,
            zoom: 0.5,
            minZoom: 0.5,
            maxZoom: 2.0,
            smoothing: 0.1,  // Camera follow smoothing (0-1, lower = smoother)
            targetX: 0,
            targetY: 0,
            autoFitZoom: 0.5  // Computed in updateZoomLimits() to fit the world in the viewport
        };
        
        // Pre-computed shortest word for fallback (safe with non-empty dictionary)
        const SHORTEST_WORD = WORD_DICTIONARY.length > 0 
            ? WORD_DICTIONARY.reduce((shortest, word) => word.length < shortest.length ? word : shortest)
            : 'FUN';  // Fallback if dictionary is somehow empty

        let gameRunning = false;
        let platforms = [];
        let player = null;
        
        // World dimensions (actual photo size in game world coordinates)
        let worldWidth = 800;
        let worldHeight = 600;
        let goal = null;  // Goal object for animation tracking
        let goalPlatform = null;  // The platform that acts as the goal
        let playerSpawnY = 0;  // Calculated spawn Y position
        let keys = {};
        let score = 0;
        let startTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchJumping = false;
        let backgroundImage = null; // Store the uploaded photo for background
        let gameWon = false;  // Track if player reached the goal

        // Letter collection game state
        let letters = [];  // Array of Letter objects
        let collectedLetters = [];  // Array of collected letters in order
        let targetWord = '';  // The word to spell
        let wordCompleteBonus = 0;  // Bonus earned for completing word
        let correctOrderBonus = 0;  // Bonus earned for correct order

        let debugOverlayEnabled = DEBUG_DEFAULT_ENABLED;
        let debugSolidGrid = null;
        let debugGridSize = GRID_SIZE;
        let debugHelperPlatforms = [];

        // ONNX ML detection configuration
        const ML_DETECTION_ENABLED_DEFAULT = false;
        // Model URLs: Try CDN first for deployments, local as fallback
        // For local development: place yolov8n.onnx in 'models/' folder
        // For production: CDN is preferred (smaller deployment, no large files in repo)
        const ML_MODEL_URLS = [
            'https://cdn.jsdelivr.net/gh/aspect-technology/yolov8-onnx@main/models/yolov8n.onnx',  // CDN (preferred for production)
            'models/yolov8n.onnx',  // Local fallback (for development/offline)
        ];
        // ONNX Runtime URLs: CDN first for deployments, local fallback
        // For local development: download ort.min.js and ort-wasm*.wasm files to 'lib/' folder
        // From: https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/
        const ONNX_RUNTIME_URLS = [
            'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js',  // CDN (preferred for production)
            'lib/ort.min.js',  // Local fallback (for development/offline)
        ];
        const ML_CONFIDENCE_THRESHOLD = 0.3;  // Lowered from 0.5 to detect more objects
        const ML_INPUT_SIZE = 640;  // YOLOv8n expects 640x640 input images
        const ML_INFERENCE_TIMEOUT_MS = 5000;
        const ML_MIN_DETECTION_SIZE = 10;  // Minimum bounding box size in pixels to consider
        const ML_PLATFORM_MERGE_TOLERANCE = 20;  // Extra horizontal gap tolerance when merging ML platforms
        const ML_PLATFORM_OVERLAP_TOLERANCE_Y = 30;  // Vertical overlap tolerance when combining ML and grid platforms (increased for better coverage)
        
        // COCO classes that are suitable for platforms (horizontal surfaces)
        const PLATFORMABLE_CLASSES = [
            // Furniture - obvious platforms
            'bench', 'chair', 'couch', 'bed', 'dining table', 'desk', 'toilet',
            
            // Electronics - flat top surfaces
            'tv', 'laptop', 'keyboard', 'book', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator',
            
            // Vehicles - can stand on top
            'car', 'bus', 'truck', 'boat', 'train', 'airplane', 'bicycle', 'motorcycle',
            
            // Large objects - stable platforms
            'suitcase', 'backpack', 'skateboard', 'surfboard', 
            
            // Sports equipment - flat surfaces
            'snowboard', 'skis',
            
            // Containers - can stand on
            'vase', 'potted plant', 'bowl',
            
            // Animals - because why not! ü¶íüêòüê¥
            'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe',
            
            // People - jump on heads!
            'person',
            
            // Other - potential platforms
            'clock', 'teddy bear', 'remote', 'mouse', 'cell phone'
        ];
        
        // COCO class names (80 classes)
        const COCO_CLASSES = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
            'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
            'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
            'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
            'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
            'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
            'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
            'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];

        // ONNX state
        let mlDetectionEnabled = ML_DETECTION_ENABLED_DEFAULT;
        let onnxSession = null;
        let onnxModelLoading = false;
        let onnxModelLoaded = false;
        let onnxLoadError = null;
        let debugDetectedObjects = [];

        // Calculate scaled block size - all visual elements scale with world dimensions
        // This ensures consistent visual scale across different photo sizes
        function getScaledBlockSize() {
            return (worldWidth / BASE_WORLD_WIDTH) * BLOCK_SIZE;
        }

        // Calculate player size - should always match scaled block size for consistent scale with platforms
        function getScaledPlayerSize() {
            return getScaledBlockSize();  // Scales with world to match platform block size
        }

        // Calculate player speed scaled to world dimensions
        // Speed must scale proportionally so movement feels consistent across world sizes
        function getScaledPlayerSpeed() {
            return (worldWidth / BASE_WORLD_WIDTH) * PLAYER_SPEED;
        }

        // Calculate player jump power scaled to world dimensions
        // Jump power must scale proportionally so jumping feels consistent across world sizes
        function getScaledPlayerJumpPower() {
            return (worldWidth / BASE_WORLD_WIDTH) * PLAYER_JUMP_POWER;
        }

        // Calculate player gravity scaled to world dimensions
        // Gravity must scale proportionally to match jump physics
        function getScaledPlayerGravity() {
            return (worldWidth / BASE_WORLD_WIDTH) * PLAYER_GRAVITY;
        }

        // Calculate scaled letter size - scales with world for visibility
        function getScaledLetterSize() {
            return (worldWidth / BASE_WORLD_WIDTH) * COLLECTIBLE_LETTER_SIZE;
        }

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                // Use scaled player size based on world dimensions
                const playerSize = getScaledPlayerSize();
                this.width = playerSize;
                this.height = playerSize;
                this.velocityX = 0;
                this.velocityY = 0;
                // Scale speed, jump power, and gravity to match world size
                this.speed = getScaledPlayerSpeed();
                this.jumpPower = getScaledPlayerJumpPower();
                this.gravity = getScaledPlayerGravity();
                this.onGround = false;
                this.jumpCutAllowed = false;  // Variable jump: true while rising and cut is possible
                this.lastPositionTime = Date.now();
                this.lastX = x;
                this.lastY = y;
                this.stuckCheckInterval = STUCK_CHECK_INTERVAL;
            }

            update() {
                // Horizontal movement
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    this.velocityX = -this.speed;
                    this.lastPositionTime = Date.now(); // Reset stuck timer on input
                } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    this.velocityX = this.speed;
                    this.lastPositionTime = Date.now(); // Reset stuck timer on input
                } else {
                    this.velocityX *= 0.7; // Reduced friction for more responsive feel
                }

                // Jumping - variable height: hold for full jump, tap for short hop
                if ((keys['ArrowUp'] || keys['w'] || keys['W'] || keys[' '] || touchJumping) && this.onGround) {
                    this.velocityY = -this.jumpPower;
                    this.onGround = false;
                    this.jumpCutAllowed = true;  // Enable jump cut until apex or key release
                    touchJumping = false; // Reset touch jump
                    this.lastPositionTime = Date.now(); // Reset stuck timer on input
                }

                // Clear jump cut when player starts falling (reached apex)
                if (this.velocityY >= 0) {
                    this.jumpCutAllowed = false;
                }

                // Apply gravity
                this.velocityY += this.gravity;

                // Update horizontal position
                this.x += this.velocityX;

                // Check horizontal platform collisions
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Push out from sides
                        if (this.x + this.width / 2 < platform.x + platform.width / 2) {
                            this.x = platform.x - this.width;
                        } else {
                            this.x = platform.x + platform.width;
                        }
                        this.velocityX = 0;
                    }
                }

                // Update vertical position
                this.y += this.velocityY;

                // Check vertical platform collisions
                this.onGround = false;
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Landing on top of platform
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                        // Hitting platform from below
                        else if (this.velocityY < 0 && this.y - this.velocityY >= platform.y + platform.height) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                    }
                }

                // Boundary checks
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > worldWidth) this.x = worldWidth - this.width;

                // Check if player fell off
                if (this.y > worldHeight) {
                    this.respawn();
                }

                // Stuck detection: if player hasn't moved significantly in a while
                const now = Date.now();
                const distMoved = Math.sqrt((this.x - this.lastX) ** 2 + (this.y - this.lastY) ** 2);
                
                if (now - this.lastPositionTime > this.stuckCheckInterval) {
                    if (distMoved < STUCK_MOVEMENT_THRESHOLD && this.onGround) {
                        // Player appears stuck, auto-respawn
                        this.respawn();
                        // Reset tracking variables after respawn to prevent immediate re-triggering
                        this.lastX = this.x;
                        this.lastY = this.y;
                        this.lastPositionTime = Date.now();
                    } else {
                        // Update last known position when not stuck
                        this.lastX = this.x;
                        this.lastY = this.y;
                        this.lastPositionTime = now;
                    }
                }

                // Update score based on progress and time efficiency
                // Score = platforms reached * 100 - time penalty
                const heightProgress = Math.max(0, Math.floor((worldHeight - this.y) / 10));
                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                const timePenalty = Math.floor(elapsedSeconds / 2); // -1 point every 2 seconds
                const currentScore = Math.max(0, heightProgress * 2 - timePenalty);
                
                if (currentScore > score) {
                    score = currentScore;
                    scoreElement.textContent = score;
                }
            }

            checkCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            respawn() {
                this.x = PLAYER_SPAWN_X;
                this.y = playerSpawnY;  // Use the calculated spawn Y position
                this.velocityX = 0;
                this.velocityY = 0;
                score = Math.max(0, score - 10);
                scoreElement.textContent = score;
            }

            draw() {
                // Draw shadow/outline for better visibility on photo
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x + 2, this.y + 2, this.width, this.height);
                
                // Draw main body
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw border for visibility
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Draw eyes (scaled proportionally to player size using constants)
                const eyeSize = Math.max(2, Math.floor(this.width * PLAYER_EYE_SIZE_RATIO));
                const eyeY = this.y + Math.floor(this.height * PLAYER_EYE_Y_RATIO);
                const leftEyeX = this.x + Math.floor(this.width * PLAYER_LEFT_EYE_X_RATIO);
                const rightEyeX = this.x + Math.floor(this.width * PLAYER_RIGHT_EYE_X_RATIO);
                
                ctx.fillStyle = 'white';
                ctx.fillRect(leftEyeX, eyeY, eyeSize, eyeSize);
                ctx.fillRect(rightEyeX, eyeY, eyeSize, eyeSize);
                
                const pupilSize = Math.max(1, Math.floor(eyeSize * PLAYER_PUPIL_SIZE_RATIO));
                const pupilOffset = Math.floor((eyeSize - pupilSize) / 2);
                ctx.fillStyle = 'black';
                ctx.fillRect(leftEyeX + pupilOffset, eyeY + pupilOffset, pupilSize, pupilSize);
                ctx.fillRect(rightEyeX + pupilOffset, eyeY + pupilOffset, pupilSize, pupilSize);
            }
        }

        // Goal class - represents the end goal for the level
        class Goal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const blockSize = getScaledBlockSize();
                this.width = blockSize;   // Portal is one block wide
                this.height = blockSize * 2;  // Portal is 2 blocks tall
                this.animation = 0;
            }

            update() {
                this.animation += 0.05;
            }

            checkCollision(player) {
                // Check if player overlaps with the portal
                return player.x < this.x + this.width &&
                       player.x + player.width > this.x &&
                       player.y < this.y + this.height &&
                       player.y + player.height > this.y;
            }

            draw() {
                // Draw portal as shimmering gateway
                ctx.save();
                
                const glowIntensity = 0.7 + Math.sin(this.animation * 2) * 0.3;
                
                // Outer glow
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 20 * glowIntensity;
                
                // Portal gradient (vertical)
                const gradient = ctx.createLinearGradient(
                    this.x, this.y,
                    this.x, this.y + this.height
                );
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 165, 0, 0.3)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Portal frame/border
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Sparkle particles
                ctx.shadowBlur = 0;
                for (let i = 0; i < 3; i++) {
                    const sparkleY = this.y + (Math.sin(this.animation * 3 + i * 2) + 1) * this.height / 2;
                    ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity})`;
                    ctx.fillRect(this.x + this.width / 2 - 1, sparkleY, 2, 2);
                }
                
                ctx.restore();
            }
        }

        // Platform class
        class Platform {
            constructor(x, y, width, height, color, kind = 'photo') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.kind = kind;
            }

            draw() {
                // Special glow effect for goal platform
                if (this.kind === 'goal' && goal) {
                    const glowIntensity = 0.7 + Math.sin(goal.animation * 2) * 0.3;
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 15 * glowIntensity;
                }
                
                // Draw platforms as a series of connected square blocks
                const blockSize = getScaledBlockSize();
                const numBlocks = Math.floor(this.width / blockSize);
                
                // Draw individual blocks
                for (let i = 0; i < numBlocks; i++) {
                    const blockX = this.x + (i * blockSize);
                    const blockY = this.y;
                    
                    // Main block fill (square blocks)
                    ctx.fillStyle = this.color;
                    ctx.fillRect(blockX, blockY, blockSize, blockSize);
                    
                    // Block outline
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(blockX, blockY, blockSize, blockSize);
                    
                    // Top highlight for each block
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(blockX + 1, blockY + 1);
                    ctx.lineTo(blockX + blockSize - 1, blockY + 1);
                    ctx.stroke();
                }
                
                // Handle remaining width (partial block at end)
                const remainingWidth = this.width - (numBlocks * blockSize);
                if (remainingWidth > 0) {
                    const blockX = this.x + (numBlocks * blockSize);
                    const blockY = this.y;
                    
                    ctx.fillStyle = this.color;
                    ctx.fillRect(blockX, blockY, remainingWidth, blockSize);
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(blockX, blockY, remainingWidth, blockSize);
                }
                
                // Reset shadow
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }

        // Letter class for collectible letters
        class Letter {
            constructor(char, x, y, index) {
                this.char = char;
                this.x = x;
                this.y = y;
                const letterSize = getScaledLetterSize();
                this.width = letterSize;
                this.height = letterSize;
                this.collected = false;
                this.index = index;  // Position in the target word
                this.animation = 0;
            }

            update() {
                // Increment animation for floating effect
                this.animation += COLLECTIBLE_LETTER_FLOAT_SPEED;
            }

            checkCollision(player) {
                return !this.collected &&
                       player.x < this.x + this.width &&
                       player.x + player.width > this.x &&
                       player.y < this.y + this.height &&
                       player.y + player.height > this.y;
            }

            draw() {
                if (this.collected) return;

                // Floating animation
                const floatOffset = Math.sin(this.animation) * 3;
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2 + floatOffset;

                // Draw circular background with glow
                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width / 2, 0, Math.PI * 2);
                ctx.fill();

                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Draw black outline
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width / 2, 0, Math.PI * 2);
                ctx.stroke();

                // Draw the letter (scale font size with letter size)
                ctx.fillStyle = '#000';
                const fontSize = Math.max(12, Math.floor(this.width * COLLECTIBLE_LETTER_FONT_SIZE_RATIO));
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.char, centerX, centerY);
            }
        }

        // ==========================================
        // ONNX ML Detection Functions
        // ==========================================

        // Lazy-load ONNX Runtime with fallback URLs
        async function loadONNXRuntime() {
            if (typeof ort !== 'undefined') {
                // Already loaded, just ensure WASM path is set
                if (!ort.env.wasm.wasmPaths) {
                    ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/';
                }
                return true;
            }
            
            for (const runtimeUrl of ONNX_RUNTIME_URLS) {
                try {
                    console.log('Attempting to load ONNX Runtime from:', runtimeUrl);
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = runtimeUrl;
                        script.onload = () => resolve(true);
                        script.onerror = () => reject(new Error(`Failed to load from ${runtimeUrl}`));
                        document.head.appendChild(script);
                    });
                    
                    // Wait a bit for ort to become available (async initialization)
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Verify ort is available after script loads
                    if (typeof ort !== 'undefined') {
                        console.log('ONNX Runtime loaded successfully from:', runtimeUrl);
                        
                        // Configure WASM paths - point to the same location as the runtime
                        if (runtimeUrl.includes('://')) {
                            // CDN - point to CDN for WASM files
                            const cdnBase = runtimeUrl.substring(0, runtimeUrl.lastIndexOf('/') + 1);
                            ort.env.wasm.wasmPaths = cdnBase;
                            console.log('ONNX WASM path set to CDN:', ort.env.wasm.wasmPaths);
                        } else {
                            // Local - point to local lib folder
                            ort.env.wasm.wasmPaths = 'lib/';
                            console.log('ONNX WASM path set to local:', ort.env.wasm.wasmPaths);
                        }
                        
                        // Set number of threads for better performance
                        ort.env.wasm.numThreads = 1;
                        
                        return true;
                    }
                } catch (err) {
                    console.error('Failed to load ONNX Runtime from:', runtimeUrl);
                    console.error('Error details:', err);
                    // Continue to next URL
                }
            }
            
            throw new Error('Failed to load ONNX Runtime from all sources');
        }

        // Initialize ONNX model (lazy load with fallback URLs)
        async function initONNXModel() {
            if (onnxSession) return true;
            if (onnxModelLoading) return false;
            if (onnxLoadError) return false;
            
            onnxModelLoading = true;
            updateMLStatus('Loading runtime...');
            
            try {
                // Load ONNX runtime first
                await loadONNXRuntime();
                updateMLStatus('Loading model...');
                
                // Try each model URL until one works
                let lastError = null;
                for (const modelUrl of ML_MODEL_URLS) {
                    try {
                        updateMLStatus(`Trying ${modelUrl.includes('://') ? 'CDN' : 'local'} model...`);
                        console.log('Attempting to load model from:', modelUrl);
                        
                        onnxSession = await ort.InferenceSession.create(modelUrl, {
                            executionProviders: ['wasm'],
                            graphOptimizationLevel: 'all'
                        });
                        
                        onnxModelLoaded = true;
                        onnxModelLoading = false;
                        updateMLStatus('ML ready');
                        console.log('ONNX model loaded successfully from:', modelUrl);
                        return true;
                    } catch (urlError) {
                        console.error(`Failed to load model from ${modelUrl}:`, urlError);
                        console.error('Error stack:', urlError.stack);
                        lastError = urlError;
                        // Continue to try next URL
                    }
                }
                
                // All URLs failed
                throw lastError || new Error('All model URLs failed');
            } catch (err) {
                onnxLoadError = err;
                onnxModelLoading = false;
                onnxModelLoaded = false;
                updateMLStatus('ML failed - see console');
                console.error('Failed to load ML detection:', err);
                console.info('=== ML Detection Troubleshooting ===');
                console.info('The app is running via HTTPS/web server (good!)');
                console.info('ML assets are loading from CDN (no downloads needed).');
                console.info('');
                console.info('Possible issues:');
                console.info('1. CDN temporarily unavailable - try refreshing');
                console.info('2. Network/firewall blocking CDN - check connection');
                console.info('3. Browser compatibility - try Chrome/Edge');
                console.info('');
                console.info('CDN URLs tried:');
                console.info('- Runtime: https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/');
                console.info('- Model: https://cdn.jsdelivr.net/gh/aspect-technology/yolov8-onnx@main/');
                console.info('');
                console.info('See docs/ONNX_SETUP.md for full troubleshooting guide.');
                return false;
            }
        }

        // Update ML status indicator
        function updateMLStatus(text) {
            const mlStatusEl = document.getElementById('mlStatus');
            if (mlStatusEl) {
                mlStatusEl.textContent = text ? ` (${text})` : '';
            }
        }

        // Update detection mode badge to show current detection method
        function updateDetectionModeBadge() {
            if (!detectionModeBadge) return;
            
            if (mlDetectionEnabled && onnxModelLoaded) {
                detectionModeBadge.textContent = 'ü§ñ Grid + ML';
                detectionModeBadge.classList.add('ml-active');
            } else {
                detectionModeBadge.textContent = 'üìê Grid Only';
                detectionModeBadge.classList.remove('ml-active');
            }
        }

        // Preprocess image for YOLO model input
        function preprocessImageForYOLO(imageData, width, height) {
            // Create a temporary canvas to resize image to ML_INPUT_SIZE x ML_INPUT_SIZE
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = ML_INPUT_SIZE;
            tempCanvas.height = ML_INPUT_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw with letterboxing to maintain aspect ratio
            const scale = Math.min(ML_INPUT_SIZE / width, ML_INPUT_SIZE / height);
            const scaledWidth = Math.floor(width * scale);
            const scaledHeight = Math.floor(height * scale);
            const offsetX = Math.floor((ML_INPUT_SIZE - scaledWidth) / 2);
            const offsetY = Math.floor((ML_INPUT_SIZE - scaledHeight) / 2);
            
            // Fill with gray (letterbox padding)
            tempCtx.fillStyle = '#808080';
            tempCtx.fillRect(0, 0, ML_INPUT_SIZE, ML_INPUT_SIZE);
            
            // Draw the resized image centered
            tempCtx.drawImage(previewCanvas, 0, 0, width, height, offsetX, offsetY, scaledWidth, scaledHeight);
            
            // Get pixel data
            const resizedData = tempCtx.getImageData(0, 0, ML_INPUT_SIZE, ML_INPUT_SIZE).data;
            
            // Convert to normalized float32 tensor [1, 3, 640, 640] (NCHW format)
            const inputSize = ML_INPUT_SIZE * ML_INPUT_SIZE;
            const float32Data = new Float32Array(3 * inputSize);
            
            for (let i = 0; i < inputSize; i++) {
                const pixelIndex = i * 4;
                // Normalize to [0, 1]
                float32Data[i] = resizedData[pixelIndex] / 255.0;                    // R channel
                float32Data[i + inputSize] = resizedData[pixelIndex + 1] / 255.0;   // G channel
                float32Data[i + 2 * inputSize] = resizedData[pixelIndex + 2] / 255.0; // B channel
            }
            
            return {
                tensor: new ort.Tensor('float32', float32Data, [1, 3, ML_INPUT_SIZE, ML_INPUT_SIZE]),
                scale,
                offsetX,
                offsetY
            };
        }

        // Run YOLO inference and extract bounding boxes
        async function detectObjectsWithONNX(width, height) {
            if (!onnxSession) return [];
            
            try {
                const startTime = performance.now();
                
                // Preprocess image
                const { tensor, scale, offsetX, offsetY } = preprocessImageForYOLO(null, width, height);
                
                // Run inference with timeout (clean up timeout when inference completes)
                let timeoutId;
                const timeoutPromise = new Promise((_, reject) => {
                    timeoutId = setTimeout(() => reject(new Error('Inference timeout')), ML_INFERENCE_TIMEOUT_MS);
                });
                
                try {
                    const results = await Promise.race([
                        onnxSession.run({ images: tensor }),
                        timeoutPromise
                    ]);
                    clearTimeout(timeoutId);
                    
                    const inferenceTime = performance.now() - startTime;
                    console.log(`ONNX inference completed in ${inferenceTime.toFixed(0)}ms`);
                    
                    // Process YOLO output - different models use different output names
                    const output = results.predictions || results.output0 || results[Object.keys(results)[0]];
                    
                    if (!output) {
                        console.error('No valid output found. Available keys:', Object.keys(results));
                        return [];
                    }
                    
                    console.log('Using output tensor with dims:', output.dims);
                    
                    const detections = processYOLOOutput(output, width, height, scale, offsetX, offsetY);
                    
                    return detections;
                } catch (inferErr) {
                    clearTimeout(timeoutId);
                    throw inferErr;
                }
            } catch (err) {
                console.warn('ONNX inference failed:', err);
                return [];
            }
        }

        // Process YOLO v8 output format [1, 84, 8400] -> bounding boxes
        function processYOLOOutput(output, originalWidth, originalHeight, scale, offsetX, offsetY) {
            if (!output) {
                console.error('Output is undefined');
                return [];
            }
            
            // ONNX Runtime Web returns tensors, need to get data from cpuData or data
            const data = output.cpuData || output.data;
            
            if (!data) {
                console.error('Output data is undefined. Output:', output);
                console.error('Available properties:', Object.keys(output));
                return [];
            }
            
            const dims = output.dims;
            if (!dims || dims.length !== 3) {
                console.error('Invalid output dimensions:', dims);
                return [];
            }
            
            const [batch, features, numBoxes] = dims; // Expected: [1, 84, 8400]
            console.log(`Processing YOLO output: ${batch}x${features}x${numBoxes}`);
            
            const detections = [];
            
            // YOLOv8 output format: first 4 values are [cx, cy, w, h], remaining 80 are class probabilities
            for (let i = 0; i < numBoxes; i++) {
                // Extract box coordinates (cx, cy, w, h)
                const cx = data[i];
                const cy = data[numBoxes + i];
                const w = data[2 * numBoxes + i];
                const h = data[3 * numBoxes + i];
                
                // Find the class with highest probability
                let maxProb = 0;
                let maxClass = 0;
                for (let c = 0; c < 80; c++) {
                    const prob = data[(4 + c) * numBoxes + i];
                    if (prob > maxProb) {
                        maxProb = prob;
                        maxClass = c;
                    }
                }
                
                // Filter by confidence threshold
                if (maxProb < ML_CONFIDENCE_THRESHOLD) continue;
                
                // Convert from letterboxed coordinates to original image coordinates
                const x1 = (cx - w / 2 - offsetX) / scale;
                const y1 = (cy - h / 2 - offsetY) / scale;
                const boxW = w / scale;
                const boxH = h / scale;
                
                // Clamp to image bounds
                const clampedX = Math.max(0, Math.min(x1, originalWidth - 1));
                const clampedY = Math.max(0, Math.min(y1, originalHeight - 1));
                const clampedW = Math.min(boxW, originalWidth - clampedX);
                const clampedH = Math.min(boxH, originalHeight - clampedY);
                
                if (clampedW < ML_MIN_DETECTION_SIZE || clampedH < ML_MIN_DETECTION_SIZE) continue;
                
                const className = COCO_CLASSES[maxClass] || 'unknown';
                
                detections.push({
                    class: className,
                    classId: maxClass,
                    confidence: maxProb,
                    bbox: [clampedX, clampedY, clampedW, clampedH],
                    isPlatformable: PLATFORMABLE_CLASSES.includes(className)
                });
            }
            
            // Apply Non-Maximum Suppression (NMS)
            return applyNMS(detections, 0.45);
        }

        // Non-Maximum Suppression to remove overlapping detections
        function applyNMS(detections, iouThreshold) {
            // Sort by confidence (descending)
            detections.sort((a, b) => b.confidence - a.confidence);
            
            const kept = [];
            const suppressed = new Set();
            
            for (let i = 0; i < detections.length; i++) {
                if (suppressed.has(i)) continue;
                
                kept.push(detections[i]);
                
                for (let j = i + 1; j < detections.length; j++) {
                    if (suppressed.has(j)) continue;
                    
                    const iou = calculateIoU(detections[i].bbox, detections[j].bbox);
                    if (iou > iouThreshold) {
                        suppressed.add(j);
                    }
                }
            }
            
            return kept;
        }

        // Calculate Intersection over Union (IoU) between two bounding boxes
        function calculateIoU(box1, box2) {
            const [x1, y1, w1, h1] = box1;
            const [x2, y2, w2, h2] = box2;
            
            const interX1 = Math.max(x1, x2);
            const interY1 = Math.max(y1, y2);
            const interX2 = Math.min(x1 + w1, x2 + w2);
            const interY2 = Math.min(y1 + h1, y2 + h2);
            
            const interW = Math.max(0, interX2 - interX1);
            const interH = Math.max(0, interY2 - interY1);
            const interArea = interW * interH;
            
            const area1 = w1 * h1;
            const area2 = w2 * h2;
            const unionArea = area1 + area2 - interArea;
            
            return unionArea > 0 ? interArea / unionArea : 0;
        }

        // Map detected objects to platform surfaces (bottom-edge for standing)
        function mapObjectsToPlatforms(detections, canvasWidth, canvasHeight) {
            const platformCandidates = [];
            
            for (const detection of detections) {
                const [x, y, w, h] = detection.bbox;
                
                // Use BOTTOM edge as platform surface - this is where the player stands on the object
                // y = top of bounding box, y + h = bottom of bounding box (where platform should be)
                const platformY = y + h;  // Bottom edge of detected object
                const platformX = x;
                
                // Align width to block boundaries (use scaled block size)
                const blockSize = getScaledBlockSize();
                const blockCount = Math.max(2, Math.ceil(w / blockSize));  // At least 2 blocks
                const platformWidth = blockCount * blockSize;
                const platformHeight = blockSize;  // One block tall
                
                // Skip if platform would be in reserved areas
                const isStartArea = (platformX < START_AREA_WIDTH && platformY > canvasHeight - START_AREA_HEIGHT);
                const isGoalArea = (platformX > canvasWidth - GOAL_AREA_WIDTH && platformY < GOAL_AREA_HEIGHT);
                const isWordBarArea = (platformY < WORD_BAR_AREA_HEIGHT);
                if (isStartArea || isGoalArea || isWordBarArea) continue;
                
                // Skip if platform is too small
                if (platformWidth < PLATFORM_MIN_WIDTH) continue;
                
                // Skip if platform is outside canvas bounds
                if (platformY < 0 || platformY > canvasHeight - platformHeight) continue;
                if (platformX + platformWidth > canvasWidth) continue;
                
                // Semi-transparent platforms that show the photo underneath
                let color;
                if (detection.isPlatformable) {
                    color = 'rgba(60, 150, 80, 0.85)';
                } else {
                    color = 'rgba(80, 100, 160, 0.85)';
                }
                
                platformCandidates.push({
                    x: platformX,
                    y: platformY,
                    width: platformWidth,
                    height: platformHeight,
                    color: color,
                    source: 'ml-detection',
                    detection: detection
                });
            }
            
            // Merge nearby platforms to reduce clutter
            return mergePlatformCandidates(platformCandidates);
        }

        // Merge platform candidates that are on similar Y levels and close horizontally
        function mergePlatformCandidates(candidates) {
            if (candidates.length === 0) return [];
            
            // Sort by Y then X
            candidates.sort((a, b) => a.y - b.y || a.x - b.x);
            
            const merged = [];
            let current = { ...candidates[0] };
            
            for (let i = 1; i < candidates.length; i++) {
                const next = candidates[i];
                
                // Merge if on same Y level (within tolerance) and horizontally adjacent/overlapping
                const sameRow = Math.abs(next.y - current.y) < PLATFORM_THICKNESS;
                const adjacent = next.x <= current.x + current.width + PLATFORM_MERGE_GAP_PX + ML_PLATFORM_MERGE_TOLERANCE;
                
                if (sameRow && adjacent) {
                    // Extend current platform
                    const newRight = Math.max(current.x + current.width, next.x + next.width);
                    current.width = newRight - current.x;
                } else {
                    merged.push(current);
                    current = { ...next };
                }
            }
            merged.push(current);
            
            return merged;
        }

        // ==========================================
        // End ONNX ML Detection Functions
        // ==========================================

        // Helper functions for reachability checking
        function intervalGap(a1, a2, b1, b2) {
            if (a2 < b1) return b1 - a2;
            if (b2 < a1) return a1 - b2;
            return 0;
        }

        function getJumpLimits() {
            const jumpPower = getScaledPlayerJumpPower();
            const gravity = getScaledPlayerGravity();
            const speed = getScaledPlayerSpeed();

            const maxJumpUp = (jumpPower * jumpPower) / (2 * gravity);
            const maxHangTime = (2 * jumpPower) / gravity;
            const maxJumpDx = speed * maxHangTime;

            // Conservative safety margins (gameplay-first): if we say reachable, it should
            // be comfortably reachable ‚Äî not a frame-perfect jump.
            // 0.85 vertical / 0.80 horizontal ensures helpers get inserted for borderline gaps.
            return {
                maxJumpUp: maxJumpUp * 0.85,  // 15% margin below theoretical max
                maxJumpDx: maxJumpDx * 0.80,  // 20% margin below theoretical max
                jumpPower,
                gravity,
                speed
            };
        }

        function canReachPlatform(from, to, limits, allPlatforms) {
            if (from === to) return false;

            const fromLeft = from.x;
            const fromRight = from.x + from.width;
            const toLeft = to.x;
            const toRight = to.x + to.width;

            const dx = intervalGap(fromLeft, fromRight, toLeft, toRight);
            if (dx > limits.maxJumpDx) return false;

            const up = from.y - to.y;
            if (up <= 0) {
                // Dropping down is allowed; keep conservative horizontal requirement only.
                return true;
            }

            if (up > limits.maxJumpUp) return false;

            // More accurate horizontal limit for higher targets: time to reach that height (descending).
            const disc = (limits.jumpPower * limits.jumpPower) - (2 * limits.gravity * up);
            if (disc < 0) return false;
            const tLanding = (limits.jumpPower + Math.sqrt(disc)) / limits.gravity;
            const dxLimit = Math.min(limits.maxJumpDx, limits.speed * tLanding * 0.9);
            if (dx > dxLimit) return false;

            // Ceiling check: when jumping UP, verify no solid platform blocks the
            // vertical path between 'from' and 'to'. A ceiling is any platform whose
            // bottom edge sits between the two Y levels AND horizontally overlaps the
            // jump lane (the narrower of from/to horizontal extents).
            if (allPlatforms && up > 0) {
                // The horizontal lane the player must pass through
                const laneLeft = Math.max(fromLeft, toLeft);
                const laneRight = Math.min(fromRight, toRight);
                // Only check when platforms horizontally overlap (vertical jump)
                if (laneLeft < laneRight) {
                    const topY = to.y + to.height;  // bottom edge of destination
                    const botY = from.y;              // top edge of source
                    for (const p of allPlatforms) {
                        if (p === from || p === to || p.kind === 'wall') continue;
                        // Platform sits between the two Y levels?
                        if (p.y + p.height > topY && p.y < botY) {
                            // Horizontally blocks the lane entirely?
                            if (p.x <= laneLeft && p.x + p.width >= laneRight) {
                                return false;  // Ceiling blocks upward jump
                            }
                        }
                    }
                }
            }

            return true;
        }

        /**
         * Check if a platform has an unbroken ceiling directly above it within
         * jump height. Used by letter placement to avoid putting collectibles
         * in spots the player can't reach even though BFS says the platform
         * itself is reachable.
         */
        function hasCeilingAbove(platform, allPlatforms, jumpHeight) {
            const aboveY = platform.y - jumpHeight;
            for (const p of allPlatforms) {
                if (p === platform || p.kind === 'wall') continue;
                // Platform is above and within jump height?
                if (p.y + p.height > aboveY && p.y + p.height <= platform.y) {
                    // Completely covers this platform horizontally?
                    if (p.x <= platform.x && p.x + p.width >= platform.x + platform.width) {
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Split platforms that exceed MAX_PLATFORM_WIDTH_BLOCKS into smaller
         * segments with player-width gaps so the player can always jump through.
         * Max width scales proportionally with world size via getScaledBlockSize().
         * Skips ground, start, and goal platforms.
         */
        function splitLongPlatforms(platformList) {
            const blockSize = getScaledBlockSize();
            const maxWidth = MAX_PLATFORM_WIDTH_BLOCKS * blockSize;
            const gapWidth = PLATFORM_GAP_WIDTH_BLOCKS * blockSize;
            const minSegWidth = PLATFORM_MIN_WIDTH;  // Minimum 2-block segment
            const result = [];

            for (const p of platformList) {
                // Never split special platforms
                if (p.kind === 'ground' || p.kind === 'start' || p.kind === 'goal') {
                    result.push(p);
                    continue;
                }

                if (p.width <= maxWidth) {
                    result.push(p);
                    continue;
                }

                // Calculate how many segments we need
                // Each segment is at most maxWidth, separated by gapWidth
                const totalContentWidth = p.width;
                // Number of gaps needed: enough so each segment <= maxWidth
                const numGaps = Math.floor(totalContentWidth / maxWidth);
                const numSegments = numGaps + 1;
                // Distribute width evenly across segments
                const totalGapWidth = numGaps * gapWidth;
                const segmentWidth = Math.floor((totalContentWidth - totalGapWidth) / numSegments);

                if (segmentWidth < minSegWidth) {
                    // Platform too narrow to split meaningfully ‚Äî keep as-is
                    result.push(p);
                    continue;
                }

                // Build segments with gaps
                let x = p.x;
                for (let i = 0; i < numSegments; i++) {
                    // Last segment gets remaining width to avoid rounding drift
                    const isLast = (i === numSegments - 1);
                    const w = isLast
                        ? Math.max(minSegWidth, (p.x + p.width) - x)  // remainder
                        : segmentWidth;
                    // Align to block grid
                    const alignedW = Math.floor(w / blockSize) * blockSize;
                    const finalW = Math.max(minSegWidth, alignedW);

                    result.push(new Platform(x, p.y, finalW, p.height, p.color, p.kind));
                    x += finalW + gapWidth;

                    // Safety: don't exceed original platform bounds
                    if (x >= p.x + p.width) break;
                }

                console.log(`Split ${Math.round(p.width)}px platform into ${numSegments} segments at y=${Math.round(p.y)}`);
            }

            return result;
        }

        function isReachable(startPlatform, goalPlatform, allPlatforms, limits) {
            // Filter out wall blocks ‚Äî they are solid collision obstacles, not traversal nodes
            const traversable = allPlatforms.filter(p => p.kind !== 'wall');
            const visited = new Set();
            const queue = [startPlatform];
            visited.add(startPlatform);

            while (queue.length) {
                const current = queue.shift();
                if (current === goalPlatform) return true;

                for (const next of traversable) {
                    if (visited.has(next)) continue;
                    if (!canReachPlatform(current, next, limits, traversable)) continue;
                    visited.add(next);
                    queue.push(next);
                }
            }

            return false;
        }

        function overlapsAny(candidate, allPlatforms) {
            for (const p of allPlatforms) {
                const overlaps = !(candidate.x + candidate.width <= p.x ||
                    candidate.x >= p.x + p.width ||
                    candidate.y + candidate.height <= p.y ||
                    candidate.y >= p.y + p.height);
                if (overlaps) return true;
            }
            return false;
        }

        // Process image and create platforms
        async function processImage(image) {
            console.log('processImage called with image:', image.width, 'x', image.height);
            
            // Update detection mode badge to show current mode
            updateDetectionModeBadge();
            
            // Store the image for background rendering
            backgroundImage = image;

            // Store the original image dimensions as the world size
            // This allows the photo to be rendered at full resolution in game world
            worldWidth = image.width;
            worldHeight = image.height;

            // For platform detection, we'll use the actual image size
            // (We'll limit processing size for performance, but world coords use full size)
            const maxProcessWidth = 1600;  // Increased from 800 to preserve more detail
            const maxProcessHeight = 1200; // Increased from 600 to preserve more detail
            let processWidth = image.width;
            let processHeight = image.height;

            // Scale down only if image is very large (for performance)
            if (processWidth > maxProcessWidth) {
                processHeight = (processHeight * maxProcessWidth) / processWidth;
                processWidth = maxProcessWidth;
            }
            if (processHeight > maxProcessHeight) {
                processWidth = (processWidth * maxProcessHeight) / processHeight;
                processHeight = maxProcessHeight;
            }

            // Set preview canvas to processing size for platform detection
            previewCanvas.width = processWidth;
            previewCanvas.height = processHeight;

            // Draw image to preview canvas for platform detection
            previewCtx.drawImage(image, 0, 0, processWidth, processHeight);
            const imageData = previewCtx.getImageData(0, 0, processWidth, processHeight);
            const data = imageData.data;
            
            // For convenience in nested functions, create width/height aliases
            const width = processWidth;
            const height = processHeight;

            // Create platforms based on brightness and edge detection
            platforms = [];
            const gridSize = GRID_SIZE;
            const brightnessThreshold = BRIGHTNESS_THRESHOLD;

            debugGridSize = gridSize;
            debugHelperPlatforms = [];
            debugSolidGrid = null;
            debugDetectedObjects = [];

            // Helper function to detect edges (helps identify objects better)
            function hasEdge(x, y, width, height, data) {
                // Allow edge detection near boundaries, just need 1-pixel neighbors
                if (x === 0 || y === 0 || x + 1 >= width || y + 1 >= height) {
                    return false;
                }
                
                // Get center brightness
                const centerI = (y * width + x) * 4;
                const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;
                
                // Check brightness difference with adjacent neighbors (1 pixel away)
                let maxDiff = 0;
                const checkPositions = [
                    [x - 1, y], [x + 1, y],
                    [x, y - 1], [x, y + 1]
                ];
                
                for (const [px, py] of checkPositions) {
                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const i = (py * width + px) * 4;
                        const neighborBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const diff = Math.abs(centerBrightness - neighborBrightness);
                        maxDiff = Math.max(maxDiff, diff);
                    }
                }
                // Significant brightness difference indicates an edge
                return maxDiff > EDGE_DETECTION_THRESHOLD;
            }

            function buildSolidGrid() {
                const cellsX = Math.ceil(width / gridSize);
                const cellsY = Math.ceil(height / gridSize);
                const solid = Array.from({ length: cellsY }, () => Array.from({ length: cellsX }, () => false));
                const brightness = Array.from({ length: cellsY }, () => Array.from({ length: cellsX }, () => 255));

                for (let cy = 0; cy < cellsY; cy++) {
                    for (let cx = 0; cx < cellsX; cx++) {
                        const x = cx * gridSize;
                        const y = cy * gridSize;

                        let totalBrightness = 0;
                        let pixelCount = 0;

                        // Calculate average brightness of grid cell
                        for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4;
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                const bness = (r + g + b) / 3;
                                totalBrightness += bness;
                                pixelCount++;
                            }
                        }

                        const avgBrightness = pixelCount > 0 ? (totalBrightness / pixelCount) : 255;
                        brightness[cy][cx] = avgBrightness;

                        // Create solid hint if brightness is below threshold OR at edges (better object detection)
                        const isEdge = hasEdge(x, y, width, height, data);

                        // Reserve start area (bottom-left), goal area (top-right), and word bar area (top) - don't generate photo platforms there
                        const isStartArea = (x < START_AREA_WIDTH && y > height - START_AREA_HEIGHT);
                        const isGoalArea = (x > width - GOAL_AREA_WIDTH && y < GOAL_AREA_HEIGHT);
                        const isWordBarArea = (y < WORD_BAR_AREA_HEIGHT);

                        const isSolidHint = (!isStartArea && !isGoalArea && !isWordBarArea) &&
                            (avgBrightness < brightnessThreshold || (isEdge && avgBrightness < EDGE_BRIGHTNESS_THRESHOLD));

                        solid[cy][cx] = Boolean(isSolidHint);
                    }
                }

                return { solid, brightness, cellsX, cellsY };
            }

            function platformColorFromBrightness(avgBrightness) {
                // Solid semi-opaque blocks for clear gameplay experience
                const alpha = 0.85;
                const colorValue = Math.floor(avgBrightness * 0.6);
                return `rgba(${colorValue}, ${colorValue}, ${colorValue}, ${alpha})`;
            }

            function extractTopSurfacesFromGrid(grid) {
                const { solid, brightness, cellsX, cellsY } = grid;
                const segments = [];

                // Extract top surfaces only - keep air space clear for navigation
                for (let cy = 0; cy < cellsY; cy++) {
                    for (let cx = 0; cx < cellsX; cx++) {
                        if (!solid[cy][cx]) continue;
                        const aboveSolid = (cy > 0) ? solid[cy - 1][cx] : false;
                        if (aboveSolid) continue;

                        const x = cx * gridSize;
                        const y = cy * gridSize;
                        const w = Math.min(gridSize, width - x);
                        if (w <= 0) continue;

                        segments.push({
                            x,
                            y,
                            width: w,
                            brightness: brightness[cy][cx]
                        });
                    }
                }

                // Merge adjacent segments on the same y into longer platforms
                const merged = [];
                let current = null;

                for (const seg of segments) {
                    if (!current) {
                        current = { ...seg };
                        continue;
                    }

                    const touchesSameRow = seg.y === current.y;
                    const isAdjacent = seg.x <= (current.x + current.width + PLATFORM_MERGE_GAP_PX);

                    if (touchesSameRow && isAdjacent) {
                        const end = Math.max(current.x + current.width, seg.x + seg.width);
                        const totalWidth = end - current.x;
                        const weightedBrightness = ((current.brightness * current.width) + (seg.brightness * seg.width)) / (current.width + seg.width);
                        current.width = totalWidth;
                        current.brightness = weightedBrightness;
                    } else {
                        merged.push(current);
                        current = { ...seg };
                    }
                }
                if (current) merged.push(current);

                // Convert to platform objects with block-aligned dimensions
                const blockSize = getScaledBlockSize();
                const platformsOut = [];
                for (const m of merged) {
                    if (m.width < PLATFORM_MIN_WIDTH) continue;
                    
                    // Align platform width to block boundaries for clean appearance
                    const blockCount = Math.ceil(m.width / blockSize);
                    const alignedWidth = blockCount * blockSize;
                    
                    const platformHeight = blockSize;  // One block tall
                    const color = platformColorFromBrightness(m.brightness);
                    const mainPlatform = new Platform(m.x, m.y, Math.min(alignedWidth, width - m.x), platformHeight, color, 'photo');
                    platformsOut.push(mainPlatform);
                    // Wall blocks are added post-BFS by addWallBlocks() for smart placement
                }

                // Filter out platforms that are too close vertically (minimum 1 block spacing)
                return filterVerticallyClashingPlatforms(platformsOut);
            }
            
            // Remove platforms that are stacked too closely vertically
            function filterVerticallyClashingPlatforms(platforms) {
                // Minimum gap should allow player to pass comfortably
                // Player is 20px tall, so we need at least that much clearance
                // Reduced from 35px to 25px to allow tighter but still playable platforming
                const minVerticalGap = PLAYER_SIZE + 5;  // 25px - fits 20px player with small margin
                const filtered = [];
                
                // Sort by Y position
                const sorted = [...platforms].sort((a, b) => a.y - b.y);
                
                for (let i = 0; i < sorted.length; i++) {
                    const current = sorted[i];
                    let tooClose = false;
                    
                    // Check if there's a platform directly below that's too close
                    for (let j = i + 1; j < sorted.length; j++) {
                        const below = sorted[j];
                        
                        // Check if they overlap horizontally
                        const horizontalOverlap = !(current.x + current.width <= below.x || below.x + below.width <= current.x);
                        
                        if (horizontalOverlap) {
                            const verticalGap = below.y - (current.y + current.height);
                            
                            if (verticalGap > 0 && verticalGap < minVerticalGap) {
                                tooClose = true;
                                console.log(`Filtering platform at y=${current.y} - too close to platform at y=${below.y} (gap=${verticalGap}px < ${minVerticalGap}px)`);
                                break;
                            }
                            // Once we find the first platform below with overlap, we can stop checking
                            break;
                        }
                    }
                    
                    if (!tooClose) {
                        filtered.push(current);
                    }
                }
                
                return filtered;
            }

            // Smart wall block placement (post-BFS): only place wall blocks on
            // platform edges that don't face a reachable neighbor. This keeps walls
            // as solid climbing assists (ADR 0009) without blocking jump paths.
            function addWallBlocks(allPlatforms, limits) {
                const blockSize = getScaledBlockSize();
                // Only consider non-wall traversable platforms for wall placement
                const mainPlatforms = allPlatforms.filter(p => p.kind !== 'wall');
                const newWalls = [];

                for (const platform of mainPlatforms) {
                    // Only add walls on platforms wide enough (>= 3 blocks)
                    if (platform.width < blockSize * 3) continue;

                    // Check if any reachable neighbor approaches from the left or right
                    let hasLeftNeighbor = false;
                    let hasRightNeighbor = false;

                    for (const other of mainPlatforms) {
                        if (other === platform) continue;
                        // Check both directions: can we reach other FROM platform, or reach platform FROM other
                        const reachable = canReachPlatform(platform, other, limits, mainPlatforms) || canReachPlatform(other, platform, limits, mainPlatforms);
                        if (!reachable) continue;

                        // Determine which side the neighbor is on relative to this platform
                        const otherCenterX = other.x + other.width / 2;
                        const platformCenterX = platform.x + platform.width / 2;

                        if (otherCenterX < platformCenterX) {
                            hasLeftNeighbor = true;
                        }
                        if (otherCenterX > platformCenterX) {
                            hasRightNeighbor = true;
                        }

                        // Early exit if both sides have neighbors
                        if (hasLeftNeighbor && hasRightNeighbor) break;
                    }

                    // Place wall block on left edge only if no neighbor approaches from the left
                    if (!hasLeftNeighbor && platform.x >= blockSize) {
                        newWalls.push(new Platform(
                            platform.x,
                            platform.y - blockSize,
                            blockSize,
                            blockSize,
                            platform.color,
                            'wall'
                        ));
                    }

                    // Place wall block on right edge only if no neighbor approaches from the right
                    if (!hasRightNeighbor && platform.x + platform.width + blockSize <= processWidth) {
                        newWalls.push(new Platform(
                            platform.x + platform.width - blockSize,
                            platform.y - blockSize,
                            blockSize,
                            blockSize,
                            platform.color,
                            'wall'
                        ));
                    }
                }

                // Add all wall blocks to the platform array
                for (const wall of newWalls) {
                    allPlatforms.push(wall);
                }
            }

            function addHelperPlatformsIfNeeded(startPlatform, goalPlatform, allPlatforms, limits) {
                if (isReachable(startPlatform, goalPlatform, allPlatforms, limits)) {
                    return;
                }

                // Use smaller, more flexible helper blocks (scaled with world)
                const blockSize = getScaledBlockSize();
                const helperWidthOptions = [blockSize * 2, blockSize * 3];  // Try smallest first
                const helperHeight = blockSize;
                const helperColor = 'rgba(80, 120, 255, 0.9)';

                let current = startPlatform;
                let added = 0;
                let failedAttempts = 0;
                const maxFailedAttempts = 10;  // Increased tolerance

                while (added < HELPERS_MAX_COUNT && failedAttempts < maxFailedAttempts) {
                    if (isReachable(startPlatform, goalPlatform, allPlatforms, limits)) {
                        console.log(`Goal is reachable after adding ${added} helper platforms`);
                        return;
                    }

                    const currentCenter = current.x + current.width / 2;
                    const goalCenter = goalPlatform.x + goalPlatform.width / 2;

                    const toward = Math.sign(goalCenter - currentCenter) || 1;
                    const stepX = limits.maxJumpDx * 0.5;  // Even smaller horizontal steps - 50% of max
                    const stepUp = limits.maxJumpUp * 0.4;  // Even smaller vertical steps - 40% of max

                    const targetY = Math.max(WORD_BAR_AREA_HEIGHT, current.y - stepUp);
                    
                    // Try different helper widths to find one that fits
                    let placed = false;
                    
                    for (const helperWidth of helperWidthOptions) {
                        if (placed) break;
                        
                        const idealX = currentCenter + toward * stepX - (helperWidth / 2);
                        let targetX = Math.max(0, Math.min(width - helperWidth, idealX));

                        const wouldBeInGoalArea = (targetX > width - GOAL_AREA_WIDTH && targetY < GOAL_AREA_HEIGHT);
                        if (wouldBeInGoalArea) {
                            targetX = Math.max(0, width - GOAL_AREA_WIDTH - helperWidth - 10);
                        }

                        const candidate = new Platform(targetX, targetY, helperWidth, helperHeight, helperColor, 'helper');

                        if (!overlapsAny(candidate, allPlatforms)) {
                            allPlatforms.push(candidate);
                            debugHelperPlatforms.push(candidate);
                            current = candidate;
                            placed = true;
                            failedAttempts = 0;
                            break;
                        }
                        
                        // Try shifting left and right with current width - more aggressive range
                        for (let offset = blockSize; offset <= blockSize * 15; offset += blockSize) {
                            const leftX = Math.max(0, targetX - offset);
                            const rightX = Math.min(width - helperWidth, targetX + offset);

                            const leftCandidate = new Platform(leftX, targetY, helperWidth, helperHeight, helperColor, 'helper');
                            if (!overlapsAny(leftCandidate, allPlatforms)) {
                                allPlatforms.push(leftCandidate);
                                debugHelperPlatforms.push(leftCandidate);
                                current = leftCandidate;
                                placed = true;
                                failedAttempts = 0;
                                break;
                            }

                            const rightCandidate = new Platform(rightX, targetY, helperWidth, helperHeight, helperColor, 'helper');
                            if (!overlapsAny(rightCandidate, allPlatforms)) {
                                allPlatforms.push(rightCandidate);
                                debugHelperPlatforms.push(rightCandidate);
                                current = rightCandidate;
                                placed = true;
                                failedAttempts = 0;
                                break;
                            }
                        }
                    }

                    if (!placed) {
                        // Try stepping horizontally at same height
                        for (let stepMultiplier = 2; stepMultiplier <= 5; stepMultiplier++) {
                            const horizontalHelper = new Platform(
                                currentCenter + toward * (blockSize * stepMultiplier), 
                                current.y, 
                                blockSize * 2, 
                                helperHeight, 
                                helperColor, 
                                'helper'
                            );
                            
                            if (!overlapsAny(horizontalHelper, allPlatforms) && 
                                horizontalHelper.x >= 0 && 
                                horizontalHelper.x + horizontalHelper.width <= width) {
                                allPlatforms.push(horizontalHelper);
                                debugHelperPlatforms.push(horizontalHelper);
                                current = horizontalHelper;
                                placed = true;
                                failedAttempts = 0;
                                break;
                            }
                        }
                    }

                    if (!placed) {
                        // Try going down to create descending path
                        for (let stepMultiplier = 1; stepMultiplier <= 3; stepMultiplier++) {
                            const downHelper = new Platform(
                                currentCenter + toward * stepX - blockSize,
                                Math.min(height - helperHeight - 20, current.y + (stepUp * stepMultiplier)),
                                blockSize * 2,
                                helperHeight,
                                helperColor,
                                'helper'
                            );
                            
                            if (!overlapsAny(downHelper, allPlatforms) &&
                                downHelper.x >= 0 &&
                                downHelper.x + downHelper.width <= width &&
                                downHelper.y >= WORD_BAR_AREA_HEIGHT) {
                                allPlatforms.push(downHelper);
                                debugHelperPlatforms.push(downHelper);
                                current = downHelper;
                                placed = true;
                                failedAttempts = 0;
                                break;
                            }
                        }
                    }

                    if (!placed) {
                        // Last resort: very small steps in multiple directions
                        const closeSteps = [
                            { x: blockSize * 1.5, y: -blockSize * 1.5 },  // diagonal up-forward
                            { x: blockSize * 2, y: -blockSize },          // forward-up
                            { x: blockSize * 1, y: -blockSize * 2 },      // up-forward
                            { x: blockSize * 2, y: 0 },                    // straight forward
                            { x: blockSize * 1.5, y: blockSize },         // forward-down
                        ];
                        
                        for (const step of closeSteps) {
                            const closeHelper = new Platform(
                                currentCenter + (toward * step.x),
                                current.y + step.y,
                                blockSize * 2,
                                helperHeight,
                                helperColor,
                                'helper'
                            );
                            
                            if (!overlapsAny(closeHelper, allPlatforms) &&
                                closeHelper.x >= 0 &&
                                closeHelper.x + closeHelper.width <= width &&
                                closeHelper.y >= WORD_BAR_AREA_HEIGHT &&
                                closeHelper.y + closeHelper.height <= height) {
                                allPlatforms.push(closeHelper);
                                debugHelperPlatforms.push(closeHelper);
                                current = closeHelper;
                                placed = true;
                                failedAttempts = 0;
                                break;
                            }
                        }
                    }

                    if (placed) {
                        added++;
                    } else {
                        failedAttempts++;
                    }
                }
                
                console.log(`Added ${added} helper platforms (failed attempts: ${failedAttempts})`);
                if (!isReachable(startPlatform, goalPlatform, allPlatforms, limits)) {
                    console.warn('‚ö†Ô∏è Warning: Goal may not be reachable even after adding helpers. Try regenerating (G key).');
                }
            }

            // Build grid-based platforms (always run as baseline/fallback)
            const grid = buildSolidGrid();
            debugSolidGrid = grid.solid;
            let gridBasedPlatforms = extractTopSurfacesFromGrid(grid);

            // Try ML-based object detection if enabled
            let mlPlatforms = [];
            if (mlDetectionEnabled && onnxModelLoaded && onnxSession) {
                console.log('ü§ñ Running ML object detection...');
                try {
                    updateMLStatus('Detecting objects...');
                    const detections = await detectObjectsWithONNX(width, height);
                    debugDetectedObjects = detections;
                    
                    console.log(`ML detection found ${detections.length} total objects`);
                    
                    // Log all detections for debugging
                    if (detections.length > 0) {
                        console.log('Detected objects:', detections.map(d => 
                            `${d.class} (${(d.confidence * 100).toFixed(1)}%) ${d.isPlatformable ? '‚úì platformable' : '‚úó not platformable'}`
                        ).join(', '));
                    }
                    
                    
                    // Convert ALL detected objects to platforms for smooth gameplay
                    // This ensures maximum platform coverage and better level traversability
                    if (detections.length > 0) {
                        mlPlatforms = mapObjectsToPlatforms(detections, width, height);
                        
                        // Convert ML platform candidates to Platform objects
                        mlPlatforms = mlPlatforms.map(p => 
                            new Platform(p.x, p.y, p.width, p.height, p.color, 'ml')
                        );
                        
                        // Count platformable detections for status display
                        const platformableCount = detections.filter(d => d.isPlatformable).length;
                        updateMLStatus(`${detections.length} objects ‚Üí platforms (${platformableCount} platformable)`);
                    } else {
                        console.log('‚ÑπÔ∏è No objects detected. Try photos with furniture, vehicles, or electronics.');
                        console.log('   Platformable objects: chairs, tables, couches, cars, laptops, etc.');
                        console.log('   Note: Buildings/architecture are not detected - use grid-based detection for those.');
                        updateMLStatus('No objects detected');
                    }
                } catch (err) {
                    console.warn('ML detection failed during inference:', err);
                    updateMLStatus('Detection failed');
                }
            }

            // Combine platforms: ML platforms take priority, then grid-based fill gaps
            // If ML detection is enabled and found platforms, prioritize those
            if (mlDetectionEnabled && mlPlatforms.length > 0) {
                // Use ML platforms as primary, with grid-based as supplement
                platforms = [...mlPlatforms];
                
                // Add grid-based platforms that don't significantly overlap with ML platforms
                // We want to keep grid platforms that fill gaps, but remove ones that would
                // create confusing stacks or duplicate existing ML platforms
                for (const gridPlatform of gridBasedPlatforms) {
                    let shouldSkip = false;
                    for (const mlPlatform of mlPlatforms) {
                        // Check for horizontal overlap - platforms must actually overlap, not just touch
                        const horizontalOverlap = !(gridPlatform.x + gridPlatform.width < mlPlatform.x ||
                            gridPlatform.x > mlPlatform.x + mlPlatform.width);
                        
                        if (horizontalOverlap) {
                            // Calculate actual vertical gap between platform edges (not just top positions)
                            // This handles platforms of different heights correctly
                            const gridBottom = gridPlatform.y + gridPlatform.height;
                            const mlBottom = mlPlatform.y + mlPlatform.height;
                            
                            // Calculate vertical separation (positive = separated, negative = overlapping)
                            let verticalSeparation;
                            if (gridPlatform.y > mlPlatform.y) {
                                // Grid platform is below ML platform
                                verticalSeparation = gridPlatform.y - mlBottom;
                            } else {
                                // Grid platform is above ML platform
                                verticalSeparation = mlPlatform.y - gridBottom;
                            }
                            
                            // Only skip if platforms are very close or overlapping vertically
                            // (negative or small positive values indicate they're too close)
                            if (verticalSeparation < ML_PLATFORM_OVERLAP_TOLERANCE_Y) {
                                shouldSkip = true;
                                break;
                            }
                        }
                    }
                    if (!shouldSkip) {
                        platforms.push(gridPlatform);
                    }
                }
            } else {
                // Fall back to grid-based only
                platforms = gridBasedPlatforms;
            }

            // Split overly wide platforms so the player can always jump through gaps.
            // Max width scales with world size (MAX_PLATFORM_WIDTH_BLOCKS * blockSize).
            platforms = splitLongPlatforms(platforms);

            // Add a ground platform at the bottom (darker and more opaque)
            platforms.push(new Platform(0, height - 20, width, 20, 'rgba(100, 60, 20, 0.8)', 'ground'));

            // Add starting platform (green to indicate start, scaled with world)
            const blockSize = getScaledBlockSize();
            const startPlatformY = height - 60;
            const startPlatform = new Platform(10, startPlatformY, blockSize * 5, blockSize, 'rgba(0, 180, 0, 0.9)', 'start');
            platforms.push(startPlatform);

            // Randomly select a goal location from suitable platforms
            // Goal should be: reachable, sufficiently far from start, preferably high up
            let goalSupportPlatform = null;
            let goalX, goalY;
            
            // Get candidate platforms for goal placement (photo/ml platforms in upper half)
            const candidateGoalPlatforms = platforms.filter(p => {
                if (p.kind !== 'photo' && p.kind !== 'ml') return false;
                // Prefer upper 60% of the level
                if (p.y > height * 0.6) return false;
                // Must not overlap with start area
                if (p.x < 150 && p.y > height - 150) return false;
                return true;
            });
            
            // If we have suitable candidates, pick one randomly
            if (candidateGoalPlatforms.length > 0) {
                // Sort by height (higher is better) and distance from start
                const startCenter = { x: 60, y: startPlatformY };
                candidateGoalPlatforms.sort((a, b) => {
                    // Calculate distance once for each platform
                    const aDistSq = (a.x - startCenter.x) ** 2 + (a.y - startCenter.y) ** 2;
                    const bDistSq = (b.x - startCenter.x) ** 2 + (b.y - startCenter.y) ** 2;
                    // Prefer high (negative y) + far (positive distance)
                    const aScore = -a.y * 2 + Math.sqrt(aDistSq);
                    const bScore = -b.y * 2 + Math.sqrt(bDistSq);
                    return bScore - aScore;
                });
                
                // Pick from top candidates randomly for variety
                const topCandidates = candidateGoalPlatforms.slice(0, Math.min(MAX_GOAL_CANDIDATES, candidateGoalPlatforms.length));
                const selectedPlatform = topCandidates[Math.floor(Math.random() * topCandidates.length)];
                
                // Create goal support platform (use scaled block size)
                // Ensure platform is low enough that portal above it will be visible
                const minPlatformY = WORD_BAR_AREA_HEIGHT + (blockSize * 2) + 10;  // Room for portal above
                const platformY = Math.max(minPlatformY, selectedPlatform.y - blockSize);
                
                goalPlatform = new Platform(
                    selectedPlatform.x + selectedPlatform.width / 2 - (blockSize * 1.5),
                    platformY,
                    blockSize * 3, 
                    blockSize, 
                    'rgba(255, 200, 0, 0.9)', 
                    'goal'
                );
            } else {
                // Fallback to safe position if no suitable platforms found
                const goalX = width - (blockSize * 4);  // Ensure it's not too close to edge
                const goalY = WORD_BAR_AREA_HEIGHT + (blockSize * 2) + 20;  // Low enough for portal to be above
                goalPlatform = new Platform(goalX, goalY, blockSize * 3, blockSize, 'rgba(255, 200, 0, 0.9)', 'goal');
            }
            
            platforms.push(goalPlatform);
            
            // Create portal on top of goal platform (use scaled block size)
            const portalX = goalPlatform.x + (goalPlatform.width / 2) - (blockSize / 2);  // Center on platform
            const portalY = goalPlatform.y - (blockSize * 2);  // Portal sits on top of platform
            
            goal = new Goal(portalX, portalY);
            
            console.log('Goal platform created:', {
                x: goalPlatform.x,
                y: goalPlatform.y,
                width: goalPlatform.width,
                height: goalPlatform.height,
                kind: goalPlatform.kind
            });
            console.log('Goal portal created:', {
                x: goal.x,
                y: goal.y,
                width: goal.width,
                height: goal.height
            });

            // Initialize player ON the start platform (not above it)
            playerSpawnY = startPlatformY - 20; // Player height is 20, so spawn on top of platform
            player = new Player(PLAYER_SPAWN_X, playerSpawnY);
            
            // Remove any photo-generated platforms that overlap with player spawn area
            // to ensure player never spawns inside a block
            const spawnCheckX = PLAYER_SPAWN_X - 10;
            const spawnCheckY = playerSpawnY - 10;
            const spawnCheckWidth = 40;  // Player width + buffer
            const spawnCheckHeight = 40; // Player height + buffer
            
            platforms = platforms.filter(platform => {
                // Keep non-photo/non-ml platforms (ground/start/goal/helper)
                if (platform.kind !== 'photo' && platform.kind !== 'ml') return true;

                // Remove photo/ml platforms that overlap with spawn area
                const overlaps = !(platform.x + platform.width < spawnCheckX ||
                    platform.x > spawnCheckX + spawnCheckWidth ||
                    platform.y + platform.height < spawnCheckY ||
                    platform.y > spawnCheckY + spawnCheckHeight);
                return !overlaps;
            });

            // Ensure the level is winnable: add helper platforms only when needed.
            const limits = getJumpLimits();
            addHelperPlatformsIfNeeded(startPlatform, goalPlatform, platforms, limits);

            // If goal is still unreachable, try re-selecting from lower candidates
            if (!isReachable(startPlatform, goalPlatform, platforms, limits)) {
                console.warn('Goal unreachable after helpers ‚Äî trying lower candidates...');
                // Find all reachable platforms from start, pick the highest one as new goal
                const reachablePlatforms = platforms.filter(p =>
                    p.kind !== 'wall' && p.kind !== 'goal' && p !== startPlatform &&
                    isReachable(startPlatform, p, platforms, limits)
                );
                if (reachablePlatforms.length > 0) {
                    // Sort by Y ascending (highest first) and pick from top 3
                    reachablePlatforms.sort((a, b) => a.y - b.y);
                    const fallbackCandidates = reachablePlatforms.slice(0, Math.min(3, reachablePlatforms.length));
                    const fallback = fallbackCandidates[Math.floor(Math.random() * fallbackCandidates.length)];
                    
                    // Remove old goal platform and portal
                    platforms = platforms.filter(p => p !== goalPlatform);
                    
                    // Create new goal at the reachable platform
                    const newBlockSize = getScaledBlockSize();
                    const newMinY = WORD_BAR_AREA_HEIGHT + (newBlockSize * 2) + 10;
                    const newGoalY = Math.max(newMinY, fallback.y - newBlockSize);
                    goalPlatform = new Platform(
                        fallback.x + fallback.width / 2 - (newBlockSize * 1.5),
                        newGoalY,
                        newBlockSize * 3,
                        newBlockSize,
                        'rgba(255, 200, 0, 0.9)',
                        'goal'
                    );
                    platforms.push(goalPlatform);
                    
                    // Recreate portal on new goal
                    const newPortalX = goalPlatform.x + (goalPlatform.width / 2) - (newBlockSize / 2);
                    const newPortalY = goalPlatform.y - (newBlockSize * 2);
                    goal = new Goal(newPortalX, newPortalY);
                    
                    console.log('Goal relocated to reachable platform at y=' + fallback.y);
                }
            }

            // Add wall blocks on platform edges that don't face a reachable neighbor.
            // Walls are solid climbing assists (ADR 0009) placed only where they won't
            // block jump paths ‚Äî edges facing a reachable neighbor stay clear.
            addWallBlocks(platforms, limits);

            // Alternative-path pass: sprinkle minimal single-block stepping stones
            // to connect isolated platform clusters. This gives the player more
            // routes through the level without flooding it with helpers.
            (function addAlternativePathHelpers() {
                const blockSize = getScaledBlockSize();
                const helperColor = 'rgba(80, 120, 255, 0.7)';
                const traversable = platforms.filter(p => p.kind !== 'wall');
                
                // Find all platforms reachable from start
                const reachableSet = new Set();
                const queue = [startPlatform];
                reachableSet.add(startPlatform);
                while (queue.length) {
                    const cur = queue.shift();
                    for (const next of traversable) {
                        if (reachableSet.has(next)) continue;
                        if (!canReachPlatform(cur, next, limits, traversable)) continue;
                        reachableSet.add(next);
                        queue.push(next);
                    }
                }
                
                // Collect unreachable photo/ML platforms worth connecting
                const unreachable = traversable.filter(p =>
                    !reachableSet.has(p) &&
                    (p.kind === 'photo' || p.kind === 'ml') &&
                    p.width >= blockSize * 2
                );
                
                if (unreachable.length === 0) return;
                
                let added = 0;
                const maxAltHelpers = 8; // Keep it minimal
                
                for (const target of unreachable) {
                    if (added >= maxAltHelpers) break;
                    
                    // Find the closest reachable platform to this unreachable one
                    let bestFrom = null;
                    let bestDist = Infinity;
                    for (const rp of reachableSet) {
                        const dx = (rp.x + rp.width / 2) - (target.x + target.width / 2);
                        const dy = rp.y - target.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestFrom = rp;
                        }
                    }
                    if (!bestFrom) continue;
                    
                    // Only bridge gaps that are within ~2 jump distances
                    if (bestDist > limits.maxJumpDx * 2.5) continue;
                    
                    // Try placing a single stepping-stone block midway
                    const midX = (bestFrom.x + bestFrom.width / 2 + target.x + target.width / 2) / 2 - blockSize / 2;
                    const midY = Math.min(bestFrom.y, target.y) - limits.maxJumpUp * 0.3;
                    const clampedY = Math.max(WORD_BAR_AREA_HEIGHT, Math.min(midY, height - blockSize * 2));
                    const clampedX = Math.max(0, Math.min(midX, width - blockSize));
                    
                    const stone = new Platform(clampedX, clampedY, blockSize, blockSize, helperColor, 'helper');
                    
                    if (!overlapsAny(stone, platforms)) {
                        // Verify the stone actually helps: reachable from existing set AND can reach target
                        const canGetToStone = [...reachableSet].some(rp => canReachPlatform(rp, stone, limits, platforms));
                        const canGetFromStone = canReachPlatform(stone, target, limits, platforms);
                        
                        if (canGetToStone && canGetFromStone) {
                            platforms.push(stone);
                            debugHelperPlatforms.push(stone);
                            reachableSet.add(stone);
                            reachableSet.add(target);
                            added++;
                            console.log(`Alt-path stone at (${Math.round(clampedX)}, ${Math.round(clampedY)}) connects to platform at y=${Math.round(target.y)}`);
                            continue;
                        }
                    }
                    
                    // Fallback: try a 2-block wide stone at a few Y offsets
                    const offsets = [0, -blockSize, blockSize, -blockSize * 2];
                    let placed = false;
                    for (const yOff of offsets) {
                        const altY = Math.max(WORD_BAR_AREA_HEIGHT, Math.min(clampedY + yOff, height - blockSize * 2));
                        const altStone = new Platform(clampedX, altY, blockSize * 2, blockSize, helperColor, 'helper');
                        
                        if (!overlapsAny(altStone, platforms)) {
                            const canGet = [...reachableSet].some(rp => canReachPlatform(rp, altStone, limits, platforms));
                            const canLeave = canReachPlatform(altStone, target, limits, platforms);
                            
                            if (canGet && canLeave) {
                                platforms.push(altStone);
                                debugHelperPlatforms.push(altStone);
                                reachableSet.add(altStone);
                                reachableSet.add(target);
                                added++;
                                placed = true;
                                console.log(`Alt-path 2-block stone at (${Math.round(clampedX)}, ${Math.round(altY)}) connects to platform at y=${Math.round(target.y)}`);
                                break;
                            }
                        }
                    }
                }
                
                if (added > 0) {
                    console.log(`Added ${added} alternative-path stepping stones`);
                }
            })();

            // Scale all platforms from process coordinates to world coordinates
            const scaleX = worldWidth / processWidth;
            const scaleY = worldHeight / processHeight;
            
            for (let platform of platforms) {
                platform.x *= scaleX;
                platform.y *= scaleY;
                platform.width *= scaleX;
                platform.height *= scaleY;
            }
            
            // Scale goal position
            if (goal) {
                goal.x *= scaleX;
                goal.y *= scaleY;
                goal.width *= scaleX;
                goal.height *= scaleY;
            }

            // Place collectible letters on platforms (pass limits and startPlatform for reachability check)
            placeLettersOnPlatforms(startPlatform, limits);

            // Second helper pass: ensure every letter platform is comfortably reachable.
            // The first pass only ensured start‚Üígoal; letters may be on side branches
            // that are borderline or unreachable with the tighter safety margins.
            for (const letter of letters) {
                // Find the platform this letter sits on
                const letterPlatform = platforms.find(p =>
                    p.kind !== 'wall' && p.kind !== 'ground' &&
                    letter.x + letter.width > p.x &&
                    letter.x < p.x + p.width &&
                    Math.abs((letter.y + letter.height) - p.y) < getScaledBlockSize() * 2
                );
                if (letterPlatform && !isReachable(startPlatform, letterPlatform, platforms, limits)) {
                    console.log(`Adding helpers for letter '${letter.letter}' platform at y=${Math.round(letterPlatform.y)}`);
                    addHelperPlatformsIfNeeded(startPlatform, letterPlatform, platforms, limits);
                }
            }

            // Start game
            startGame();
        }

        // Fisher-Yates shuffle algorithm for unbiased array shuffling
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Place letters on platforms to spell a word
        function placeLettersOnPlatforms(startPlatform, limits) {
            letters = [];
            collectedLetters = [];
            
            // Get platforms that are suitable for letter placement AND reachable from start
            // Exclude ground, start, goal platforms and those with ceilings blocking letter access
            const jumpHeight = limits.maxJumpUp;
            const suitablePlatforms = platforms.filter(p => {
                // Must be a photo/ml/helper platform (NOT goal)
                if (p.kind !== 'photo' && p.kind !== 'ml' && p.kind !== 'helper') {
                    return false;
                }
                
                // Don't place letters on goal platform
                if (p === goalPlatform) {
                    return false;
                }
                
                // Must be reachable from the start platform (including multi-hop paths)
                if (!isReachable(startPlatform, p, platforms, limits)) {
                    return false;
                }
                
                // Skip platforms with an unbroken ceiling directly above ‚Äî
                // letters placed here would be visually accessible but physically
                // unreachable because the player bonks the ceiling.
                if (hasCeilingAbove(p, platforms, jumpHeight)) {
                    return false;
                }
                
                return true;
            });
            
            if (suitablePlatforms.length === 0) {
                console.warn('No suitable reachable platforms for letter placement');
                return;
            }
            
            // Choose a word that fits the available platforms
            // Filter words that have length <= number of suitable platforms
            const availableWords = WORD_DICTIONARY.filter(word => word.length <= suitablePlatforms.length);
            
            if (availableWords.length === 0) {
                // If no words fit (not enough reachable platforms), truncate the shortest word
                // to match the number of available platforms
                const baseWord = SHORTEST_WORD;
                targetWord = baseWord.substring(0, Math.min(baseWord.length, suitablePlatforms.length));
                
                // If still no platforms, exit early
                if (suitablePlatforms.length === 0 || targetWord.length === 0) {
                    console.warn('Not enough reachable platforms for any word');
                    return;
                }
            } else {
                targetWord = availableWords[Math.floor(Math.random() * availableWords.length)];
            }
            
            // Shuffle platforms using Fisher-Yates algorithm
            const shuffledPlatforms = shuffleArray(suitablePlatforms);
            
            // Place each letter of the word on different platforms (one letter per platform)
            for (let i = 0; i < targetWord.length; i++) {
                const platform = shuffledPlatforms[i];  // Direct indexing since word length <= platform count
                
                // Safety check: ensure platform exists
                // This should never happen due to filtering above, but we check defensively
                // to prevent crashes from undefined access
                if (!platform) {
                    console.error(`CRITICAL: Platform ${i} is undefined for letter ${targetWord[i]} - this indicates a bug in platform filtering`);
                    console.error(`Available platforms: ${suitablePlatforms.length}, Word length: ${targetWord.length}`);
                    continue;
                }
                
                // Place letter on top of platform, centered with some randomness
                const letterSize = getScaledLetterSize();
                const platformCenterX = platform.x + platform.width / 2;
                const randomOffsetX = (Math.random() - 0.5) * Math.min(
                    platform.width * COLLECTIBLE_LETTER_OFFSET_RATIO, 
                    COLLECTIBLE_LETTER_MAX_OFFSET
                );
                const letterX = platformCenterX + randomOffsetX - letterSize / 2;
                const letterY = platform.y - letterSize - COLLECTIBLE_LETTER_VERTICAL_OFFSET;
                
                letters.push(new Letter(targetWord[i], letterX, letterY, i));
            }
            
            console.log(`Placed ${letters.length} letters to spell: ${targetWord} on reachable platforms`);
        }

        // Start the game loop
        function startGame() {
            gameRunning = true;
            gameWon = false;  // Reset win state
            canvas.style.display = 'block';
            gameInfo.style.display = 'none';  // Hide old game info (we draw it on canvas now)
            resetBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'none';
            cameraBtn.style.display = 'none';
            
            // Show detection mode badge
            detectionModeBadge.classList.add('visible');
            
            score = 0;
            wordCompleteBonus = 0;
            correctOrderBonus = 0;
            startTime = Date.now();
            
            // Reset camera
            camera.x = 0;
            camera.y = 0;
            camera.targetX = 0;
            camera.targetY = 0;
            
            // Resize canvas to fill the container/viewport (also computes autoFitZoom)
            resizeCanvas();
            
            // Set zoom to auto-fit so the world fills the screen
            camera.zoom = camera.autoFitZoom;
            
            // Enter fullscreen when game starts
            enterFullscreen();
            
            gameLoop();
        }

        // Resize canvas to fill viewport
        function resizeCanvas() {
            const container = document.querySelector('.game-canvas-container');
            const isFullscreen = container.classList.contains('fullscreen');
            
            if (isFullscreen) {
                // Fill entire screen on mobile/fullscreen for maximum gameplay area
                // Note: This intentionally ignores photo aspect ratio to maximize screen usage
                // The game world will scale to fill available space (may appear stretched)
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            }
            
            // Update minimum zoom to ensure entire world can be viewed
            updateZoomLimits();
        }
        
        // Calculate and update zoom limits based on world and canvas size
        function updateZoomLimits() {
            // Calculate zoom levels: fit (entire world visible) and fill (no letterbox)
            const zoomToFitWidth = canvas.width / worldWidth;
            const zoomToFitHeight = canvas.height / worldHeight;
            const minZoomToFitWorld = Math.min(zoomToFitWidth, zoomToFitHeight);
            const fillZoom = Math.max(zoomToFitWidth, zoomToFitHeight);
            
            // minZoom allows zooming out to see the full level
            camera.minZoom = Math.max(0.1, minZoomToFitWorld * 0.95);
            camera.maxZoom = 2.0;
            
            // Default zoom fits the photo in the canvas ‚Äî frosted letterbox shows around edges
            camera.autoFitZoom = Math.max(camera.minZoom, Math.min(minZoomToFitWorld, camera.maxZoom));
        }

        // Update camera to follow player
        function updateCamera() {
            if (!player) return;
            
            // Target camera position (center on player)
            camera.targetX = player.x + player.width / 2 - (canvas.width / camera.zoom) / 2;
            camera.targetY = player.y + player.height / 2 - (canvas.height / camera.zoom) / 2;
            
            // Smooth camera movement
            camera.x += (camera.targetX - camera.x) * camera.smoothing;
            camera.y += (camera.targetY - camera.y) * camera.smoothing;
            
            // Clamp camera to world bounds, centering when viewport exceeds world
            const viewportWidth = canvas.width / camera.zoom;
            const viewportHeight = canvas.height / camera.zoom;
            if (viewportWidth >= worldWidth) {
                // Viewport wider than world ‚Äî center horizontally
                camera.x = -(viewportWidth - worldWidth) / 2;
            } else {
                camera.x = Math.max(0, Math.min(camera.x, worldWidth - viewportWidth));
            }
            if (viewportHeight >= worldHeight) {
                // Viewport taller than world ‚Äî center vertically
                camera.y = -(viewportHeight - worldHeight) / 2;
            } else {
                camera.y = Math.max(0, Math.min(camera.y, worldHeight - viewportHeight));
            }
        }

        // Main game loop
        function gameLoop() {
            if (!gameRunning) return;

            // Update camera position
            updateCamera();

            // Clear canvas with dark letterbox color (area outside the game world)
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Save context state
            ctx.save();
            
            // Apply camera transformation for game world
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            // Fill world bounds with sky-blue background
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, worldWidth, worldHeight);

            // Draw the photo as background in world space (so it zooms with camera)
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, worldWidth, worldHeight);
            }

            // Update and draw goal
            if (goal) {
                goal.update();
                goal.draw();
            }

            // Update and draw platforms
            for (let platform of platforms) {
                platform.draw();
            }

            if (debugOverlayEnabled && debugSolidGrid) {
                drawDebugOverlay();
            }

            // Update and draw letters (skip collected ones for performance)
            for (let letter of letters) {
                if (!letter.collected) {
                    letter.update();
                    letter.draw();
                }
            }

            // Update and draw player
            if (player && !gameWon) {
                player.update();
                player.draw();
                
                // Check for letter collection
                for (let letter of letters) {
                    if (letter.checkCollision(player)) {
                        letter.collected = true;
                        collectedLetters.push(letter);
                        
                        // Add points for the letter
                        score += COLLECTIBLE_LETTER_POINTS;
                        scoreElement.textContent = score;
                        
                        console.log(`Collected letter: ${letter.char} (${collectedLetters.length}/${targetWord.length})`);
                    }
                }
                
                // Check if player reached the goal portal
                if (goal) {
                    const collision = goal.checkCollision(player);
                    if (collision) {
                        console.log('Player reached goal portal!');
                        console.log('Player:', { x: player.x, y: player.y, width: player.width, height: player.height });
                        console.log('Goal Portal:', { x: goal.x, y: goal.y, width: goal.width, height: goal.height });
                        // Calculate bonuses if all letters were collected
                        if (collectedLetters.length === targetWord.length) {
                            wordCompleteBonus = WORD_COMPLETE_BONUS;
                            score += wordCompleteBonus;
                            
                            // Check if letters were collected in correct order
                            let correctOrder = true;
                            for (let i = 0; i < collectedLetters.length; i++) {
                                if (collectedLetters[i].index !== i) {
                                    correctOrder = false;
                                    break;
                                }
                            }
                            
                            if (correctOrder) {
                                correctOrderBonus = CORRECT_ORDER_BONUS;
                                score += correctOrderBonus;
                            }
                            
                            scoreElement.textContent = score;
                        }
                        gameWon = true;
                        console.log('Game won set to true');
                    }
                } else {
                    console.warn('goal is null!');
                }
            } else if (player && gameWon) {
                // Just draw the player when game is won, don't update
                player.draw();
            }

            // Restore context for UI overlay (drawn in screen space, not world space)
            ctx.restore();

            // Draw game info overlay (score, time)
            drawGameInfoOverlay();

            // Draw collected letters display
            drawCollectedLetters();

            // Draw win message if game is won
            if (gameWon) {
                drawWinMessage();
            }
            
            // Draw zoom level indicator
            drawZoomIndicator();

            requestAnimationFrame(gameLoop);
        }

        // Draw zoom level indicator
        function drawZoomIndicator() {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(canvas.width - 80, canvas.height - 40, 70, 30);
            
            ctx.fillStyle = '#FFF';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.round(camera.zoom * 100)}%`, canvas.width - 45, canvas.height - 25);
            ctx.restore();
        }

        // Draw game info overlay (score, time, controls hint)
        function drawGameInfoOverlay() {
            ctx.save();
            
            // Top-right corner - Score and Time
            const infoX = canvas.width - 10;
            const infoY = 10;
            
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.lineWidth = 4;
            ctx.fillStyle = '#FFD700';
            
            const scoreText = `Score: ${score}`;
            ctx.strokeText(scoreText, infoX, infoY);
            ctx.fillText(scoreText, infoX, infoY);
            
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const timeText = `Time: ${elapsedTime}s`;
            ctx.strokeText(timeText, infoX, infoY + 22);
            ctx.fillText(timeText, infoX, infoY + 22);
            
            ctx.restore();
        }

        function drawDebugOverlay() {
            const gridSize = debugGridSize;
            if (!gridSize) return;

            // Solid grid hint
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = '#00bcd4';

            for (let cy = 0; cy < debugSolidGrid.length; cy++) {
                const row = debugSolidGrid[cy];
                for (let cx = 0; cx < row.length; cx++) {
                    if (!row[cx]) continue;
                    const x = cx * gridSize;
                    const y = cy * gridSize;
                    const w = Math.min(gridSize, canvas.width - x);
                    const h = Math.min(gridSize, canvas.height - y);
                    ctx.fillRect(x, y, w, h);
                }
            }

            // Helper platforms highlight
            ctx.globalAlpha = 1;
            ctx.strokeStyle = 'rgba(80, 120, 255, 1)';
            ctx.lineWidth = 2;
            for (const p of debugHelperPlatforms) {
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            }

            // ML detected objects overlay (only in debug mode)
            if (debugOverlayEnabled && debugDetectedObjects && debugDetectedObjects.length > 0) {
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                
                for (const detection of debugDetectedObjects) {
                    const [x, y, w, h] = detection.bbox;
                    
                    // Draw bounding box
                    if (detection.isPlatformable) {
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                    } else {
                        ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                    }
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                    
                    // Draw label background
                    const label = `${detection.class} (${Math.round(detection.confidence * 100)}%)`;
                    const textWidth = ctx.measureText(label).width;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(x, y - 16, textWidth + 6, 16);
                    
                    // Draw label text
                    ctx.fillStyle = detection.isPlatformable ? '#00ff00' : '#ffa500';
                    ctx.fillText(label, x + 3, y - 4);
                }
            }

            ctx.restore();
        }

        // Update word bar HTML element with collected letters
        function drawCollectedLetters() {
            if (letters.length === 0) {
                wordBar.style.display = 'none';
                return;
            }
            
            wordBar.style.display = 'flex';
            
            // Create a Set of collected indices for O(1) lookup
            const collectedIndices = new Set(collectedLetters.map(l => l.index));
            
            // Build the letters HTML
            let lettersHTML = '';
            for (let i = 0; i < targetWord.length; i++) {
                const collected = collectedIndices.has(i);
                const className = collected ? 'word-letter collected' : 'word-letter uncollected';
                lettersHTML += `<span class="${className}">${targetWord[i]}</span>`;
            }
            
            wordLetters.innerHTML = lettersHTML;
            wordProgress.textContent = `${collectedLetters.length}/${targetWord.length}`;
        }

        // Draw win message overlay
        function drawWinMessage() {
            // Calculate message height based on content
            let messageHeight = 80;
            let yOffset = 0;
            
            if (collectedLetters.length === targetWord.length) {
                messageHeight = 160;
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, canvas.height / 2 - messageHeight / 2, canvas.width, messageHeight);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üéâ YOU WIN! üéâ', canvas.width / 2, canvas.height / 2 - 50);
            
            // Show word if all letters were collected
            if (collectedLetters.length === targetWord.length) {
                ctx.font = 'bold 28px Arial';
                ctx.fillStyle = '#00FF00';
                ctx.fillText(`You spelled: ${targetWord}!`, canvas.width / 2, canvas.height / 2 - 15);
                
                // Show bonuses
                ctx.font = '18px Arial';
                ctx.fillStyle = '#FFF';
                yOffset = 10;
                ctx.fillText(`Word Complete Bonus: +${wordCompleteBonus}`, canvas.width / 2, canvas.height / 2 + yOffset);
                
                if (correctOrderBonus > 0) {
                    yOffset += 25;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(`‚ú® Correct Order Bonus: +${correctOrderBonus} ‚ú®`, canvas.width / 2, canvas.height / 2 + yOffset);
                }
                
                yOffset += 30;
            } else {
                yOffset = 0;
            }
            
            ctx.font = '16px Arial';
            ctx.fillStyle = '#FFF';
            ctx.fillText('Press ESC or click "Exit Game" to return to start', canvas.width / 2, canvas.height / 2 + yOffset + 30);
        }

        // Show intro screen (from splash or back from game)
        function showIntroScreen() {
            splashScreen.classList.add('hidden');
            introScreen.classList.remove('hidden');
            gameScreen.classList.remove('active');
            exitFullscreen();
        }

        // Show game screen
        function showGameScreen() {
            splashScreen.classList.add('hidden');
            introScreen.classList.add('hidden');
            gameScreen.classList.add('active');
        }

        // Enter fullscreen
        function enterFullscreen() {
            gameCanvasContainer.classList.add('fullscreen');
            exitFullscreenBtn.classList.add('visible');
            document.body.style.overflow = 'hidden';
            
            // Lock to landscape orientation on mobile devices
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(err => {
                    // Orientation lock requires fullscreen API and may not be supported on all devices
                    // This is an optional enhancement - game works fine without it
                    console.log('Screen orientation lock not available:', err.name, err.message);
                });
            }
        }

        // Exit fullscreen
        function exitFullscreen() {
            gameCanvasContainer.classList.remove('fullscreen');
            exitFullscreenBtn.classList.remove('visible');
            document.body.style.overflow = '';
            
            // Unlock screen orientation
            if (screen.orientation && screen.orientation.unlock) {
                screen.orientation.unlock();
            }
        }

        // Return to intro and exit fullscreen
        function returnToIntro() {
            resetGame();
            showIntroScreen();
        }

        // Reset game
        function resetGame() {
            gameRunning = false;
            gameWon = false;
            platforms = [];
            player = null;
            goal = null;  // Clear goal
            score = 0;
            letters = [];  // Clear letters
            collectedLetters = [];  // Clear collected letters
            targetWord = '';  // Clear target word
            wordCompleteBonus = 0;
            correctOrderBonus = 0;
            backgroundImage = null; // Clear background image
            canvas.style.display = 'none';
            gameInfo.style.display = 'none';
            wordBar.style.display = 'none';  // Hide word bar
            detectionModeBadge.classList.remove('visible');  // Hide detection mode badge
            resetBtn.style.display = 'none';
            uploadBtn.style.display = 'inline-block';
            cameraBtn.style.display = 'inline-block';
        }

        function guessDeviceType() {
            const ua = (navigator.userAgent || '').toLowerCase();
            if (ua.includes('ipad') || ua.includes('tablet')) return 'tablet';
            if (ua.includes('iphone') || ua.includes('android')) {
                return ua.includes('mobile') ? 'mobile' : 'tablet';
            }
            if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
                return window.innerWidth >= 768 ? 'tablet' : 'mobile';
            }
            return 'desktop';
        }

        function setFeedbackStatus(text, kind) {
            feedbackStatus.textContent = text || '';
            feedbackStatus.classList.remove('error', 'success');
            if (kind) feedbackStatus.classList.add(kind);
        }

        function openFeedbackModal() {
            feedbackDeviceType.value = guessDeviceType();
            setFeedbackStatus('', null);
            feedbackModal.classList.add('open');
            feedbackModal.setAttribute('aria-hidden', 'false');

            if (location.protocol === 'file:') {
                setFeedbackStatus('Feedback requires running the local server (not file://).', 'error');
            }

            setTimeout(() => {
                feedbackMessage.focus();
            }, 0);
        }

        function closeFeedbackModal() {
            feedbackModal.classList.remove('open');
            feedbackModal.setAttribute('aria-hidden', 'true');
        }

        async function postFeedback(message, deviceType, token) {
            const headers = {
                'Content-Type': 'application/json'
            };
            if (token) headers['X-Feedback-Token'] = token;

            return fetch('/api/feedback', {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    message,
                    deviceType
                })
            });
        }

        function shouldIgnoreGameKeyEvent(e) {
            if (feedbackModal.classList.contains('open')) return true;
            const target = e.target;
            if (!target) return false;
            if (target.isContentEditable) return true;
            const tag = (target.tagName || '').toUpperCase();
            return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        }

        function updateLanHint() {
            if (location.protocol === 'file:') {
                lanHint.classList.remove('open');
                return;
            }

            lanHint.classList.add('open');
            lanUrl.textContent = location.href;

            const host = (location.hostname || '').toLowerCase();
            if (host === 'localhost' || host === '127.0.0.1') {
                lanNote.innerHTML = 'If you\'re sharing to other devices, replace <strong>localhost</strong> with the host computer\'s LAN IP (e.g. <strong>192.168.x.x</strong>).';
            } else if (host === '0.0.0.0') {
                lanNote.innerHTML = 'Use the host computer\'s LAN IP instead of <strong>0.0.0.0</strong> when sharing (e.g. <strong>192.168.x.x</strong>).';
            } else {
                lanNote.textContent = 'Open this URL on devices connected to the same network.';
            }
        }

        if (debugOverlayToggle) {
            debugOverlayToggle.checked = DEBUG_DEFAULT_ENABLED;
            debugOverlayToggle.addEventListener('change', () => {
                debugOverlayEnabled = Boolean(debugOverlayToggle.checked);
            });
        }

        // ML Detection toggle handling
        const mlDetectionToggle = document.getElementById('mlDetectionToggle');
        if (mlDetectionToggle) {
            mlDetectionToggle.checked = ML_DETECTION_ENABLED_DEFAULT;
            mlDetectionToggle.addEventListener('change', async () => {
                mlDetectionEnabled = Boolean(mlDetectionToggle.checked);
                
                if (mlDetectionEnabled && !onnxModelLoaded && !onnxModelLoading) {
                    // Reset error state to allow retry
                    onnxLoadError = null;
                    
                    // Show loading status
                    updateMLStatus('Loading model...');
                    
                    // Start loading the ONNX model when user enables ML detection
                    const success = await initONNXModel();
                    if (!success) {
                        // If loading fails, disable the toggle and show helpful message
                        mlDetectionToggle.checked = false;
                        mlDetectionEnabled = false;
                        updateMLStatus('');
                        updateDetectionModeBadge();
                        
                        // Show actual error from console
                        const errorMsg = onnxLoadError?.message || 'Unknown error';
                        alert('ML detection failed to load.\n\n' +
                            'Error: ' + errorMsg + '\n\n' +
                            'Check browser console (F12) for details.\n\n' +
                            'Common fixes:\n' +
                            '- Refresh the page\n' +
                            '- Check internet connection (CDN needed)\n' +
                            '- Clear browser cache\n\n' +
                            'See docs/ONNX_SETUP.md for full troubleshooting.');
                    } else {
                        updateMLStatus('ML ready');
                        updateDetectionModeBadge();
                    }
                } else if (mlDetectionEnabled && onnxModelLoaded) {
                    updateMLStatus('ML ready');
                    updateDetectionModeBadge();
                } else {
                    updateMLStatus('');
                    updateDetectionModeBadge();
                }
            });
        }

        async function copyLanLink() {
            const text = location.href;
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const temp = document.createElement('textarea');
                    temp.value = text;
                    temp.style.position = 'fixed';
                    temp.style.left = '-9999px';
                    document.body.appendChild(temp);
                    temp.focus();
                    temp.select();
                    document.execCommand('copy');
                    document.body.removeChild(temp);
                }
                copyLinkBtn.textContent = 'Copied';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 900);
            } catch {
                copyLinkBtn.textContent = 'Copy failed';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 1200);
            }
        }

        // Event listeners
        splashPlayBtn.addEventListener('click', showIntroScreen);
        startGameBtn.addEventListener('click', showGameScreen);
        exitFullscreenBtn.addEventListener('click', returnToIntro);
        
        uploadBtn.addEventListener('click', () => fileInput.click());
        cameraBtn.addEventListener('click', () => cameraInput.click());
        resetBtn.addEventListener('click', returnToIntro);

        copyLinkBtn.addEventListener('click', copyLanLink);

        feedbackBtn.addEventListener('click', openFeedbackModal);
        feedbackCancelBtn.addEventListener('click', closeFeedbackModal);
        feedbackModal.addEventListener('click', (e) => {
            if (e.target === feedbackModal) closeFeedbackModal();
        });

        fileInput.addEventListener('change', (e) => {
            console.log('File input changed');
            const file = e.target.files[0];
            if (file) {
                console.log('File selected:', file.name, file.type, file.size);
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please select a valid image file.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('File is too large. Please select an image under 10MB.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    console.log('FileReader loaded');
                    const img = new Image();
                    img.onload = () => {
                        console.log('Image loaded, calling processImage');
                        processImage(img);
                    };
                    img.onerror = () => {
                        console.error('Image load error');
                        alert('Failed to load image. Please try a different file.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    console.error('FileReader error');
                    alert('Failed to read file. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        cameraInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please capture a valid image.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('Image is too large. Please try again.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try again.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read image. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        feedbackForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const message = (feedbackMessage.value || '').trim();
            const deviceType = feedbackDeviceType.value || 'unknown';

            if (!message) {
                setFeedbackStatus('Please enter a message.', 'error');
                return;
            }

            feedbackSubmitBtn.disabled = true;
            setFeedbackStatus('Sending‚Ä¶', null);

            try {
                let token = localStorage.getItem(FEEDBACK_TOKEN_STORAGE_KEY) || '';
                let response = await postFeedback(message, deviceType, token);

                if (response.status === 401) {
                    const enteredToken = window.prompt('This server requires an access code. Enter it to send feedback:');
                    if (enteredToken) {
                        localStorage.setItem(FEEDBACK_TOKEN_STORAGE_KEY, enteredToken);
                        token = enteredToken;
                        response = await postFeedback(message, deviceType, token);
                    }
                }

                if (!response.ok) {
                    const text = await response.text();
                    setFeedbackStatus(`Failed to send feedback (${response.status}). ${text ? 'Details: ' + text : ''}`.trim(), 'error');
                    return;
                }

                feedbackMessage.value = '';
                setFeedbackStatus('Sent. Thank you!', 'success');

                setTimeout(() => {
                    closeFeedbackModal();
                }, 700);
            } catch (err) {
                setFeedbackStatus('Failed to send feedback. Is the local server running?', 'error');
            } finally {
                feedbackSubmitBtn.disabled = false;
            }
        });

        updateLanHint();

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // ESC key returns to intro screen
            if (e.key === 'Escape') {
                if (gameScreen.classList.contains('active')) {
                    returnToIntro();
                    e.preventDefault();
                }
                return;
            }
            
            if (shouldIgnoreGameKeyEvent(e)) return;
            
            // Zoom controls with + and - keys
            if (e.key === '=' || e.key === '+') {
                camera.zoom = Math.min(camera.maxZoom, camera.zoom + 0.1);
                e.preventDefault();
                return;
            }
            if (e.key === '-' || e.key === '_') {
                camera.zoom = Math.max(camera.minZoom, camera.zoom - 0.1);
                e.preventDefault();
                return;
            }
            // Reset zoom with '0' ‚Äî snaps to auto-fit level
            if (e.key === '0') {
                camera.zoom = camera.autoFitZoom;
                e.preventDefault();
                return;
            }
            
            // Manual respawn with 'R' key
            if ((e.key === 'r' || e.key === 'R') && player && gameRunning) {
                player.respawn();
                e.preventDefault();
                return;
            }
            
            // Regenerate level with 'G' key
            if ((e.key === 'g' || e.key === 'G') && backgroundImage && gameRunning) {
                console.log('Regenerating level...');
                gameRunning = false;  // Stop current game loop
                
                // Small delay to ensure current frame completes
                setTimeout(() => {
                    processImage(backgroundImage);
                }, 50);
                
                e.preventDefault();
                return;
            }
            
            keys[e.key] = true;
            // Prevent default for arrow keys and space
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!gameRunning) return;
            
            const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
            camera.zoom = Math.max(camera.minZoom, Math.min(camera.maxZoom, camera.zoom + zoomDelta));
        }, { passive: false });

        // Resize canvas when window resizes
        window.addEventListener('resize', () => {
            if (gameRunning) {
                resizeCanvas();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (shouldIgnoreGameKeyEvent(e)) return;
            
            // Variable jump: cut the jump short on early release
            if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W' || e.key === ' ') 
                && player && player.jumpCutAllowed && player.velocityY < 0) {
                player.velocityY *= JUMP_CUT_DAMPING;
                player.jumpCutAllowed = false;
            }
            
            keys[e.key] = false;
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
            
            // Jump on tap
            touchJumping = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // Horizontal movement based on touch position
            const deltaX = touchX - touchStartX;
            
            if (deltaX < -20) {
                keys['ArrowLeft'] = true;
                keys['ArrowRight'] = false;
            } else if (deltaX > 20) {
                keys['ArrowRight'] = true;
                keys['ArrowLeft'] = false;
            } else {
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            // Variable jump: cut the jump short on early release
            if (player && player.jumpCutAllowed && player.velocityY < 0) {
                player.velocityY *= JUMP_CUT_DAMPING;
                player.jumpCutAllowed = false;
            }
        });

        // Mobile control button handlers
        // Detect if device supports touch and show controls
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            mobileControls.classList.add('visible');
        }

        // Left button
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        leftBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });

        // Right button
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        rightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        rightBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });

        // Jump button
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchJumping = true;
        });
        jumpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
            // Variable jump: cut the jump short on early release
            if (player && player.jumpCutAllowed && player.velocityY < 0) {
                player.velocityY *= JUMP_CUT_DAMPING;
                player.jumpCutAllowed = false;
            }
        });
        jumpBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchJumping = false;
            // Also cut jump on touch cancel
            if (player && player.jumpCutAllowed && player.velocityY < 0) {
                player.velocityY *= JUMP_CUT_DAMPING;
                player.jumpCutAllowed = false;
            }
        });

        // Zoom control buttons
        zoomInBtn.addEventListener('click', (e) => {
            e.preventDefault();
            camera.zoom = Math.min(camera.maxZoom, camera.zoom + 0.2);
        });

        zoomOutBtn.addEventListener('click', (e) => {
            e.preventDefault();
            camera.zoom = Math.max(camera.minZoom, camera.zoom - 0.2);
        });

        zoomResetBtn.addEventListener('click', (e) => {
            e.preventDefault();
            camera.zoom = camera.autoFitZoom;
        });

        // Respawn button (R)
        respawnBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (player && gameRunning) player.respawn();
        });
        respawnBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (player && gameRunning) player.respawn();
        });

        // Regenerate level button (G)
        regenBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (backgroundImage && gameRunning) {
                console.log('Regenerating level...');
                gameRunning = false;
                setTimeout(() => { processImage(backgroundImage); }, 50);
            }
        });
        regenBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (backgroundImage && gameRunning) {
                console.log('Regenerating level...');
                gameRunning = false;
                setTimeout(() => { processImage(backgroundImage); }, 50);
            }
        });

        // Touch support for zoom buttons
        zoomInBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            camera.zoom = Math.min(camera.maxZoom, camera.zoom + 0.2);
        });

        zoomOutBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            camera.zoom = Math.max(camera.minZoom, camera.zoom - 0.2);
        });

        zoomResetBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            camera.zoom = camera.autoFitZoom;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && feedbackModal.classList.contains('open')) {
                closeFeedbackModal();
            }
        });

        // Register Service Worker for PWA/offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
