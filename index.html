<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#764ba2">
    <meta name="description" content="Turn your photos into playable platformer levels! Upload a photo and jump through your own pictures.">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Photo Jumper">
    <title>Photo Jumper - Platform Game</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .lan-hint {
            margin-top: -6px;
            margin-bottom: 18px;
            background: #f7f7ff;
            border: 1px solid #e3e3ff;
            border-radius: 12px;
            padding: 12px;
            display: none;
        }

        .lan-hint.open {
            display: block;
        }

        .lan-hint .row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .lan-hint .label {
            font-weight: bold;
            color: #333;
        }

        .lan-hint code {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px 10px;
            display: inline-block;
            max-width: 100%;
            overflow-wrap: anywhere;
        }

        .lan-hint .note {
            margin-top: 8px;
            color: #666;
            font-size: 13px;
        }

        .lan-hint .note strong {
            color: #333;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #fileInput, #cameraInput {
            display: none;
        }

        .game-canvas-container {
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 3px solid #333;
            border-radius: 10px;
            max-width: 100%;
            background: #87ceeb;
            display: none;
        }

        .instructions {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .instructions p {
            margin-bottom: 8px;
            color: #666;
        }

        .game-info {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: none;
        }

        .preview-canvas {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 1000;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 520px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
        }

        .modal-content h3 {
            margin-bottom: 8px;
            color: #333;
        }

        .modal-content .hint {
            margin-bottom: 14px;
            color: #666;
            font-size: 14px;
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            text-align: left;
        }

        .form-row label {
            font-weight: bold;
            color: #333;
        }

        .form-row select,
        .form-row textarea {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 10px;
            font-size: 14px;
            font-family: inherit;
        }

        .form-row textarea {
            resize: vertical;
            min-height: 110px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .status {
            margin-top: 10px;
            min-height: 18px;
            color: #333;
            font-size: 14px;
        }

        .status.error {
            color: #b00020;
        }

        .status.success {
            color: #0b6b0b;
        }

        /* Mobile control buttons */
        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            user-select: none;
        }

        .mobile-controls.visible {
            display: flex;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 15px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            touch-action: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .control-btn.jump-btn {
            width: 90px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        /* Zoom control buttons */
        .zoom-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            flex-direction: column;
            gap: 10px;
            z-index: 102;
        }

        .game-canvas-container.fullscreen ~ .zoom-controls {
            display: flex;
        }

        .zoom-btn {
            width: 50px;
            height: 50px;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #FFD700;
            transform: scale(1.1);
        }

        .zoom-btn:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        /* Intro screen styles */
        .intro-screen {
            text-align: center;
            padding: 40px 20px;
        }

        .intro-screen.hidden {
            display: none;
        }

        .intro-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .intro-screen .tagline {
            font-size: 1.3em;
            color: #555;
            margin-bottom: 30px;
        }

        .intro-screen .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
            text-align: left;
        }

        .intro-screen .feature {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .intro-screen .feature h3 {
            margin-bottom: 8px;
            color: #667eea;
        }

        .intro-screen .feature p {
            color: #666;
            margin: 0;
        }

        .intro-screen .cta-button {
            font-size: 1.2em;
            padding: 16px 32px;
            margin-top: 20px;
        }

        /* Game screen styles */
        .game-screen {
            display: none;
        }

        .game-screen.active {
            display: block;
        }

        /* Fullscreen styles */
        .game-canvas-container.fullscreen {
            position: fixed;
            inset: 0;
            z-index: 100;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            margin: 0;
        }

        .game-canvas-container.fullscreen #gameCanvas {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            border-radius: 0;
        }

        /* Hide non-essential elements when canvas is fullscreen */
        .game-canvas-container.fullscreen ~ .instructions {
            display: none;
        }

        .game-screen:has(.game-canvas-container.fullscreen) .upload-section {
            display: none;
        }

        .game-screen:has(.game-canvas-container.fullscreen) h1 {
            display: none;
        }

        /* Position game info overlay when fullscreen */
        .game-canvas-container.fullscreen ~ .game-info,
        .game-screen:has(.game-canvas-container.fullscreen) .game-info {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Position mobile controls when fullscreen */
        .game-canvas-container.fullscreen ~ .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
        }

        /* Exit fullscreen button */
        .exit-fullscreen-btn {
            position: fixed;
            top: 60px;  /* Moved down to not overlap score */
            right: 10px;
            z-index: 101;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.5);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            display: none;
            cursor: pointer;
        }

        .exit-fullscreen-btn.visible {
            display: block;
        }
        
        .exit-fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #FFD700;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
            }

            button {
                padding: 10px 20px;
                font-size: 14px;
            }

            .container {
                padding: 20px;
            }

            .intro-screen h1 {
                font-size: 2em;
            }

            .intro-screen .tagline {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <button class="exit-fullscreen-btn" id="exitFullscreenBtn">‚Üê Exit</button>
    
    <div class="container">
        <!-- Intro Screen -->
        <div class="intro-screen" id="introScreen">
            <h1>üéÆ Photo Jumper</h1>
            <p class="tagline">Turn your photos into playable platformer levels!</p>
            
            <div class="features">
                <div class="feature">
                    <h3>üì∏ Upload or Capture</h3>
                    <p>Use any photo - the game detects edges and brightness to create platforms</p>
                </div>
                <div class="feature">
                    <h3>üéØ Reach the Goal</h3>
                    <p>Jump from platform to platform to reach the golden star at the top</p>
                </div>
                <div class="feature">
                    <h3>‚ö° Fast & Fun</h3>
                    <p>Quick platformer action with responsive controls</p>
                </div>
            </div>

            <button class="cta-button" id="startGameBtn">Get Started</button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <h1>üéÆ Photo Jumper</h1>
            
            <div class="upload-section">
            <div class="button-group">
                <button id="uploadBtn">üìÅ Upload Photo</button>
                <button id="cameraBtn">üì∑ Take Photo</button>
                <button id="resetBtn" style="display: none;">üîÑ New Photo</button>
                <button id="feedbackBtn" type="button">üìù Feedback</button>
            </div>

            <div id="lanHint" class="lan-hint" aria-live="polite">
                <div class="row">
                    <div>
                        <div class="label">Share link</div>
                        <code id="lanUrl"></code>
                    </div>
                    <button id="copyLinkBtn" type="button">Copy</button>
                </div>
                <div id="lanNote" class="note"></div>
            </div>

            <input type="file" id="fileInput" accept="image/*">
            <input type="file" id="cameraInput" accept="image/*" capture="environment">
        </div>

        <div class="game-info" id="gameInfo">
            Score: <span id="score">0</span> | Time: <span id="time">0</span>s
        </div>

        <div class="game-canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <canvas id="previewCanvas" class="preview-canvas"></canvas>
        </div>

        <!-- Mobile control buttons -->
        <div class="mobile-controls" id="mobileControls">
            <button class="control-btn" id="leftBtn" aria-label="Move left">‚óÄ</button>
            <button class="control-btn jump-btn" id="jumpBtn" aria-label="Jump">‚ñ≤</button>
            <button class="control-btn" id="rightBtn" aria-label="Move right">‚ñ∂</button>
        </div>

        <!-- Zoom control buttons -->
        <div class="zoom-controls" id="zoomControls">
            <button class="zoom-btn" id="zoomOutBtn" aria-label="Zoom out" title="Zoom out (-)">‚àí</button>
            <button class="zoom-btn" id="zoomResetBtn" aria-label="Reset zoom" title="Reset zoom (0)">‚äô</button>
            <button class="zoom-btn" id="zoomInBtn" aria-label="Zoom in" title="Zoom in (+)">+</button>
        </div>

        <div class="instructions">
            <h3>How to Play:</h3>
            <p>1. Upload a photo or take one with your camera</p>
            <p>2. The photo will be converted into platforms based on brightness</p>
            <p>3. Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move (or touch controls on mobile)</p>
            <p>4. Press <strong>Space</strong> or <strong>Up Arrow</strong> to jump</p>
            <p>5. Navigate from the green start platform to the golden goal star!</p>
            <p>6. Press <strong>R</strong> to respawn if you get stuck</p>
            <p><label><input type="checkbox" id="debugOverlayToggle"> Debug overlay</label></p>
            <p><label><input type="checkbox" id="mlDetectionToggle" aria-describedby="mlStatusDesc"> ML object detection (experimental)</label>
                <span id="mlStatus" style="font-size: 12px; color: #666;"></span>
                <span id="mlStatusDesc" class="visually-hidden" style="position: absolute; left: -10000px;">When enabled, uses machine learning to detect objects in your photo and create platforms from them. May increase loading time.</span>
            </p>
        </div>
        </div>
        <!-- End Game Screen -->

        <div id="feedbackModal" class="modal" aria-hidden="true">
            <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="feedbackTitle">
                <h3 id="feedbackTitle">Send Feedback</h3>
                <p class="hint">Text-only feedback is saved locally on the host machine.</p>

                <form id="feedbackForm">
                    <div class="form-row">
                        <label for="feedbackDeviceType">Device type</label>
                        <select id="feedbackDeviceType" required>
                            <option value="unknown">Unknown</option>
                            <option value="desktop">Desktop / Laptop</option>
                            <option value="tablet">Tablet</option>
                            <option value="mobile">Mobile</option>
                        </select>
                    </div>

                    <div class="form-row">
                        <label for="feedbackMessage">Message</label>
                        <textarea id="feedbackMessage" maxlength="2000" placeholder="What worked well? What was confusing or buggy?" required></textarea>
                    </div>

                    <div class="modal-actions">
                        <button type="button" id="feedbackCancelBtn">Cancel</button>
                        <button type="submit" id="feedbackSubmitBtn">Send</button>
                    </div>
                    <div id="feedbackStatus" class="status" aria-live="polite"></div>
                </form>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        
        const introScreen = document.getElementById('introScreen');
        const gameScreen = document.getElementById('gameScreen');
        const startGameBtn = document.getElementById('startGameBtn');
        const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
        const container = document.querySelector('.container');
        const gameCanvasContainer = document.querySelector('.game-canvas-container');
        
        const uploadBtn = document.getElementById('uploadBtn');
        const cameraBtn = document.getElementById('cameraBtn');
        const resetBtn = document.getElementById('resetBtn');
        const feedbackBtn = document.getElementById('feedbackBtn');
        const fileInput = document.getElementById('fileInput');
        const cameraInput = document.getElementById('cameraInput');
        const gameInfo = document.getElementById('gameInfo');
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');

        const feedbackModal = document.getElementById('feedbackModal');
        const feedbackForm = document.getElementById('feedbackForm');
        const feedbackDeviceType = document.getElementById('feedbackDeviceType');
        const feedbackMessage = document.getElementById('feedbackMessage');
        const feedbackCancelBtn = document.getElementById('feedbackCancelBtn');
        const feedbackSubmitBtn = document.getElementById('feedbackSubmitBtn');
        const feedbackStatus = document.getElementById('feedbackStatus');

        const lanHint = document.getElementById('lanHint');
        const lanUrl = document.getElementById('lanUrl');
        const lanNote = document.getElementById('lanNote');
        const copyLinkBtn = document.getElementById('copyLinkBtn');

        const debugOverlayToggle = document.getElementById('debugOverlayToggle');

        // Mobile control buttons
        const mobileControls = document.getElementById('mobileControls');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');

        // Zoom control buttons
        const zoomControls = document.getElementById('zoomControls');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');

        const FEEDBACK_TOKEN_STORAGE_KEY = 'photoJumperFeedbackToken';

        // Game configuration constants
        const PLAYER_SIZE = 20;
        const PLAYER_SPEED = 4;  // Adjusted from 3 - sweet spot between 3 and 5
        const PLAYER_JUMP_POWER = 12;
        const PLAYER_GRAVITY = 0.5;

        const GRID_SIZE = 20;  // Reduced from 30 to detect more platforms (1x player size)
        const BRIGHTNESS_THRESHOLD = 140;  // Increased from 128 to require brighter areas for platforms
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
        const EDGE_DETECTION_THRESHOLD = 30;  // Reduced from 40 for better edge detection
        const EDGE_BRIGHTNESS_THRESHOLD = 200;  // Increased from 180 to accept more edge-detected platforms

        // Modular block platform system
        const BLOCK_SIZE = 20;  // Individual block size (matches GRID_SIZE)
        const PLATFORM_MIN_WIDTH = 40;  // Must fit at least 2 blocks
        const PLATFORM_THICKNESS = BLOCK_SIZE;  // One block tall
        const PLATFORM_MERGE_GAP_PX = 0;
        const HELPERS_MAX_COUNT = 30;  // Increased for better reachability with modular blocks

        const DEBUG_DEFAULT_ENABLED = false;
        
        // Player spawn and reserved area constants
        const PLAYER_SPAWN_X = 40;
        const PLAYER_SPAWN_Y_OFFSET = 100; // Pixels above canvas bottom
        const START_AREA_WIDTH = 140;  // Wider to ensure clear start area
        const START_AREA_HEIGHT = 100;  // Taller to ensure clear start area
        const GOAL_AREA_WIDTH = 100;
        const GOAL_AREA_HEIGHT = 80;
        const WORD_BAR_AREA_HEIGHT = 30;  // Reduced from 60 to not overlap with score display
        
        // Stuck detection constants
        const STUCK_CHECK_INTERVAL = 15000;  // 15 seconds - increased from 5 for more patience
        const STUCK_MOVEMENT_THRESHOLD = 5;  // pixels

        // Letter collection constants
        const COLLECTIBLE_LETTER_SIZE = 20;
        const COLLECTIBLE_LETTER_POINTS = 10;  // Points per letter
        const COLLECTIBLE_LETTER_FLOAT_SPEED = 0.1;  // Animation speed for floating effect
        const COLLECTIBLE_LETTER_OFFSET_RATIO = 0.4;  // Ratio of platform width for random offset
        const COLLECTIBLE_LETTER_MAX_OFFSET = 30;  // Maximum horizontal offset in pixels
        const COLLECTIBLE_LETTER_VERTICAL_OFFSET = 10;  // Pixels above platform
        const WORD_COMPLETE_BONUS = 50;  // Bonus for collecting all letters
        const CORRECT_ORDER_BONUS = 100;  // Extra bonus for correct order
        const WORD_DICTIONARY = ['JUMP', 'PLAY', 'GAME', 'PHOTO', 'STAR', 'GOAL', 'WIN', 'FUN'];
        const MAX_GOAL_CANDIDATES = 3;  // Number of top goal platform candidates to randomly select from
        
        // Camera and viewport constants
        let camera = {
            x: 0,
            y: 0,
            zoom: 1.0,
            minZoom: 0.5,
            maxZoom: 2.0,
            smoothing: 0.1,  // Camera follow smoothing (0-1, lower = smoother)
            targetX: 0,
            targetY: 0
        };
        
        // Pre-computed shortest word for fallback (safe with non-empty dictionary)
        const SHORTEST_WORD = WORD_DICTIONARY.length > 0 
            ? WORD_DICTIONARY.reduce((shortest, word) => word.length < shortest.length ? word : shortest)
            : 'FUN';  // Fallback if dictionary is somehow empty

        let gameRunning = false;
        let platforms = [];
        let player = null;
        let goal = null;  // Goal object for animation tracking
        let goalPlatform = null;  // The platform that acts as the goal
        let playerSpawnY = 0;  // Calculated spawn Y position
        let keys = {};
        let score = 0;
        let startTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchJumping = false;
        let backgroundImage = null; // Store the uploaded photo for background
        let gameWon = false;  // Track if player reached the goal

        // Letter collection game state
        let letters = [];  // Array of Letter objects
        let collectedLetters = [];  // Array of collected letters in order
        let targetWord = '';  // The word to spell
        let wordCompleteBonus = 0;  // Bonus earned for completing word
        let correctOrderBonus = 0;  // Bonus earned for correct order

        let debugOverlayEnabled = DEBUG_DEFAULT_ENABLED;
        let debugSolidGrid = null;
        let debugGridSize = GRID_SIZE;
        let debugHelperPlatforms = [];

        // ONNX ML detection configuration
        const ML_DETECTION_ENABLED_DEFAULT = false;
        // Model URLs: Try CDN first for deployments, local as fallback
        // For local development: place yolov8n.onnx in 'models/' folder
        // For production: CDN is preferred (smaller deployment, no large files in repo)
        const ML_MODEL_URLS = [
            'https://cdn.jsdelivr.net/gh/aspect-technology/yolov8-onnx@main/models/yolov8n.onnx',  // CDN (preferred for production)
            'models/yolov8n.onnx',  // Local fallback (for development/offline)
        ];
        // ONNX Runtime URLs: CDN first for deployments, local fallback
        // For local development: download ort.min.js and ort-wasm*.wasm files to 'lib/' folder
        // From: https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/
        const ONNX_RUNTIME_URLS = [
            'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js',  // CDN (preferred for production)
            'lib/ort.min.js',  // Local fallback (for development/offline)
        ];
        const ML_CONFIDENCE_THRESHOLD = 0.3;  // Lowered from 0.5 to detect more objects
        const ML_INPUT_SIZE = 640;  // YOLOv8n expects 640x640 input images
        const ML_INFERENCE_TIMEOUT_MS = 5000;
        const ML_MIN_DETECTION_SIZE = 10;  // Minimum bounding box size in pixels to consider
        const ML_PLATFORM_MERGE_TOLERANCE = 20;  // Extra horizontal gap tolerance when merging ML platforms
        const ML_PLATFORM_OVERLAP_TOLERANCE_Y = 10;  // Vertical overlap tolerance when combining ML and grid platforms
        
        // COCO classes that are suitable for platforms (horizontal surfaces)
        const PLATFORMABLE_CLASSES = [
            // Furniture - obvious platforms
            'bench', 'chair', 'couch', 'bed', 'dining table', 'desk', 'toilet',
            
            // Electronics - flat top surfaces
            'tv', 'laptop', 'keyboard', 'book', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator',
            
            // Vehicles - can stand on top
            'car', 'bus', 'truck', 'boat', 'train', 'airplane', 'bicycle', 'motorcycle',
            
            // Large objects - stable platforms
            'suitcase', 'backpack', 'skateboard', 'surfboard', 
            
            // Sports equipment - flat surfaces
            'snowboard', 'skis',
            
            // Containers - can stand on
            'vase', 'potted plant', 'bowl',
            
            // Animals - because why not! ü¶íüêòüê¥
            'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe',
            
            // People - jump on heads!
            'person',
            
            // Other - potential platforms
            'clock', 'teddy bear', 'remote', 'mouse', 'cell phone'
        ];
        
        // COCO class names (80 classes)
        const COCO_CLASSES = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat',
            'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack',
            'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
            'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
            'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake',
            'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop',
            'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink',
            'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];

        // ONNX state
        let mlDetectionEnabled = ML_DETECTION_ENABLED_DEFAULT;
        let onnxSession = null;
        let onnxModelLoading = false;
        let onnxModelLoaded = false;
        let onnxLoadError = null;
        let debugDetectedObjects = [];

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = PLAYER_SIZE;
                this.height = PLAYER_SIZE;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = PLAYER_SPEED;
                this.jumpPower = PLAYER_JUMP_POWER;
                this.gravity = PLAYER_GRAVITY;
                this.onGround = false;
                this.lastPositionTime = Date.now();
                this.lastX = x;
                this.lastY = y;
                this.stuckCheckInterval = STUCK_CHECK_INTERVAL;
            }

            update() {
                // Horizontal movement
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    this.velocityX = -this.speed;
                    this.lastPositionTime = Date.now(); // Reset stuck timer on input
                } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    this.velocityX = this.speed;
                    this.lastPositionTime = Date.now(); // Reset stuck timer on input
                } else {
                    this.velocityX *= 0.7; // Reduced friction for more responsive feel
                }

                // Jumping
                if ((keys['ArrowUp'] || keys['w'] || keys['W'] || keys[' '] || touchJumping) && this.onGround) {
                    this.velocityY = -this.jumpPower;
                    this.onGround = false;
                    touchJumping = false; // Reset touch jump
                    this.lastPositionTime = Date.now(); // Reset stuck timer on input
                }

                // Apply gravity
                this.velocityY += this.gravity;

                // Update horizontal position
                this.x += this.velocityX;

                // Check horizontal platform collisions
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Push out from sides
                        if (this.x + this.width / 2 < platform.x + platform.width / 2) {
                            this.x = platform.x - this.width;
                        } else {
                            this.x = platform.x + platform.width;
                        }
                        this.velocityX = 0;
                    }
                }

                // Update vertical position
                this.y += this.velocityY;

                // Check vertical platform collisions
                this.onGround = false;
                for (let platform of platforms) {
                    if (this.checkCollision(platform)) {
                        // Landing on top of platform
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                        // Hitting platform from below
                        else if (this.velocityY < 0 && this.y - this.velocityY >= platform.y + platform.height) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                    }
                }

                // Boundary checks
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;

                // Check if player fell off
                if (this.y > canvas.height) {
                    this.respawn();
                }

                // Stuck detection: if player hasn't moved significantly in a while
                const now = Date.now();
                const distMoved = Math.sqrt((this.x - this.lastX) ** 2 + (this.y - this.lastY) ** 2);
                
                if (now - this.lastPositionTime > this.stuckCheckInterval) {
                    if (distMoved < STUCK_MOVEMENT_THRESHOLD && this.onGround) {
                        // Player appears stuck, auto-respawn
                        this.respawn();
                        // Reset tracking variables after respawn to prevent immediate re-triggering
                        this.lastX = this.x;
                        this.lastY = this.y;
                        this.lastPositionTime = Date.now();
                    } else {
                        // Update last known position when not stuck
                        this.lastX = this.x;
                        this.lastY = this.y;
                        this.lastPositionTime = now;
                    }
                }

                // Update score based on progress and time efficiency
                // Score = platforms reached * 100 - time penalty
                const heightProgress = Math.max(0, Math.floor((canvas.height - this.y) / 10));
                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                const timePenalty = Math.floor(elapsedSeconds / 2); // -1 point every 2 seconds
                const currentScore = Math.max(0, heightProgress * 2 - timePenalty);
                
                if (currentScore > score) {
                    score = currentScore;
                    scoreElement.textContent = score;
                }
            }

            checkCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            respawn() {
                this.x = PLAYER_SPAWN_X;
                this.y = playerSpawnY;  // Use the calculated spawn Y position
                this.velocityX = 0;
                this.velocityY = 0;
                score = Math.max(0, score - 10);
                scoreElement.textContent = score;
            }

            draw() {
                // Draw shadow/outline for better visibility on photo
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x + 2, this.y + 2, this.width, this.height);
                
                // Draw main body
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw border for visibility
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Draw eyes (adjusted for smaller size)
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x + 4, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 12, this.y + 5, 4, 4);
                
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x + 5, this.y + 6, 2, 2);
                ctx.fillRect(this.x + 13, this.y + 6, 2, 2);
            }
        }

        // Goal class - represents the end goal for the level
        class Goal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 0;   // No separate goal object
                this.height = 0;  // Goal is just the glowing platform
                this.animation = 0;
            }

            update() {
                this.animation += 0.05;
            }

            checkCollision(player) {
                // Collision is handled by the goal platform itself
                return false;
            }

            draw() {
                // Goal is drawn as part of the platform - nothing to draw here
            }
        }

        // Platform class
        class Platform {
            constructor(x, y, width, height, color, kind = 'photo') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.kind = kind;
            }

            draw() {
                // Special glow effect for goal platform
                if (this.kind === 'goal' && goal) {
                    const glowIntensity = 0.7 + Math.sin(goal.animation * 2) * 0.3;
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 15 * glowIntensity;
                } else {
                    // Draw shadow for entire platform
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(this.x + 2, this.y + 2, this.width, this.height);
                }
                
                // Draw platforms as a series of connected square blocks
                const numBlocks = Math.floor(this.width / BLOCK_SIZE);
                
                // Draw individual blocks
                for (let i = 0; i < numBlocks; i++) {
                    const blockX = this.x + (i * BLOCK_SIZE);
                    const blockY = this.y;
                    
                    // Main block fill
                    ctx.fillStyle = this.color;
                    ctx.fillRect(blockX, blockY, BLOCK_SIZE, this.height);
                    
                    // Block outline
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(blockX, blockY, BLOCK_SIZE, this.height);
                    
                    // Top highlight for each block
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(blockX + 1, blockY + 1);
                    ctx.lineTo(blockX + BLOCK_SIZE - 1, blockY + 1);
                    ctx.stroke();
                }
                
                // Handle remaining width (partial block at end)
                const remainingWidth = this.width - (numBlocks * BLOCK_SIZE);
                if (remainingWidth > 0) {
                    const blockX = this.x + (numBlocks * BLOCK_SIZE);
                    const blockY = this.y;
                    
                    ctx.fillStyle = this.color;
                    ctx.fillRect(blockX, blockY, remainingWidth, this.height);
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(blockX, blockY, remainingWidth, this.height);
                }
                
                // Reset shadow
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }

        // Letter class for collectible letters
        class Letter {
            constructor(char, x, y, index) {
                this.char = char;
                this.x = x;
                this.y = y;
                this.width = COLLECTIBLE_LETTER_SIZE;
                this.height = COLLECTIBLE_LETTER_SIZE;
                this.collected = false;
                this.index = index;  // Position in the target word
                this.animation = 0;
            }

            update() {
                // Increment animation for floating effect
                this.animation += COLLECTIBLE_LETTER_FLOAT_SPEED;
            }

            checkCollision(player) {
                return !this.collected &&
                       player.x < this.x + this.width &&
                       player.x + player.width > this.x &&
                       player.y < this.y + this.height &&
                       player.y + player.height > this.y;
            }

            draw() {
                if (this.collected) return;

                // Floating animation
                const floatOffset = Math.sin(this.animation) * 3;
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2 + floatOffset;

                // Draw circular background with glow
                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, COLLECTIBLE_LETTER_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();

                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Draw black outline
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, COLLECTIBLE_LETTER_SIZE / 2, 0, Math.PI * 2);
                ctx.stroke();

                // Draw the letter
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.char, centerX, centerY);
            }
        }

        // ==========================================
        // ONNX ML Detection Functions
        // ==========================================

        // Lazy-load ONNX Runtime with fallback URLs
        async function loadONNXRuntime() {
            if (typeof ort !== 'undefined') {
                // Already loaded, just ensure WASM path is set
                if (!ort.env.wasm.wasmPaths) {
                    ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/';
                }
                return true;
            }
            
            for (const runtimeUrl of ONNX_RUNTIME_URLS) {
                try {
                    console.log('Attempting to load ONNX Runtime from:', runtimeUrl);
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = runtimeUrl;
                        script.onload = () => resolve(true);
                        script.onerror = () => reject(new Error(`Failed to load from ${runtimeUrl}`));
                        document.head.appendChild(script);
                    });
                    
                    // Wait a bit for ort to become available (async initialization)
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Verify ort is available after script loads
                    if (typeof ort !== 'undefined') {
                        console.log('ONNX Runtime loaded successfully from:', runtimeUrl);
                        
                        // Configure WASM paths - point to the same location as the runtime
                        if (runtimeUrl.includes('://')) {
                            // CDN - point to CDN for WASM files
                            const cdnBase = runtimeUrl.substring(0, runtimeUrl.lastIndexOf('/') + 1);
                            ort.env.wasm.wasmPaths = cdnBase;
                            console.log('ONNX WASM path set to CDN:', ort.env.wasm.wasmPaths);
                        } else {
                            // Local - point to local lib folder
                            ort.env.wasm.wasmPaths = 'lib/';
                            console.log('ONNX WASM path set to local:', ort.env.wasm.wasmPaths);
                        }
                        
                        // Set number of threads for better performance
                        ort.env.wasm.numThreads = 1;
                        
                        return true;
                    }
                } catch (err) {
                    console.error('Failed to load ONNX Runtime from:', runtimeUrl);
                    console.error('Error details:', err);
                    // Continue to next URL
                }
            }
            
            throw new Error('Failed to load ONNX Runtime from all sources');
        }

        // Initialize ONNX model (lazy load with fallback URLs)
        async function initONNXModel() {
            if (onnxSession) return true;
            if (onnxModelLoading) return false;
            if (onnxLoadError) return false;
            
            onnxModelLoading = true;
            updateMLStatus('Loading runtime...');
            
            try {
                // Load ONNX runtime first
                await loadONNXRuntime();
                updateMLStatus('Loading model...');
                
                // Try each model URL until one works
                let lastError = null;
                for (const modelUrl of ML_MODEL_URLS) {
                    try {
                        updateMLStatus(`Trying ${modelUrl.includes('://') ? 'CDN' : 'local'} model...`);
                        console.log('Attempting to load model from:', modelUrl);
                        
                        onnxSession = await ort.InferenceSession.create(modelUrl, {
                            executionProviders: ['wasm'],
                            graphOptimizationLevel: 'all'
                        });
                        
                        onnxModelLoaded = true;
                        onnxModelLoading = false;
                        updateMLStatus('ML ready');
                        console.log('ONNX model loaded successfully from:', modelUrl);
                        return true;
                    } catch (urlError) {
                        console.error(`Failed to load model from ${modelUrl}:`, urlError);
                        console.error('Error stack:', urlError.stack);
                        lastError = urlError;
                        // Continue to try next URL
                    }
                }
                
                // All URLs failed
                throw lastError || new Error('All model URLs failed');
            } catch (err) {
                onnxLoadError = err;
                onnxModelLoading = false;
                onnxModelLoaded = false;
                updateMLStatus('ML failed - see console');
                console.error('Failed to load ML detection:', err);
                console.info('=== ML Detection Troubleshooting ===');
                console.info('The app is running via HTTPS/web server (good!)');
                console.info('ML assets are loading from CDN (no downloads needed).');
                console.info('');
                console.info('Possible issues:');
                console.info('1. CDN temporarily unavailable - try refreshing');
                console.info('2. Network/firewall blocking CDN - check connection');
                console.info('3. Browser compatibility - try Chrome/Edge');
                console.info('');
                console.info('CDN URLs tried:');
                console.info('- Runtime: https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/');
                console.info('- Model: https://cdn.jsdelivr.net/gh/aspect-technology/yolov8-onnx@main/');
                console.info('');
                console.info('See docs/ONNX_SETUP.md for full troubleshooting guide.');
                return false;
            }
        }

        // Update ML status indicator
        function updateMLStatus(text) {
            const mlStatusEl = document.getElementById('mlStatus');
            if (mlStatusEl) {
                mlStatusEl.textContent = text ? ` (${text})` : '';
            }
        }

        // Preprocess image for YOLO model input
        function preprocessImageForYOLO(imageData, width, height) {
            // Create a temporary canvas to resize image to ML_INPUT_SIZE x ML_INPUT_SIZE
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = ML_INPUT_SIZE;
            tempCanvas.height = ML_INPUT_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw with letterboxing to maintain aspect ratio
            const scale = Math.min(ML_INPUT_SIZE / width, ML_INPUT_SIZE / height);
            const scaledWidth = Math.floor(width * scale);
            const scaledHeight = Math.floor(height * scale);
            const offsetX = Math.floor((ML_INPUT_SIZE - scaledWidth) / 2);
            const offsetY = Math.floor((ML_INPUT_SIZE - scaledHeight) / 2);
            
            // Fill with gray (letterbox padding)
            tempCtx.fillStyle = '#808080';
            tempCtx.fillRect(0, 0, ML_INPUT_SIZE, ML_INPUT_SIZE);
            
            // Draw the resized image centered
            tempCtx.drawImage(previewCanvas, 0, 0, width, height, offsetX, offsetY, scaledWidth, scaledHeight);
            
            // Get pixel data
            const resizedData = tempCtx.getImageData(0, 0, ML_INPUT_SIZE, ML_INPUT_SIZE).data;
            
            // Convert to normalized float32 tensor [1, 3, 640, 640] (NCHW format)
            const inputSize = ML_INPUT_SIZE * ML_INPUT_SIZE;
            const float32Data = new Float32Array(3 * inputSize);
            
            for (let i = 0; i < inputSize; i++) {
                const pixelIndex = i * 4;
                // Normalize to [0, 1]
                float32Data[i] = resizedData[pixelIndex] / 255.0;                    // R channel
                float32Data[i + inputSize] = resizedData[pixelIndex + 1] / 255.0;   // G channel
                float32Data[i + 2 * inputSize] = resizedData[pixelIndex + 2] / 255.0; // B channel
            }
            
            return {
                tensor: new ort.Tensor('float32', float32Data, [1, 3, ML_INPUT_SIZE, ML_INPUT_SIZE]),
                scale,
                offsetX,
                offsetY
            };
        }

        // Run YOLO inference and extract bounding boxes
        async function detectObjectsWithONNX(width, height) {
            if (!onnxSession) return [];
            
            try {
                const startTime = performance.now();
                
                // Preprocess image
                const { tensor, scale, offsetX, offsetY } = preprocessImageForYOLO(null, width, height);
                
                // Run inference with timeout (clean up timeout when inference completes)
                let timeoutId;
                const timeoutPromise = new Promise((_, reject) => {
                    timeoutId = setTimeout(() => reject(new Error('Inference timeout')), ML_INFERENCE_TIMEOUT_MS);
                });
                
                try {
                    const results = await Promise.race([
                        onnxSession.run({ images: tensor }),
                        timeoutPromise
                    ]);
                    clearTimeout(timeoutId);
                    
                    const inferenceTime = performance.now() - startTime;
                    console.log(`ONNX inference completed in ${inferenceTime.toFixed(0)}ms`);
                    
                    // Process YOLO output - different models use different output names
                    const output = results.predictions || results.output0 || results[Object.keys(results)[0]];
                    
                    if (!output) {
                        console.error('No valid output found. Available keys:', Object.keys(results));
                        return [];
                    }
                    
                    console.log('Using output tensor with dims:', output.dims);
                    
                    const detections = processYOLOOutput(output, width, height, scale, offsetX, offsetY);
                    
                    return detections;
                } catch (inferErr) {
                    clearTimeout(timeoutId);
                    throw inferErr;
                }
            } catch (err) {
                console.warn('ONNX inference failed:', err);
                return [];
            }
        }

        // Process YOLO v8 output format [1, 84, 8400] -> bounding boxes
        function processYOLOOutput(output, originalWidth, originalHeight, scale, offsetX, offsetY) {
            if (!output) {
                console.error('Output is undefined');
                return [];
            }
            
            // ONNX Runtime Web returns tensors, need to get data from cpuData or data
            const data = output.cpuData || output.data;
            
            if (!data) {
                console.error('Output data is undefined. Output:', output);
                console.error('Available properties:', Object.keys(output));
                return [];
            }
            
            const dims = output.dims;
            if (!dims || dims.length !== 3) {
                console.error('Invalid output dimensions:', dims);
                return [];
            }
            
            const [batch, features, numBoxes] = dims; // Expected: [1, 84, 8400]
            console.log(`Processing YOLO output: ${batch}x${features}x${numBoxes}`);
            
            const detections = [];
            
            // YOLOv8 output format: first 4 values are [cx, cy, w, h], remaining 80 are class probabilities
            for (let i = 0; i < numBoxes; i++) {
                // Extract box coordinates (cx, cy, w, h)
                const cx = data[i];
                const cy = data[numBoxes + i];
                const w = data[2 * numBoxes + i];
                const h = data[3 * numBoxes + i];
                
                // Find the class with highest probability
                let maxProb = 0;
                let maxClass = 0;
                for (let c = 0; c < 80; c++) {
                    const prob = data[(4 + c) * numBoxes + i];
                    if (prob > maxProb) {
                        maxProb = prob;
                        maxClass = c;
                    }
                }
                
                // Filter by confidence threshold
                if (maxProb < ML_CONFIDENCE_THRESHOLD) continue;
                
                // Convert from letterboxed coordinates to original image coordinates
                const x1 = (cx - w / 2 - offsetX) / scale;
                const y1 = (cy - h / 2 - offsetY) / scale;
                const boxW = w / scale;
                const boxH = h / scale;
                
                // Clamp to image bounds
                const clampedX = Math.max(0, Math.min(x1, originalWidth - 1));
                const clampedY = Math.max(0, Math.min(y1, originalHeight - 1));
                const clampedW = Math.min(boxW, originalWidth - clampedX);
                const clampedH = Math.min(boxH, originalHeight - clampedY);
                
                if (clampedW < ML_MIN_DETECTION_SIZE || clampedH < ML_MIN_DETECTION_SIZE) continue;
                
                const className = COCO_CLASSES[maxClass] || 'unknown';
                
                detections.push({
                    class: className,
                    classId: maxClass,
                    confidence: maxProb,
                    bbox: [clampedX, clampedY, clampedW, clampedH],
                    isPlatformable: PLATFORMABLE_CLASSES.includes(className)
                });
            }
            
            // Apply Non-Maximum Suppression (NMS)
            return applyNMS(detections, 0.45);
        }

        // Non-Maximum Suppression to remove overlapping detections
        function applyNMS(detections, iouThreshold) {
            // Sort by confidence (descending)
            detections.sort((a, b) => b.confidence - a.confidence);
            
            const kept = [];
            const suppressed = new Set();
            
            for (let i = 0; i < detections.length; i++) {
                if (suppressed.has(i)) continue;
                
                kept.push(detections[i]);
                
                for (let j = i + 1; j < detections.length; j++) {
                    if (suppressed.has(j)) continue;
                    
                    const iou = calculateIoU(detections[i].bbox, detections[j].bbox);
                    if (iou > iouThreshold) {
                        suppressed.add(j);
                    }
                }
            }
            
            return kept;
        }

        // Calculate Intersection over Union (IoU) between two bounding boxes
        function calculateIoU(box1, box2) {
            const [x1, y1, w1, h1] = box1;
            const [x2, y2, w2, h2] = box2;
            
            const interX1 = Math.max(x1, x2);
            const interY1 = Math.max(y1, y2);
            const interX2 = Math.min(x1 + w1, x2 + w2);
            const interY2 = Math.min(y1 + h1, y2 + h2);
            
            const interW = Math.max(0, interX2 - interX1);
            const interH = Math.max(0, interY2 - interY1);
            const interArea = interW * interH;
            
            const area1 = w1 * h1;
            const area2 = w2 * h2;
            const unionArea = area1 + area2 - interArea;
            
            return unionArea > 0 ? interArea / unionArea : 0;
        }

        // Map detected objects to platform surfaces (top-edge for standing)
        function mapObjectsToPlatforms(detections, canvasWidth, canvasHeight) {
            const platformCandidates = [];
            
            for (const detection of detections) {
                const [x, y, w, h] = detection.bbox;
                
                // Use TOP edge as platform surface with block-aligned dimensions
                const platformY = y;
                const platformX = x;
                
                // Align width to block boundaries
                const blockCount = Math.max(2, Math.ceil(w / BLOCK_SIZE));  // At least 2 blocks
                const platformWidth = blockCount * BLOCK_SIZE;
                const platformHeight = BLOCK_SIZE;  // One block tall
                
                // Skip if platform would be in reserved areas
                const isStartArea = (platformX < START_AREA_WIDTH && platformY > canvasHeight - START_AREA_HEIGHT);
                const isGoalArea = (platformX > canvasWidth - GOAL_AREA_WIDTH && platformY < GOAL_AREA_HEIGHT);
                const isWordBarArea = (platformY < WORD_BAR_AREA_HEIGHT);
                if (isStartArea || isGoalArea || isWordBarArea) continue;
                
                // Skip if platform is too small
                if (platformWidth < PLATFORM_MIN_WIDTH) continue;
                
                // Skip if platform is outside canvas bounds
                if (platformY < 0 || platformY > canvasHeight - platformHeight) continue;
                if (platformX + platformWidth > canvasWidth) continue;
                
                // Semi-transparent platforms that show the photo underneath
                let color;
                if (detection.isPlatformable) {
                    color = 'rgba(60, 150, 80, 0.85)';
                } else {
                    color = 'rgba(80, 100, 160, 0.85)';
                }
                
                platformCandidates.push({
                    x: platformX,
                    y: platformY,
                    width: platformWidth,
                    height: platformHeight,
                    color: color,
                    source: 'ml-detection',
                    detection: detection
                });
            }
            
            // Merge nearby platforms to reduce clutter
            return mergePlatformCandidates(platformCandidates);
        }

        // Merge platform candidates that are on similar Y levels and close horizontally
        function mergePlatformCandidates(candidates) {
            if (candidates.length === 0) return [];
            
            // Sort by Y then X
            candidates.sort((a, b) => a.y - b.y || a.x - b.x);
            
            const merged = [];
            let current = { ...candidates[0] };
            
            for (let i = 1; i < candidates.length; i++) {
                const next = candidates[i];
                
                // Merge if on same Y level (within tolerance) and horizontally adjacent/overlapping
                const sameRow = Math.abs(next.y - current.y) < PLATFORM_THICKNESS;
                const adjacent = next.x <= current.x + current.width + PLATFORM_MERGE_GAP_PX + ML_PLATFORM_MERGE_TOLERANCE;
                
                if (sameRow && adjacent) {
                    // Extend current platform
                    const newRight = Math.max(current.x + current.width, next.x + next.width);
                    current.width = newRight - current.x;
                } else {
                    merged.push(current);
                    current = { ...next };
                }
            }
            merged.push(current);
            
            return merged;
        }

        // ==========================================
        // End ONNX ML Detection Functions
        // ==========================================

        // Helper functions for reachability checking
        function intervalGap(a1, a2, b1, b2) {
            if (a2 < b1) return b1 - a2;
            if (b2 < a1) return a1 - b2;
            return 0;
        }

        function getJumpLimits() {
            const jumpPower = PLAYER_JUMP_POWER;
            const gravity = PLAYER_GRAVITY;
            const speed = PLAYER_SPEED;

            const maxJumpUp = (jumpPower * jumpPower) / (2 * gravity);
            const maxHangTime = (2 * jumpPower) / gravity;
            const maxJumpDx = speed * maxHangTime;

            // Conservative safety margins (gameplay-first): if we say reachable, it should be reachable.
            // Increased margins to be more generous and ensure better level traversability
            return {
                maxJumpUp: maxJumpUp * 0.95,  // Increased from 0.9 for more vertical reach
                maxJumpDx: maxJumpDx * 0.90,  // Increased from 0.85 for more horizontal reach
                jumpPower,
                gravity,
                speed
            };
        }

        function canReachPlatform(from, to, limits) {
            if (from === to) return false;

            const fromLeft = from.x;
            const fromRight = from.x + from.width;
            const toLeft = to.x;
            const toRight = to.x + to.width;

            const dx = intervalGap(fromLeft, fromRight, toLeft, toRight);
            if (dx > limits.maxJumpDx) return false;

            const up = from.y - to.y;
            if (up <= 0) {
                // Dropping down is allowed; keep conservative horizontal requirement only.
                return true;
            }

            if (up > limits.maxJumpUp) return false;

            // More accurate horizontal limit for higher targets: time to reach that height (descending).
            const disc = (limits.jumpPower * limits.jumpPower) - (2 * limits.gravity * up);
            if (disc < 0) return false;
            const tLanding = (limits.jumpPower + Math.sqrt(disc)) / limits.gravity;
            const dxLimit = Math.min(limits.maxJumpDx, limits.speed * tLanding * 0.9);
            return dx <= dxLimit;
        }

        function isReachable(startPlatform, goalPlatform, allPlatforms, limits) {
            const visited = new Set();
            const queue = [startPlatform];
            visited.add(startPlatform);

            while (queue.length) {
                const current = queue.shift();
                if (current === goalPlatform) return true;

                for (const next of allPlatforms) {
                    if (visited.has(next)) continue;
                    if (!canReachPlatform(current, next, limits)) continue;
                    visited.add(next);
                    queue.push(next);
                }
            }

            return false;
        }

        function overlapsAny(candidate, allPlatforms) {
            for (const p of allPlatforms) {
                const overlaps = !(candidate.x + candidate.width <= p.x ||
                    candidate.x >= p.x + p.width ||
                    candidate.y + candidate.height <= p.y ||
                    candidate.y >= p.y + p.height);
                if (overlaps) return true;
            }
            return false;
        }

        // Process image and create platforms
        async function processImage(image) {
            // Store the image for background rendering
            backgroundImage = image;

            // Set canvas size based on image aspect ratio
            const maxWidth = 800;
            const maxHeight = 600;
            let width = image.width;
            let height = image.height;

            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }

            canvas.width = width;
            canvas.height = height;
            previewCanvas.width = width;
            previewCanvas.height = height;

            // Draw image to preview canvas
            previewCtx.drawImage(image, 0, 0, width, height);
            const imageData = previewCtx.getImageData(0, 0, width, height);
            const data = imageData.data;

            // Create platforms based on brightness and edge detection
            platforms = [];
            const gridSize = GRID_SIZE;
            const brightnessThreshold = BRIGHTNESS_THRESHOLD;

            debugGridSize = gridSize;
            debugHelperPlatforms = [];
            debugSolidGrid = null;
            debugDetectedObjects = [];

            // Helper function to detect edges (helps identify objects better)
            function hasEdge(x, y, width, height, data) {
                // Allow edge detection near boundaries, just need 1-pixel neighbors
                if (x === 0 || y === 0 || x + 1 >= width || y + 1 >= height) {
                    return false;
                }
                
                // Get center brightness
                const centerI = (y * width + x) * 4;
                const centerBrightness = (data[centerI] + data[centerI + 1] + data[centerI + 2]) / 3;
                
                // Check brightness difference with adjacent neighbors (1 pixel away)
                let maxDiff = 0;
                const checkPositions = [
                    [x - 1, y], [x + 1, y],
                    [x, y - 1], [x, y + 1]
                ];
                
                for (const [px, py] of checkPositions) {
                    if (px >= 0 && px < width && py >= 0 && py < height) {
                        const i = (py * width + px) * 4;
                        const neighborBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const diff = Math.abs(centerBrightness - neighborBrightness);
                        maxDiff = Math.max(maxDiff, diff);
                    }
                }
                // Significant brightness difference indicates an edge
                return maxDiff > EDGE_DETECTION_THRESHOLD;
            }

            function buildSolidGrid() {
                const cellsX = Math.ceil(width / gridSize);
                const cellsY = Math.ceil(height / gridSize);
                const solid = Array.from({ length: cellsY }, () => Array.from({ length: cellsX }, () => false));
                const brightness = Array.from({ length: cellsY }, () => Array.from({ length: cellsX }, () => 255));

                for (let cy = 0; cy < cellsY; cy++) {
                    for (let cx = 0; cx < cellsX; cx++) {
                        const x = cx * gridSize;
                        const y = cy * gridSize;

                        let totalBrightness = 0;
                        let pixelCount = 0;

                        // Calculate average brightness of grid cell
                        for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
                            for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4;
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                const bness = (r + g + b) / 3;
                                totalBrightness += bness;
                                pixelCount++;
                            }
                        }

                        const avgBrightness = pixelCount > 0 ? (totalBrightness / pixelCount) : 255;
                        brightness[cy][cx] = avgBrightness;

                        // Create solid hint if brightness is below threshold OR at edges (better object detection)
                        const isEdge = hasEdge(x, y, width, height, data);

                        // Reserve start area (bottom-left), goal area (top-right), and word bar area (top) - don't generate photo platforms there
                        const isStartArea = (x < START_AREA_WIDTH && y > height - START_AREA_HEIGHT);
                        const isGoalArea = (x > width - GOAL_AREA_WIDTH && y < GOAL_AREA_HEIGHT);
                        const isWordBarArea = (y < WORD_BAR_AREA_HEIGHT);

                        const isSolidHint = (!isStartArea && !isGoalArea && !isWordBarArea) &&
                            (avgBrightness < brightnessThreshold || (isEdge && avgBrightness < EDGE_BRIGHTNESS_THRESHOLD));

                        solid[cy][cx] = Boolean(isSolidHint);
                    }
                }

                return { solid, brightness, cellsX, cellsY };
            }

            function platformColorFromBrightness(avgBrightness) {
                // Solid semi-opaque blocks for clear gameplay experience
                const alpha = 0.85;
                const colorValue = Math.floor(avgBrightness * 0.6);
                return `rgba(${colorValue}, ${colorValue}, ${colorValue}, ${alpha})`;
            }

            function extractTopSurfacesFromGrid(grid) {
                const { solid, brightness, cellsX, cellsY } = grid;
                const segments = [];

                // Extract top surfaces only - keep air space clear for navigation
                for (let cy = 0; cy < cellsY; cy++) {
                    for (let cx = 0; cx < cellsX; cx++) {
                        if (!solid[cy][cx]) continue;
                        const aboveSolid = (cy > 0) ? solid[cy - 1][cx] : false;
                        if (aboveSolid) continue;

                        const x = cx * gridSize;
                        const y = cy * gridSize;
                        const w = Math.min(gridSize, width - x);
                        if (w <= 0) continue;

                        segments.push({
                            x,
                            y,
                            width: w,
                            brightness: brightness[cy][cx]
                        });
                    }
                }

                // Merge adjacent segments on the same y into longer platforms
                const merged = [];
                let current = null;

                for (const seg of segments) {
                    if (!current) {
                        current = { ...seg };
                        continue;
                    }

                    const touchesSameRow = seg.y === current.y;
                    const isAdjacent = seg.x <= (current.x + current.width + PLATFORM_MERGE_GAP_PX);

                    if (touchesSameRow && isAdjacent) {
                        const end = Math.max(current.x + current.width, seg.x + seg.width);
                        const totalWidth = end - current.x;
                        const weightedBrightness = ((current.brightness * current.width) + (seg.brightness * seg.width)) / (current.width + seg.width);
                        current.width = totalWidth;
                        current.brightness = weightedBrightness;
                    } else {
                        merged.push(current);
                        current = { ...seg };
                    }
                }
                if (current) merged.push(current);

                // Convert to platform objects with block-aligned dimensions
                const platformsOut = [];
                for (const m of merged) {
                    if (m.width < PLATFORM_MIN_WIDTH) continue;
                    
                    // Align platform width to block boundaries for clean appearance
                    const blockCount = Math.ceil(m.width / BLOCK_SIZE);
                    const alignedWidth = blockCount * BLOCK_SIZE;
                    
                    const platformHeight = BLOCK_SIZE;  // One block tall
                    const color = platformColorFromBrightness(m.brightness);
                    const mainPlatform = new Platform(m.x, m.y, Math.min(alignedWidth, width - m.x), platformHeight, color, 'photo');
                    platformsOut.push(mainPlatform);
                    
                    // Add wall blocks at the ends of platforms for better climbing
                    // Left wall block
                    if (m.x >= BLOCK_SIZE && mainPlatform.width >= BLOCK_SIZE * 3) {
                        platformsOut.push(new Platform(
                            m.x, 
                            m.y - BLOCK_SIZE, 
                            BLOCK_SIZE, 
                            BLOCK_SIZE, 
                            color, 
                            'photo'
                        ));
                    }
                    // Right wall block
                    if (mainPlatform.x + mainPlatform.width + BLOCK_SIZE <= width && mainPlatform.width >= BLOCK_SIZE * 3) {
                        platformsOut.push(new Platform(
                            mainPlatform.x + mainPlatform.width - BLOCK_SIZE, 
                            m.y - BLOCK_SIZE, 
                            BLOCK_SIZE, 
                            BLOCK_SIZE, 
                            color, 
                            'photo'
                        ));
                    }
                }

                // Filter out platforms that are too close vertically (minimum 1 block spacing)
                return filterVerticallyClashingPlatforms(platformsOut);
            }
            
            // Remove platforms that are stacked too closely vertically
            function filterVerticallyClashingPlatforms(platforms) {
                const minVerticalGap = BLOCK_SIZE;  // At least 1 block spacing
                const filtered = [];
                
                // Sort by Y position
                const sorted = [...platforms].sort((a, b) => a.y - b.y);
                
                for (let i = 0; i < sorted.length; i++) {
                    const current = sorted[i];
                    let tooClose = false;
                    
                    // Check if there's a platform directly below that's too close
                    for (let j = i + 1; j < sorted.length; j++) {
                        const below = sorted[j];
                        
                        // Check if they overlap horizontally
                        const horizontalOverlap = !(current.x + current.width <= below.x || below.x + below.width <= current.x);
                        
                        if (horizontalOverlap) {
                            const verticalGap = below.y - (current.y + current.height);
                            
                            if (verticalGap < minVerticalGap) {
                                tooClose = true;
                                break;
                            }
                            // Once we find the first platform below with overlap, we can stop checking
                            break;
                        }
                    }
                    
                    if (!tooClose) {
                        filtered.push(current);
                    }
                }
                
                return filtered;
            }

            function addHelperPlatformsIfNeeded(startPlatform, goalSupportPlatform, allPlatforms, limits) {
                if (isReachable(startPlatform, goalSupportPlatform, allPlatforms, limits)) {
                    return;
                }

                // Use smaller, more flexible helper blocks
                const helperWidthOptions = [BLOCK_SIZE * 3, BLOCK_SIZE * 2];  // 60px, 40px - smaller for tighter spaces
                const helperHeight = BLOCK_SIZE;
                const helperColor = 'rgba(80, 120, 255, 0.9)';

                let current = startPlatform;
                let added = 0;
                let failedAttempts = 0;
                const maxFailedAttempts = 5;

                while (added < HELPERS_MAX_COUNT && failedAttempts < maxFailedAttempts) {
                    if (isReachable(startPlatform, goalSupportPlatform, allPlatforms, limits)) return;

                    const currentCenter = current.x + current.width / 2;
                    const goalCenter = goalSupportPlatform.x + goalSupportPlatform.width / 2;

                    const toward = Math.sign(goalCenter - currentCenter) || 1;
                    const stepX = limits.maxJumpDx * 0.55;  // Even smaller horizontal steps
                    const stepUp = limits.maxJumpUp * 0.45;  // Even smaller vertical steps for gradual climb

                    const targetY = Math.max(WORD_BAR_AREA_HEIGHT, current.y - stepUp);
                    
                    // Try different helper widths to find one that fits
                    let placed = false;
                    
                    for (const helperWidth of helperWidthOptions) {
                        if (placed) break;
                        
                        const idealX = currentCenter + toward * stepX - (helperWidth / 2);
                        let targetX = Math.max(0, Math.min(width - helperWidth, idealX));

                        const wouldBeInGoalArea = (targetX > width - GOAL_AREA_WIDTH && targetY < GOAL_AREA_HEIGHT);
                        if (wouldBeInGoalArea) {
                            targetX = Math.max(0, width - GOAL_AREA_WIDTH - helperWidth - 10);
                        }

                        const candidate = new Platform(targetX, targetY, helperWidth, helperHeight, helperColor, 'helper');

                        if (!overlapsAny(candidate, allPlatforms)) {
                            allPlatforms.push(candidate);
                            debugHelperPlatforms.push(candidate);
                            current = candidate;
                            placed = true;
                            failedAttempts = 0;  // Reset failed attempts on success
                            break;
                        }
                        
                        // Try shifting left and right with current width
                        for (let offset = BLOCK_SIZE; offset <= BLOCK_SIZE * 10; offset += BLOCK_SIZE) {
                            const leftX = Math.max(0, targetX - offset);
                            const rightX = Math.min(width - helperWidth, targetX + offset);

                            const leftCandidate = new Platform(leftX, targetY, helperWidth, helperHeight, helperColor, 'helper');
                            if (!overlapsAny(leftCandidate, allPlatforms)) {
                                allPlatforms.push(leftCandidate);
                                debugHelperPlatforms.push(leftCandidate);
                                current = leftCandidate;
                                placed = true;
                                failedAttempts = 0;
                                break;
                            }

                            const rightCandidate = new Platform(rightX, targetY, helperWidth, helperHeight, helperColor, 'helper');
                            if (!overlapsAny(rightCandidate, allPlatforms)) {
                                allPlatforms.push(rightCandidate);
                                debugHelperPlatforms.push(rightCandidate);
                                current = rightCandidate;
                                placed = true;
                                failedAttempts = 0;
                                break;
                            }
                        }
                    }

                    if (!placed) {
                        // Try stepping horizontally at same height
                        const horizontalHelper = new Platform(
                            currentCenter + toward * (BLOCK_SIZE * 3), 
                            current.y, 
                            BLOCK_SIZE * 2, 
                            helperHeight, 
                            helperColor, 
                            'helper'
                        );
                        
                        if (!overlapsAny(horizontalHelper, allPlatforms) && 
                            horizontalHelper.x >= 0 && 
                            horizontalHelper.x + horizontalHelper.width <= width) {
                            allPlatforms.push(horizontalHelper);
                            debugHelperPlatforms.push(horizontalHelper);
                            current = horizontalHelper;
                            placed = true;
                            failedAttempts = 0;
                        } else {
                            // Try going down instead of up
                            const downHelper = new Platform(
                                currentCenter + toward * stepX - BLOCK_SIZE,
                                Math.min(height - helperHeight - 20, current.y + stepUp),
                                BLOCK_SIZE * 2,
                                helperHeight,
                                helperColor,
                                'helper'
                            );
                            
                            if (!overlapsAny(downHelper, allPlatforms) &&
                                downHelper.x >= 0 &&
                                downHelper.x + downHelper.width <= width &&
                                downHelper.y >= WORD_BAR_AREA_HEIGHT) {
                                allPlatforms.push(downHelper);
                                debugHelperPlatforms.push(downHelper);
                                current = downHelper;
                                placed = true;
                                failedAttempts = 0;
                            } else {
                                // Last resort: try placing a stepping stone closer to current platform
                                const closeHelper = new Platform(
                                    currentCenter + toward * (BLOCK_SIZE * 2),
                                    current.y - (BLOCK_SIZE * 2),
                                    BLOCK_SIZE * 2,
                                    helperHeight,
                                    helperColor,
                                    'helper'
                                );
                                
                                if (!overlapsAny(closeHelper, allPlatforms) &&
                                    closeHelper.x >= 0 &&
                                    closeHelper.x + closeHelper.width <= width &&
                                    closeHelper.y >= WORD_BAR_AREA_HEIGHT) {
                                    allPlatforms.push(closeHelper);
                                    debugHelperPlatforms.push(closeHelper);
                                    current = closeHelper;
                                    placed = true;
                                    failedAttempts = 0;
                                } else {
                                    failedAttempts++;
                                }
                            }
                        }
                    }

                    if (placed) {
                        added++;
                    }
                }
                
                console.log(`Added ${added} helper platforms (failed attempts: ${failedAttempts})`);
            }

            // Build grid-based platforms (always run as baseline/fallback)
            const grid = buildSolidGrid();
            debugSolidGrid = grid.solid;
            let gridBasedPlatforms = extractTopSurfacesFromGrid(grid);

            // Try ML-based object detection if enabled
            let mlPlatforms = [];
            if (mlDetectionEnabled && onnxModelLoaded && onnxSession) {
                console.log('ü§ñ Running ML object detection...');
                try {
                    updateMLStatus('Detecting objects...');
                    const detections = await detectObjectsWithONNX(width, height);
                    debugDetectedObjects = detections;
                    
                    console.log(`ML detection found ${detections.length} total objects`);
                    
                    // Log all detections for debugging
                    if (detections.length > 0) {
                        console.log('Detected objects:', detections.map(d => 
                            `${d.class} (${(d.confidence * 100).toFixed(1)}%) ${d.isPlatformable ? '‚úì platformable' : '‚úó not platformable'}`
                        ).join(', '));
                    }
                    
                    
                    // Convert ALL detected objects to platforms for smooth gameplay
                    // This ensures maximum platform coverage and better level traversability
                    if (detections.length > 0) {
                        mlPlatforms = mapObjectsToPlatforms(detections, width, height);
                        
                        // Convert ML platform candidates to Platform objects
                        mlPlatforms = mlPlatforms.map(p => 
                            new Platform(p.x, p.y, p.width, p.height, p.color, 'ml')
                        );
                        
                        // Count platformable detections for status display
                        const platformableCount = detections.filter(d => d.isPlatformable).length;
                        updateMLStatus(`${detections.length} objects ‚Üí platforms (${platformableCount} platformable)`);
                    } else {
                        console.log('‚ÑπÔ∏è No objects detected. Try photos with furniture, vehicles, or electronics.');
                        console.log('   Platformable objects: chairs, tables, couches, cars, laptops, etc.');
                        console.log('   Note: Buildings/architecture are not detected - use grid-based detection for those.');
                        updateMLStatus('No objects detected');
                    }
                } catch (err) {
                    console.warn('ML detection failed during inference:', err);
                    updateMLStatus('Detection failed');
                }
            }

            // Combine platforms: ML platforms take priority, then grid-based fill gaps
            // If ML detection is enabled and found platforms, prioritize those
            if (mlDetectionEnabled && mlPlatforms.length > 0) {
                // Use ML platforms as primary, with grid-based as supplement
                platforms = [...mlPlatforms];
                
                // Add grid-based platforms that don't significantly overlap with ML platforms
                for (const gridPlatform of gridBasedPlatforms) {
                    let overlapsML = false;
                    for (const mlPlatform of mlPlatforms) {
                        const overlap = !(gridPlatform.x + gridPlatform.width < mlPlatform.x ||
                            gridPlatform.x > mlPlatform.x + mlPlatform.width ||
                            gridPlatform.y + gridPlatform.height < mlPlatform.y - ML_PLATFORM_OVERLAP_TOLERANCE_Y ||
                            gridPlatform.y > mlPlatform.y + mlPlatform.height + ML_PLATFORM_OVERLAP_TOLERANCE_Y);
                        if (overlap) {
                            overlapsML = true;
                            break;
                        }
                    }
                    if (!overlapsML) {
                        platforms.push(gridPlatform);
                    }
                }
            } else {
                // Fall back to grid-based only
                platforms = gridBasedPlatforms;
            }

            // Add a ground platform at the bottom (darker and more opaque)
            platforms.push(new Platform(0, height - 20, width, 20, 'rgba(100, 60, 20, 0.8)', 'ground'));

            // Add starting platform (green to indicate start, 5 blocks wide)
            const startPlatformY = height - 60;
            const startPlatform = new Platform(10, startPlatformY, BLOCK_SIZE * 5, BLOCK_SIZE, 'rgba(0, 180, 0, 0.9)', 'start');
            platforms.push(startPlatform);

            // Randomly select a goal location from suitable platforms
            // Goal should be: reachable, sufficiently far from start, preferably high up
            let goalSupportPlatform = null;
            let goalX, goalY;
            
            // Get candidate platforms for goal placement (photo/ml platforms in upper half)
            const candidateGoalPlatforms = platforms.filter(p => {
                if (p.kind !== 'photo' && p.kind !== 'ml') return false;
                // Prefer upper 60% of the level
                if (p.y > height * 0.6) return false;
                // Must not overlap with start area
                if (p.x < 150 && p.y > height - 150) return false;
                return true;
            });
            
            // If we have suitable candidates, pick one randomly
            if (candidateGoalPlatforms.length > 0) {
                // Sort by height (higher is better) and distance from start
                const startCenter = { x: 60, y: startPlatformY };
                candidateGoalPlatforms.sort((a, b) => {
                    // Calculate distance once for each platform
                    const aDistSq = (a.x - startCenter.x) ** 2 + (a.y - startCenter.y) ** 2;
                    const bDistSq = (b.x - startCenter.x) ** 2 + (b.y - startCenter.y) ** 2;
                    // Prefer high (negative y) + far (positive distance)
                    const aScore = -a.y * 2 + Math.sqrt(aDistSq);
                    const bScore = -b.y * 2 + Math.sqrt(bDistSq);
                    return bScore - aScore;
                });
                
                // Pick from top candidates randomly for variety
                const topCandidates = candidateGoalPlatforms.slice(0, Math.min(MAX_GOAL_CANDIDATES, candidateGoalPlatforms.length));
                const selectedPlatform = topCandidates[Math.floor(Math.random() * topCandidates.length)];
                
                // Create goal support platform
                goalPlatform = new Platform(
                    selectedPlatform.x + selectedPlatform.width / 2 - (BLOCK_SIZE * 1.5),
                    selectedPlatform.y - BLOCK_SIZE,
                    BLOCK_SIZE * 3, 
                    BLOCK_SIZE, 
                    'rgba(255, 200, 0, 0.9)', 
                    'goal'
                );
            } else {
                // Fallback to top-right if no suitable platforms found
                const goalX = width - 60;
                const goalY = 30;
                goalPlatform = new Platform(goalX, goalY + 60, BLOCK_SIZE * 3, BLOCK_SIZE, 'rgba(255, 200, 0, 0.9)', 'goal');
            }
            
            platforms.push(goalPlatform);
            goal = new Goal(0, 0);  // Just for animation tracking

            // Initialize player ON the start platform (not above it)
            playerSpawnY = startPlatformY - 20; // Player height is 20, so spawn on top of platform
            player = new Player(PLAYER_SPAWN_X, playerSpawnY);
            
            // Remove any photo-generated platforms that overlap with player spawn area
            // to ensure player never spawns inside a block
            const spawnCheckX = PLAYER_SPAWN_X - 10;
            const spawnCheckY = playerSpawnY - 10;
            const spawnCheckWidth = 40;  // Player width + buffer
            const spawnCheckHeight = 40; // Player height + buffer
            
            platforms = platforms.filter(platform => {
                // Keep non-photo/non-ml platforms (ground/start/goal/helper)
                if (platform.kind !== 'photo' && platform.kind !== 'ml') return true;

                // Remove photo/ml platforms that overlap with spawn area
                const overlaps = !(platform.x + platform.width < spawnCheckX ||
                    platform.x > spawnCheckX + spawnCheckWidth ||
                    platform.y + platform.height < spawnCheckY ||
                    platform.y > spawnCheckY + spawnCheckHeight);
                return !overlaps;
            });

            // Ensure the level is winnable: add helper platforms only when needed.
            const limits = getJumpLimits();
            addHelperPlatformsIfNeeded(startPlatform, goalSupportPlatform, platforms, limits);

            // Place collectible letters on platforms (pass limits and startPlatform for reachability check)
            placeLettersOnPlatforms(startPlatform, limits);

            // Start game
            startGame();
        }

        // Fisher-Yates shuffle algorithm for unbiased array shuffling
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Place letters on platforms to spell a word
        function placeLettersOnPlatforms(startPlatform, limits) {
            letters = [];
            collectedLetters = [];
            
            // Get platforms that are suitable for letter placement AND reachable from start
            // Exclude ground, start, goal platforms
            const suitablePlatforms = platforms.filter(p => {
                // Must be a photo/ml/helper platform (NOT goal)
                if (p.kind !== 'photo' && p.kind !== 'ml' && p.kind !== 'helper') {
                    return false;
                }
                
                // Don't place letters on goal platform
                if (p === goalPlatform) {
                    return false;
                }
                
                // Must be reachable from the start platform (including multi-hop paths)
                if (!isReachable(startPlatform, p, platforms, limits)) {
                    return false;
                }
                
                return true;
            });
            
            if (suitablePlatforms.length === 0) {
                console.warn('No suitable reachable platforms for letter placement');
                return;
            }
            
            // Choose a word that fits the available platforms
            // Filter words that have length <= number of suitable platforms
            const availableWords = WORD_DICTIONARY.filter(word => word.length <= suitablePlatforms.length);
            
            if (availableWords.length === 0) {
                // If no words fit (not enough reachable platforms), truncate the shortest word
                // to match the number of available platforms
                const baseWord = SHORTEST_WORD;
                targetWord = baseWord.substring(0, Math.min(baseWord.length, suitablePlatforms.length));
                
                // If still no platforms, exit early
                if (suitablePlatforms.length === 0 || targetWord.length === 0) {
                    console.warn('Not enough reachable platforms for any word');
                    return;
                }
            } else {
                targetWord = availableWords[Math.floor(Math.random() * availableWords.length)];
            }
            
            // Shuffle platforms using Fisher-Yates algorithm
            const shuffledPlatforms = shuffleArray(suitablePlatforms);
            
            // Place each letter of the word on different platforms (one letter per platform)
            for (let i = 0; i < targetWord.length; i++) {
                const platform = shuffledPlatforms[i];  // Direct indexing since word length <= platform count
                
                // Safety check: ensure platform exists
                // This should never happen due to filtering above, but we check defensively
                // to prevent crashes from undefined access
                if (!platform) {
                    console.error(`CRITICAL: Platform ${i} is undefined for letter ${targetWord[i]} - this indicates a bug in platform filtering`);
                    console.error(`Available platforms: ${suitablePlatforms.length}, Word length: ${targetWord.length}`);
                    continue;
                }
                
                // Place letter on top of platform, centered with some randomness
                const platformCenterX = platform.x + platform.width / 2;
                const randomOffsetX = (Math.random() - 0.5) * Math.min(
                    platform.width * COLLECTIBLE_LETTER_OFFSET_RATIO, 
                    COLLECTIBLE_LETTER_MAX_OFFSET
                );
                const letterX = platformCenterX + randomOffsetX - COLLECTIBLE_LETTER_SIZE / 2;
                const letterY = platform.y - COLLECTIBLE_LETTER_SIZE - COLLECTIBLE_LETTER_VERTICAL_OFFSET;
                
                letters.push(new Letter(targetWord[i], letterX, letterY, i));
            }
            
            console.log(`Placed ${letters.length} letters to spell: ${targetWord} on reachable platforms`);
        }

        // Start the game loop
        function startGame() {
            gameRunning = true;
            gameWon = false;  // Reset win state
            canvas.style.display = 'block';
            gameInfo.style.display = 'none';  // Hide old game info (we draw it on canvas now)
            resetBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'none';
            cameraBtn.style.display = 'none';
            
            score = 0;
            wordCompleteBonus = 0;
            correctOrderBonus = 0;
            startTime = Date.now();
            
            // Reset camera
            camera.x = 0;
            camera.y = 0;
            camera.zoom = 1.0;
            camera.targetX = 0;
            camera.targetY = 0;
            
            // Resize canvas to fill viewport
            resizeCanvas();
            
            // Enter fullscreen when game starts
            enterFullscreen();
            
            gameLoop();
        }

        // Resize canvas to fill viewport
        function resizeCanvas() {
            const container = document.querySelector('.game-canvas-container');
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        // Update camera to follow player
        function updateCamera() {
            if (!player) return;
            
            // Target camera position (center on player)
            camera.targetX = player.x + player.width / 2 - (canvas.width / camera.zoom) / 2;
            camera.targetY = player.y + player.height / 2 - (canvas.height / camera.zoom) / 2;
            
            // Smooth camera movement
            camera.x += (camera.targetX - camera.x) * camera.smoothing;
            camera.y += (camera.targetY - camera.y) * camera.smoothing;
            
            // Clamp camera to level bounds
            const viewportWidth = canvas.width / camera.zoom;
            const viewportHeight = canvas.height / camera.zoom;
            camera.x = Math.max(0, Math.min(camera.x, canvas.width - viewportWidth));
            camera.y = Math.max(0, Math.min(camera.y, canvas.height - viewportHeight));
        }

        // Main game loop
        function gameLoop() {
            if (!gameRunning) return;

            // Update camera position
            updateCamera();

            // Clear canvas
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Save context state
            ctx.save();
            
            // Apply camera transformation for game world
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            // Draw the photo as background in world space (so it zooms with camera)
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            }

            // Update and draw goal
            if (goal) {
                goal.update();
                goal.draw();
            }

            // Update and draw platforms
            for (let platform of platforms) {
                platform.draw();
            }

            if (debugOverlayEnabled && debugSolidGrid) {
                drawDebugOverlay();
            }

            // Update and draw letters (skip collected ones for performance)
            for (let letter of letters) {
                if (!letter.collected) {
                    letter.update();
                    letter.draw();
                }
            }

            // Update and draw player
            if (player && !gameWon) {
                player.update();
                player.draw();
                
                // Check for letter collection
                for (let letter of letters) {
                    if (letter.checkCollision(player)) {
                        letter.collected = true;
                        collectedLetters.push(letter);
                        
                        // Add points for the letter
                        score += COLLECTIBLE_LETTER_POINTS;
                        scoreElement.textContent = score;
                        
                        console.log(`Collected letter: ${letter.char} (${collectedLetters.length}/${targetWord.length})`);
                    }
                }
                
                // Check if player reached the goal platform
                if (goalPlatform && player.checkCollision(goalPlatform)) {
                    // Calculate bonuses if all letters were collected
                    if (collectedLetters.length === targetWord.length) {
                        wordCompleteBonus = WORD_COMPLETE_BONUS;
                        score += wordCompleteBonus;
                        
                        // Check if letters were collected in correct order
                        let correctOrder = true;
                        for (let i = 0; i < collectedLetters.length; i++) {
                            if (collectedLetters[i].index !== i) {
                                correctOrder = false;
                                break;
                            }
                        }
                        
                        if (correctOrder) {
                            correctOrderBonus = CORRECT_ORDER_BONUS;
                            score += correctOrderBonus;
                        }
                        
                        scoreElement.textContent = score;
                    }
                    gameWon = true;
                }
            } else if (player && gameWon) {
                // Just draw the player when game is won, don't update
                player.draw();
            }

            // Restore context for UI overlay (drawn in screen space, not world space)
            ctx.restore();

            // Draw game info overlay (score, time)
            drawGameInfoOverlay();

            // Draw collected letters display
            drawCollectedLetters();

            // Draw win message if game is won
            if (gameWon) {
                drawWinMessage();
            }
            
            // Draw zoom level indicator
            drawZoomIndicator();

            requestAnimationFrame(gameLoop);
        }

        // Draw zoom level indicator
        function drawZoomIndicator() {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(canvas.width - 80, canvas.height - 40, 70, 30);
            
            ctx.fillStyle = '#FFF';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.round(camera.zoom * 100)}%`, canvas.width - 45, canvas.height - 25);
            ctx.restore();
        }

        // Draw game info overlay (score, time, controls hint)
        function drawGameInfoOverlay() {
            ctx.save();
            
            // Top-right corner - Score and Time
            const infoX = canvas.width - 10;
            const infoY = 10;
            
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.lineWidth = 4;
            ctx.fillStyle = '#FFD700';
            
            const scoreText = `Score: ${score}`;
            ctx.strokeText(scoreText, infoX, infoY);
            ctx.fillText(scoreText, infoX, infoY);
            
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const timeText = `Time: ${elapsedTime}s`;
            ctx.strokeText(timeText, infoX, infoY + 22);
            ctx.fillText(timeText, infoX, infoY + 22);
            
            // Bottom-left corner - Controls hint
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobile) {
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                const controlsY = canvas.height - 10;
                ctx.fillText('Controls: Arrows/Space or A/W/D | Zoom: +/- or Wheel | R: Respawn | G: Regenerate Level', 10, controlsY);
            }
            
            ctx.restore();
        }

        function drawDebugOverlay() {
            const gridSize = debugGridSize;
            if (!gridSize) return;

            // Solid grid hint
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = '#00bcd4';

            for (let cy = 0; cy < debugSolidGrid.length; cy++) {
                const row = debugSolidGrid[cy];
                for (let cx = 0; cx < row.length; cx++) {
                    if (!row[cx]) continue;
                    const x = cx * gridSize;
                    const y = cy * gridSize;
                    const w = Math.min(gridSize, canvas.width - x);
                    const h = Math.min(gridSize, canvas.height - y);
                    ctx.fillRect(x, y, w, h);
                }
            }

            // Helper platforms highlight
            ctx.globalAlpha = 1;
            ctx.strokeStyle = 'rgba(80, 120, 255, 1)';
            ctx.lineWidth = 2;
            for (const p of debugHelperPlatforms) {
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            }

            // ML detected objects overlay (only in debug mode)
            if (debugOverlayEnabled && debugDetectedObjects && debugDetectedObjects.length > 0) {
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                
                for (const detection of debugDetectedObjects) {
                    const [x, y, w, h] = detection.bbox;
                    
                    // Draw bounding box
                    if (detection.isPlatformable) {
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                    } else {
                        ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                    }
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                    
                    // Draw label background
                    const label = `${detection.class} (${Math.round(detection.confidence * 100)}%)`;
                    const textWidth = ctx.measureText(label).width;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(x, y - 16, textWidth + 6, 16);
                    
                    // Draw label text
                    ctx.fillStyle = detection.isPlatformable ? '#00ff00' : '#ffa500';
                    ctx.fillText(label, x + 3, y - 4);
                }
            }

            ctx.restore();
        }

        // Draw collected letters display at the top of the screen
        function drawCollectedLetters() {
            if (letters.length === 0) return;
            
            ctx.save();
            
            // Calculate panel width based on content
            const letterSpacing = 25;
            const panelPadding = 20;
            const labelWidth = 60;
            const progressWidth = 40;
            const panelWidth = labelWidth + (targetWord.length * letterSpacing) + progressWidth + panelPadding;
            
            // Draw background panel (compact, left-aligned)
            const panelHeight = 35;
            const panelY = 10;
            const panelX = 10;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
            
            // Draw label
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText('Word:', panelX + 10, panelY + panelHeight / 2);
            
            // Draw target word letters
            const startX = panelX + labelWidth;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            
            // Create a Set of collected indices for O(1) lookup during rendering
            const collectedIndices = new Set(collectedLetters.map(l => l.index));
            
            for (let i = 0; i < targetWord.length; i++) {
                const x = startX + i * letterSpacing;
                const y = panelY + panelHeight / 2;
                
                // Check if this letter has been collected
                const collected = collectedIndices.has(i);
                
                // Draw letter circle
                if (collected) {
                    ctx.fillStyle = '#FFD700';
                } else {
                    ctx.fillStyle = '#555';
                }
                ctx.beginPath();
                ctx.arc(x, y, 9, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw letter
                ctx.fillStyle = collected ? '#000' : '#AAA';
                ctx.fillText(targetWord[i], x, y);
            }
            
            // Draw collection progress
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`${collectedLetters.length}/${targetWord.length}`, panelX + panelWidth - 10, panelY + panelHeight / 2);
            
            ctx.restore();
        }

        // Draw win message overlay
        function drawWinMessage() {
            // Calculate message height based on content
            let messageHeight = 100;
            let yOffset = 0;
            
            if (collectedLetters.length === targetWord.length) {
                messageHeight = 180;
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, canvas.height / 2 - messageHeight / 2, canvas.width, messageHeight);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üéâ YOU WIN! üéâ', canvas.width / 2, canvas.height / 2 - 50);
            
            // Show word if all letters were collected
            if (collectedLetters.length === targetWord.length) {
                ctx.font = 'bold 28px Arial';
                ctx.fillStyle = '#00FF00';
                ctx.fillText(`You spelled: ${targetWord}!`, canvas.width / 2, canvas.height / 2 - 15);
                
                // Show bonuses
                ctx.font = '18px Arial';
                ctx.fillStyle = '#FFF';
                yOffset = 10;
                ctx.fillText(`Word Complete Bonus: +${wordCompleteBonus}`, canvas.width / 2, canvas.height / 2 + yOffset);
                
                if (correctOrderBonus > 0) {
                    yOffset += 25;
                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(`‚ú® Correct Order Bonus: +${correctOrderBonus} ‚ú®`, canvas.width / 2, canvas.height / 2 + yOffset);
                }
                
                yOffset += 30;
            } else {
                yOffset = 0;
            }
            
            ctx.font = '20px Arial';
            ctx.fillStyle = '#FFF';
            ctx.fillText(`Time: ${Math.floor((Date.now() - startTime) / 1000)}s`, canvas.width / 2, canvas.height / 2 + yOffset + 30);
            ctx.font = '16px Arial';
            ctx.fillText('Press ESC or click "Exit Game" to return to start', canvas.width / 2, canvas.height / 2 + yOffset + 55);
        }

        // Show intro screen
        function showIntroScreen() {
            introScreen.classList.remove('hidden');
            gameScreen.classList.remove('active');
            exitFullscreen();
        }

        // Show game screen
        function showGameScreen() {
            introScreen.classList.add('hidden');
            gameScreen.classList.add('active');
        }

        // Enter fullscreen
        function enterFullscreen() {
            gameCanvasContainer.classList.add('fullscreen');
            exitFullscreenBtn.classList.add('visible');
            document.body.style.overflow = 'hidden';
        }

        // Exit fullscreen
        function exitFullscreen() {
            gameCanvasContainer.classList.remove('fullscreen');
            exitFullscreenBtn.classList.remove('visible');
            document.body.style.overflow = '';
        }

        // Return to intro and exit fullscreen
        function returnToIntro() {
            resetGame();
            showIntroScreen();
        }

        // Reset game
        function resetGame() {
            gameRunning = false;
            gameWon = false;
            platforms = [];
            player = null;
            goal = null;  // Clear goal
            score = 0;
            letters = [];  // Clear letters
            collectedLetters = [];  // Clear collected letters
            targetWord = '';  // Clear target word
            wordCompleteBonus = 0;
            correctOrderBonus = 0;
            backgroundImage = null; // Clear background image
            canvas.style.display = 'none';
            gameInfo.style.display = 'none';
            resetBtn.style.display = 'none';
            uploadBtn.style.display = 'inline-block';
            cameraBtn.style.display = 'inline-block';
        }

        function guessDeviceType() {
            const ua = (navigator.userAgent || '').toLowerCase();
            if (ua.includes('ipad') || ua.includes('tablet')) return 'tablet';
            if (ua.includes('iphone') || ua.includes('android')) {
                return ua.includes('mobile') ? 'mobile' : 'tablet';
            }
            if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) {
                return window.innerWidth >= 768 ? 'tablet' : 'mobile';
            }
            return 'desktop';
        }

        function setFeedbackStatus(text, kind) {
            feedbackStatus.textContent = text || '';
            feedbackStatus.classList.remove('error', 'success');
            if (kind) feedbackStatus.classList.add(kind);
        }

        function openFeedbackModal() {
            feedbackDeviceType.value = guessDeviceType();
            setFeedbackStatus('', null);
            feedbackModal.classList.add('open');
            feedbackModal.setAttribute('aria-hidden', 'false');

            if (location.protocol === 'file:') {
                setFeedbackStatus('Feedback requires running the local server (not file://).', 'error');
            }

            setTimeout(() => {
                feedbackMessage.focus();
            }, 0);
        }

        function closeFeedbackModal() {
            feedbackModal.classList.remove('open');
            feedbackModal.setAttribute('aria-hidden', 'true');
        }

        async function postFeedback(message, deviceType, token) {
            const headers = {
                'Content-Type': 'application/json'
            };
            if (token) headers['X-Feedback-Token'] = token;

            return fetch('/api/feedback', {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    message,
                    deviceType
                })
            });
        }

        function shouldIgnoreGameKeyEvent(e) {
            if (feedbackModal.classList.contains('open')) return true;
            const target = e.target;
            if (!target) return false;
            if (target.isContentEditable) return true;
            const tag = (target.tagName || '').toUpperCase();
            return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        }

        function updateLanHint() {
            if (location.protocol === 'file:') {
                lanHint.classList.remove('open');
                return;
            }

            lanHint.classList.add('open');
            lanUrl.textContent = location.href;

            const host = (location.hostname || '').toLowerCase();
            if (host === 'localhost' || host === '127.0.0.1') {
                lanNote.innerHTML = 'If you\'re sharing to other devices, replace <strong>localhost</strong> with the host computer\'s LAN IP (e.g. <strong>192.168.x.x</strong>).';
            } else if (host === '0.0.0.0') {
                lanNote.innerHTML = 'Use the host computer\'s LAN IP instead of <strong>0.0.0.0</strong> when sharing (e.g. <strong>192.168.x.x</strong>).';
            } else {
                lanNote.textContent = 'Open this URL on devices connected to the same network.';
            }
        }

        if (debugOverlayToggle) {
            debugOverlayToggle.checked = DEBUG_DEFAULT_ENABLED;
            debugOverlayToggle.addEventListener('change', () => {
                debugOverlayEnabled = Boolean(debugOverlayToggle.checked);
            });
        }

        // ML Detection toggle handling
        const mlDetectionToggle = document.getElementById('mlDetectionToggle');
        if (mlDetectionToggle) {
            mlDetectionToggle.checked = ML_DETECTION_ENABLED_DEFAULT;
            mlDetectionToggle.addEventListener('change', async () => {
                mlDetectionEnabled = Boolean(mlDetectionToggle.checked);
                
                if (mlDetectionEnabled && !onnxModelLoaded && !onnxModelLoading) {
                    // Reset error state to allow retry
                    onnxLoadError = null;
                    
                    // Start loading the ONNX model when user enables ML detection
                    const success = await initONNXModel();
                    if (!success) {
                        // If loading fails, disable the toggle and show helpful message
                        mlDetectionToggle.checked = false;
                        mlDetectionEnabled = false;
                        
                        // Show actual error from console
                        const errorMsg = onnxLoadError?.message || 'Unknown error';
                        alert('ML detection failed to load.\n\n' +
                            'Error: ' + errorMsg + '\n\n' +
                            'Check browser console (F12) for details.\n\n' +
                            'Common fixes:\n' +
                            '- Refresh the page\n' +
                            '- Check internet connection (CDN needed)\n' +
                            '- Clear browser cache\n\n' +
                            'See docs/ONNX_SETUP.md for full troubleshooting.');
                    }
                } else if (mlDetectionEnabled && onnxModelLoaded) {
                    updateMLStatus('ML ready');
                } else {
                    updateMLStatus('');
                }
            });
        }

        async function copyLanLink() {
            const text = location.href;
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const temp = document.createElement('textarea');
                    temp.value = text;
                    temp.style.position = 'fixed';
                    temp.style.left = '-9999px';
                    document.body.appendChild(temp);
                    temp.focus();
                    temp.select();
                    document.execCommand('copy');
                    document.body.removeChild(temp);
                }
                copyLinkBtn.textContent = 'Copied';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 900);
            } catch {
                copyLinkBtn.textContent = 'Copy failed';
                setTimeout(() => {
                    copyLinkBtn.textContent = 'Copy';
                }, 1200);
            }
        }

        // Event listeners
        startGameBtn.addEventListener('click', showGameScreen);
        exitFullscreenBtn.addEventListener('click', returnToIntro);
        
        uploadBtn.addEventListener('click', () => fileInput.click());
        cameraBtn.addEventListener('click', () => cameraInput.click());
        resetBtn.addEventListener('click', returnToIntro);

        copyLinkBtn.addEventListener('click', copyLanLink);

        feedbackBtn.addEventListener('click', openFeedbackModal);
        feedbackCancelBtn.addEventListener('click', closeFeedbackModal);
        feedbackModal.addEventListener('click', (e) => {
            if (e.target === feedbackModal) closeFeedbackModal();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please select a valid image file.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('File is too large. Please select an image under 10MB.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try a different file.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read file. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        cameraInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Validate file type
                if (!file.type.match('image.*')) {
                    alert('Please capture a valid image.');
                    return;
                }
                
                // Validate file size
                if (file.size > MAX_FILE_SIZE) {
                    alert('Image is too large. Please try again.');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImage(img);
                    img.onerror = () => {
                        alert('Failed to load image. Please try again.');
                    };
                    img.src = event.target.result;
                };
                reader.onerror = () => {
                    alert('Failed to read image. Please try again.');
                };
                reader.readAsDataURL(file);
            }
        });

        feedbackForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const message = (feedbackMessage.value || '').trim();
            const deviceType = feedbackDeviceType.value || 'unknown';

            if (!message) {
                setFeedbackStatus('Please enter a message.', 'error');
                return;
            }

            feedbackSubmitBtn.disabled = true;
            setFeedbackStatus('Sending‚Ä¶', null);

            try {
                let token = localStorage.getItem(FEEDBACK_TOKEN_STORAGE_KEY) || '';
                let response = await postFeedback(message, deviceType, token);

                if (response.status === 401) {
                    const enteredToken = window.prompt('This server requires an access code. Enter it to send feedback:');
                    if (enteredToken) {
                        localStorage.setItem(FEEDBACK_TOKEN_STORAGE_KEY, enteredToken);
                        token = enteredToken;
                        response = await postFeedback(message, deviceType, token);
                    }
                }

                if (!response.ok) {
                    const text = await response.text();
                    setFeedbackStatus(`Failed to send feedback (${response.status}). ${text ? 'Details: ' + text : ''}`.trim(), 'error');
                    return;
                }

                feedbackMessage.value = '';
                setFeedbackStatus('Sent. Thank you!', 'success');

                setTimeout(() => {
                    closeFeedbackModal();
                }, 700);
            } catch (err) {
                setFeedbackStatus('Failed to send feedback. Is the local server running?', 'error');
            } finally {
                feedbackSubmitBtn.disabled = false;
            }
        });

        updateLanHint();

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // ESC key returns to intro screen
            if (e.key === 'Escape') {
                if (gameScreen.classList.contains('active')) {
                    returnToIntro();
                    e.preventDefault();
                }
                return;
            }
            
            if (shouldIgnoreGameKeyEvent(e)) return;
            
            // Zoom controls with + and - keys
            if (e.key === '=' || e.key === '+') {
                camera.zoom = Math.min(camera.maxZoom, camera.zoom + 0.1);
                e.preventDefault();
                return;
            }
            if (e.key === '-' || e.key === '_') {
                camera.zoom = Math.max(camera.minZoom, camera.zoom - 0.1);
                e.preventDefault();
                return;
            }
            // Reset zoom with '0'
            if (e.key === '0') {
                camera.zoom = 1.0;
                e.preventDefault();
                return;
            }
            
            // Manual respawn with 'R' key
            if ((e.key === 'r' || e.key === 'R') && player && gameRunning) {
                player.respawn();
                e.preventDefault();
                return;
            }
            
            // Regenerate level with 'G' key
            if ((e.key === 'g' || e.key === 'G') && backgroundImage && gameRunning) {
                console.log('Regenerating level...');
                processImage(backgroundImage);
                e.preventDefault();
                return;
            }
            
            keys[e.key] = true;
            // Prevent default for arrow keys and space
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!gameRunning) return;
            
            const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
            camera.zoom = Math.max(camera.minZoom, Math.min(camera.maxZoom, camera.zoom + zoomDelta));
        }, { passive: false });

        // Resize canvas when window resizes
        window.addEventListener('resize', () => {
            if (gameRunning) {
                resizeCanvas();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (shouldIgnoreGameKeyEvent(e)) return;
            keys[e.key] = false;
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchStartY = touch.clientY - rect.top;
            
            // Jump on tap
            touchJumping = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // Horizontal movement based on touch position
            const deltaX = touchX - touchStartX;
            
            if (deltaX < -20) {
                keys['ArrowLeft'] = true;
                keys['ArrowRight'] = false;
            } else if (deltaX > 20) {
                keys['ArrowRight'] = true;
                keys['ArrowLeft'] = false;
            } else {
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });

        // Mobile control button handlers
        // Detect if device supports touch and show controls
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            mobileControls.classList.add('visible');
        }

        // Left button
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        leftBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });

        // Right button
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        rightBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        rightBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });

        // Jump button
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchJumping = true;
        });
        jumpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchJumping = false;
        });
        jumpBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchJumping = false;
        });

        // Zoom control buttons
        zoomInBtn.addEventListener('click', (e) => {
            e.preventDefault();
            camera.zoom = Math.min(camera.maxZoom, camera.zoom + 0.2);
        });

        zoomOutBtn.addEventListener('click', (e) => {
            e.preventDefault();
            camera.zoom = Math.max(camera.minZoom, camera.zoom - 0.2);
        });

        zoomResetBtn.addEventListener('click', (e) => {
            e.preventDefault();
            camera.zoom = 1.0;
        });

        // Touch support for zoom buttons
        zoomInBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            camera.zoom = Math.min(camera.maxZoom, camera.zoom + 0.2);
        });

        zoomOutBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            camera.zoom = Math.max(camera.minZoom, camera.zoom - 0.2);
        });

        zoomResetBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            camera.zoom = 1.0;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && feedbackModal.classList.contains('open')) {
                closeFeedbackModal();
            }
        });

        // Register Service Worker for PWA/offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
